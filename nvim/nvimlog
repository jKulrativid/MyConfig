
Executing:     vnoremenu PopUp.Cut                     "+x
Executing:     vnoremenu PopUp.Copy                    "+y
Executing:     anoremenu PopUp.Paste                   "+gP
Executing:     vnoremenu PopUp.Paste                   "+P
Executing:     vnoremenu PopUp.Delete                  "_x
Executing:     nnoremenu PopUp.Select\ All             ggVG
Executing:     vnoremenu PopUp.Select\ All             gg0oG$
Executing:     inoremenu PopUp.Select\ All             <C-Home><C-O>VG
Executing:     anoremenu PopUp.Inspect                 <Cmd>Inspect<CR>
Executing:     anoremenu PopUp.-1-                     <Nop>
Executing:     anoremenu PopUp.How-to\ disable\ mouse  <Cmd>help disable-mouse<CR>
Executing:   
Searching for "ftplugin.vim" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/ftplugin.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin.vim"
sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last change:^I2023 Aug 10
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: if exists("did_load_ftplugin")
line 8:   finish
line 9: endif
line 10: let did_load_ftplugin = 1
line 11: 
line 12: augroup filetypeplugin
line 13:   au FileType * call s:LoadFTPlugin()
line 14: 
line 15:   func! s:LoadFTPlugin()
line 39: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin.vim
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/ftplugin.vim"
Searching for "indent.vim" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/indent.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/indent.vim"
sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last Change:^I2023 Aug 10
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: if exists("did_indent_on")
line 8:   finish
line 9: endif
line 10: let did_indent_on = 1
line 11: 
line 12: augroup filetypeindent
line 13:   au FileType * call s:LoadIndent()
line 14:   func! s:LoadIndent()
line 33: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/indent.vim
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/indent.vim"
could not source "/opt/homebrew/etc/xdg/nvim/sysinit.vim"
could not source "/etc/xdg/nvim/sysinit.vim"
could not source "$VIM/sysinit.vim"
sourcing "/Users/jkulrativid/.config/nvim/init.lua"
Executing: let g:netrw_liststyle = 3
Searching for "spell/en.utf-8.spl" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/spell/en.utf-8.spl"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/spell/en.utf-8.spl"
Reading spell file "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/spell/en.utf-8.spl"
Searching for "spell/en.utf-8.add.spl" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/spell/en.utf-8.add.spl"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/spell/en.utf-8.add.spl"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/spell/en.utf-8.add.spl"
not found in runtime path: "spell/en.utf-8.add.spl"
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/filetype.lua
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/filetype.lua"
Executing:   augroup filetypedetect
Executing:   runtime! ftdetect/*.{vim,lua}
Searching for "ftdetect/*.{vim,lua}" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/ftdetect/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/ftdetect/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftdetect/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/ftdetect/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/ftdetect/*.{vim,lua}"
not found in runtime path: "ftdetect/*.{vim,lua}"
Executing:   augroup END
Executing:   
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/filetype.lua
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: augroup filetypedetect
Executing: augroup END
Executing ColorSchemePre Autocommands for "*"
autocommand <Lua 30: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/loader.lua:31>

Executing: 
Searching for "colors/catppuccin.*" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/colors/catppuccin.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/colors/catppuccin.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/colors/catppuccin.*"
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/colors/catppuccin.vim"
line 1: lua require("catppuccin").load()
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/catppuccin/colors/catppuccin.vim
continuing in /Users/jkulrativid/.config/nvim/init.lua
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/plugin/plenary.vim
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/plugin/plenary.vim"
line 1: 
line 2: " Create command for running busted
line 3: command! -nargs=1 -complete=file PlenaryBustedFile lua require('plenary.test_harness').test_file([[<args>]])
line 5: 
line 6: command! -nargs=+ -complete=file PlenaryBustedDirectory lua require('plenary.test_harness').test_directory_command([[<args>]])
line 8: 
line 9: nnoremap <Plug>PlenaryTestFile :lua require('plenary.test_harness').test_file(vim.fn.expand("%:p"))<CR>
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/plugin/plenary.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/plugin/nvim-web-devicons.vim
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/plugin/nvim-web-devicons.vim"
line 1: if exists('g:loaded_devicons') | finish | endif
line 1:  finish | endif
line 1:  endif
line 2: 
line 3: let s:save_cpo = &cpo
line 4: set cpo&vim
line 5: 
line 6: " TODO change so its easier to get
line 7: let g:nvim_web_devicons = 1
line 8: 
line 9: let &cpo = s:save_cpo
line 10: unlet s:save_cpo
line 11: 
line 12: let g:loaded_devicons = 1
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/plugin/nvim-web-devicons.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/plugin/telescope.lua
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/plugin/telescope.lua"
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/plugin/telescope.lua
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing:   highlight default link NvimDapVirtualText Comment
Executing:   highlight default link NvimDapVirtualTextChanged DiagnosticVirtualTextWarn
Executing:   highlight default link NvimDapVirtualTextError DiagnosticVirtualTextError
Executing:   highlight default link NvimDapVirtualTextInfo DiagnosticVirtualTextInfo
Executing:   
Executing:     command! DapVirtualTextEnable :lua require'nvim-dap-virtual-text'.enable()
Executing:     command! DapVirtualTextDisable :lua require'nvim-dap-virtual-text'.disable()
Executing:     command! DapVirtualTextToggle :lua require'nvim-dap-virtual-text'.toggle()
Executing:     command! DapVirtualTextForceRefresh :lua require'nvim-dap-virtual-text'.refresh()
Executing:     
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/plugin/dap.lua
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/plugin/dap.lua"
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/plugin/dap.lua
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: augroup filetypedetect
Executing: augroup END
Executing:  highlight default link NvimDapSubtleFrame Comment 
Executing:  highlight default link NvimDapSubtleFrame Comment 
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/plugin/lsplines.vim
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/plugin/lsplines.vim"
line 1: if exists("g:loaded_lsplines")
line 2:   finish
line 3: endif
line 4: 
line 5: lua require("lsp_lines").setup()
line 6: 
line 7: let g:loaded_lsplines = 1
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/plugin/lsplines.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup lualine | exe "autocmd!" | augroup END
Executing:  exe "autocmd!" | augroup END
Executing: autocmd!
Executing:  augroup END
Executing: highlight! lualine_b_normal guifg=#c3ccdc guibg=#112638 gui=None
Executing: highlight! lualine_a_normal guifg=#112638 guibg=#65D1FF gui=bold
Executing: highlight! lualine_c_normal guifg=#c3ccdc guibg=#112638 gui=None
Executing: highlight! lualine_b_replace guifg=#c3ccdc guibg=#112638 gui=None
Executing: highlight! lualine_a_replace guifg=#112638 guibg=#FF4A4A gui=bold
Executing: highlight! lualine_c_replace guifg=#c3ccdc guibg=#112638 gui=None
Executing: highlight! lualine_b_inactive guifg=None guibg=#2c3043 gui=None
Executing: highlight! lualine_a_inactive guifg=None guibg=#2c3043 gui=bold
Executing: highlight! lualine_c_inactive guifg=None guibg=#2c3043 gui=None
Executing: highlight! lualine_b_command guifg=#c3ccdc guibg=#112638 gui=None
Executing: highlight! lualine_a_command guifg=#112638 guibg=#FFDA7B gui=bold
Executing: highlight! lualine_c_command guifg=#c3ccdc guibg=#112638 gui=None
Executing: highlight! lualine_b_visual guifg=#c3ccdc guibg=#112638 gui=None
Executing: highlight! lualine_a_visual guifg=#112638 guibg=#FF61EF gui=bold
Executing: highlight! lualine_c_visual guifg=#c3ccdc guibg=#112638 gui=None
Executing: highlight! lualine_b_insert guifg=#c3ccdc guibg=#112638 gui=None
Executing: highlight! lualine_a_insert guifg=#112638 guibg=#3EFFDC gui=bold
Executing: highlight! lualine_c_insert guifg=#c3ccdc guibg=#112638 gui=None
Executing: autocmd lualine ColorScheme * lua require'lualine'.setup()
Executing:     autocmd lualine OptionSet background lua require'lualine'.setup()
Searching for "lua/lualine/components/copilot.lua" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/lua/lualine/components/copilot.lua"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/lualine/components/copilot.lua"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/lua/lualine/components/copilot.lua"
Executing: highlight! lualine_x_copilot_sleep_normal guifg=#AEB7D0 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_sleep_insert guifg=#AEB7D0 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_sleep_visual guifg=#AEB7D0 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_sleep_replace guifg=#AEB7D0 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_sleep_command guifg=#AEB7D0 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_sleep_terminal guifg=#AEB7D0 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_sleep_inactive guifg=#AEB7D0 guibg=#2c3043 gui=None
Executing: highlight! lualine_x_copilot_enabled_normal guifg=#50FA7B guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_enabled_insert guifg=#50FA7B guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_enabled_visual guifg=#50FA7B guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_enabled_replace guifg=#50FA7B guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_enabled_command guifg=#50FA7B guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_enabled_terminal guifg=#50FA7B guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_enabled_inactive guifg=#50FA7B guibg=#2c3043 gui=None
Executing: highlight! lualine_x_copilot_disabled_normal guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_disabled_insert guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_disabled_visual guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_disabled_replace guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_disabled_command guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_disabled_terminal guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_disabled_inactive guifg=#6272A4 guibg=#2c3043 gui=None
Executing: highlight! lualine_x_copilot_offline_normal guifg=#FFB86C guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_offline_insert guifg=#FFB86C guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_offline_visual guifg=#FFB86C guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_offline_replace guifg=#FFB86C guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_offline_command guifg=#FFB86C guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_offline_terminal guifg=#FFB86C guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_offline_inactive guifg=#FFB86C guibg=#2c3043 gui=None
Executing: highlight! lualine_x_copilot_unknown_normal guifg=#FF5555 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_unknown_insert guifg=#FF5555 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_unknown_visual guifg=#FF5555 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_unknown_replace guifg=#FF5555 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_unknown_command guifg=#FF5555 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_unknown_terminal guifg=#FF5555 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_unknown_inactive guifg=#FF5555 guibg=#2c3043 gui=None
Executing: highlight! lualine_x_copilot_spinner_normal guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_spinner_insert guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_spinner_visual guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_spinner_replace guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_spinner_command guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_spinner_terminal guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_spinner_inactive guifg=#6272A4 guibg=#2c3043 gui=None
Executing: highlight! lualine_x_5_normal guifg=#ff9e64 guibg=#112638 gui=None
Executing: highlight! lualine_x_5_insert guifg=#ff9e64 guibg=#112638 gui=None
Executing: highlight! lualine_x_5_visual guifg=#ff9e64 guibg=#112638 gui=None
Executing: highlight! lualine_x_5_replace guifg=#ff9e64 guibg=#112638 gui=None
Executing: highlight! lualine_x_5_command guifg=#ff9e64 guibg=#112638 gui=None
Executing: highlight! lualine_x_5_terminal guifg=#ff9e64 guibg=#112638 gui=None
Executing: highlight! lualine_x_5_inactive guifg=#ff9e64 guibg=#2c3043 gui=None
Executing: au lualine BufEnter *
--- Autocommands ---
Executing: autocmd lualine BufEnter * lua require'lualine.components.branch.git_branch'.find_git_dir()
Executing: highlight! lualine_b_diff_added_normal guifg=#a6da95 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_added_insert guifg=#a6da95 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_added_visual guifg=#a6da95 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_added_replace guifg=#a6da95 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_added_command guifg=#a6da95 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_added_terminal guifg=#a6da95 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_added_inactive guifg=#a6da95 guibg=#2c3043 gui=None
Executing: highlight! lualine_b_diff_modified_normal guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_modified_insert guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_modified_visual guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_modified_replace guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_modified_command guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_modified_terminal guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_modified_inactive guifg=#eed49f guibg=#2c3043 gui=None
Executing: highlight! lualine_b_diff_removed_normal guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_removed_insert guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_removed_visual guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_removed_replace guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_removed_command guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_removed_terminal guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_removed_inactive guifg=#ed8796 guibg=#2c3043 gui=None
Executing: au lualine BufEnter *
--- Autocommands ---
lualine  BufEnter
    *         lua require'lualine.components.branch.git_branch'.find_git_dir()
	Last set from ~/.config/nvim/vim/_editor.lua
Executing: autocmd lualine BufEnter * lua require'lualine.components.diff.git_diff'.update_diff_args()
Executing: au lualine BufWritePost *
--- Autocommands ---
Executing: autocmd lualine BufWritePost * lua require'lualine.components.diff.git_diff'.update_git_diff()
Executing: highlight! lualine_b_diagnostics_error_normal guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_error_insert guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_error_visual guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_error_replace guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_error_command guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_error_terminal guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_error_inactive guifg=#ed8796 guibg=#2c3043 gui=None
Executing: highlight! lualine_b_diagnostics_warn_normal guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_warn_insert guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_warn_visual guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_warn_replace guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_warn_command guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_warn_terminal guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_warn_inactive guifg=#eed49f guibg=#2c3043 gui=None
Executing: highlight! lualine_b_diagnostics_info_normal guifg=#91d7e3 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_info_insert guifg=#91d7e3 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_info_visual guifg=#91d7e3 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_info_replace guifg=#91d7e3 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_info_command guifg=#91d7e3 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_info_terminal guifg=#91d7e3 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_info_inactive guifg=#91d7e3 guibg=#2c3043 gui=None
Executing: highlight! lualine_b_diagnostics_hint_normal guifg=#8bd5ca guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_hint_insert guifg=#8bd5ca guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_hint_visual guifg=#8bd5ca guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_hint_replace guifg=#8bd5ca guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_hint_command guifg=#8bd5ca guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_hint_terminal guifg=#8bd5ca guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_hint_inactive guifg=#8bd5ca guibg=#2c3043 gui=None
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing:   augroup DAPUIRefreshHighlights
Executing:     autocmd!
Executing:     autocmd ColorScheme * lua require('dapui.config.highlights').setup()
Executing:   augroup END
Executing:   hi default link DapUINormal Normal
Executing:   hi default link DapUIVariable Normal
Executing:   hi default DapUIScope guifg=#00F1F5
Executing:   hi default DapUIType guifg=#D484FF
Executing:   hi default link DapUIValue Normal
Executing:   hi default DapUIModifiedValue guifg=#00F1F5 gui=bold
Executing:   hi default DapUIDecoration guifg=#00F1F5
Executing:   hi default DapUIThread guifg=#A9FF68
Executing:   hi default DapUIStoppedThread guifg=#00f1f5
Executing:   hi default link DapUIFrameName Normal
Executing:   hi default DapUISource guifg=#D484FF
Executing:   hi default DapUILineNumber guifg=#00f1f5
Executing:   hi default link DapUIFloatNormal NormalFloat
Executing:   hi default DapUIFloatBorder guifg=#00F1F5
Executing:   hi default DapUIWatchesEmpty guifg=#F70067
Executing:   hi default DapUIWatchesValue guifg=#A9FF68
Executing:   hi default DapUIWatchesError guifg=#F70067
Executing:   hi default DapUIBreakpointsPath guifg=#00F1F5
Executing:   hi default DapUIBreakpointsInfo guifg=#A9FF68
Executing:   hi default DapUIBreakpointsCurrentLine guifg=#A9FF68 gui=bold
Executing:   hi default link DapUIBreakpointsLine DapUILineNumber
Executing:   hi default DapUIBreakpointsDisabledLine guifg=#424242
Executing:   hi default link DapUICurrentFrameName DapUIBreakpointsCurrentLine
Executing:   hi default DapUIStepOver guifg=#00f1f5
Executing:   hi default DapUIStepInto guifg=#00f1f5
Executing:   hi default DapUIStepBack guifg=#00f1f5
Executing:   hi default DapUIStepOut guifg=#00f1f5
Executing:   hi default DapUIStop guifg=#F70067
Executing:   hi default DapUIPlayPause guifg=#A9FF68
Executing:   hi default DapUIRestart guifg=#A9FF68
Executing:   hi default DapUIUnavailable guifg=#424242
Executing:   hi default DapUIWinSelect ctermfg=Cyan guifg=#00f1f5 gui=bold
Executing:   hi default link DapUIEndofBuffer EndofBuffer
Executing:   
Executing:   hi default link DapUINormal Normal
Executing:   hi default link DapUIVariable Normal
Executing:   hi default DapUIScope guifg=#00F1F5
Executing:   hi default DapUIType guifg=#D484FF
Executing:   hi default link DapUIValue Normal
Executing:   hi default DapUIModifiedValue guifg=#00F1F5 gui=bold
Executing:   hi default DapUIDecoration guifg=#00F1F5
Executing:   hi default DapUIThread guifg=#A9FF68
Executing:   hi default DapUIStoppedThread guifg=#00f1f5
Executing:   hi default link DapUIFrameName Normal
Executing:   hi default DapUISource guifg=#D484FF
Executing:   hi default DapUILineNumber guifg=#00f1f5
Executing:   hi default link DapUIFloatNormal NormalFloat
Executing:   hi default DapUIFloatBorder guifg=#00F1F5
Executing:   hi default DapUIWatchesEmpty guifg=#F70067
Executing:   hi default DapUIWatchesValue guifg=#A9FF68
Executing:   hi default DapUIWatchesError guifg=#F70067
Executing:   hi default DapUIBreakpointsPath guifg=#00F1F5
Executing:   hi default DapUIBreakpointsInfo guifg=#A9FF68
Executing:   hi default DapUIBreakpointsCurrentLine guifg=#A9FF68 gui=bold
Executing:   hi default link DapUIBreakpointsLine DapUILineNumber
Executing:   hi default DapUIBreakpointsDisabledLine guifg=#424242
Executing:   hi default link DapUICurrentFrameName DapUIBreakpointsCurrentLine
Executing:   hi default DapUIStepOver guifg=#00f1f5
Executing:   hi default DapUIStepInto guifg=#00f1f5
Executing:   hi default DapUIStepBack guifg=#00f1f5
Executing:   hi default DapUIStepOut guifg=#00f1f5
Executing:   hi default DapUIStop guifg=#F70067
Executing:   hi default DapUIPlayPause guifg=#A9FF68
Executing:   hi default DapUIRestart guifg=#A9FF68
Executing:   hi default DapUIUnavailable guifg=#424242
Executing:   hi default DapUIWinSelect ctermfg=Cyan guifg=#00f1f5 gui=bold
Executing:   hi default link DapUIEndofBuffer EndofBuffer
Executing:   
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/plugin/tmux_navigator.vim
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/plugin/tmux_navigator.vim"
line 1: " Maps <C-h/j/k/l> to switch vim splits in the given direction. If there are
line 2: " no more windows in that direction, forwards the operation to tmux.
line 3: " Additionally, <C-\> toggles between last active vim splits/tmux panes.
line 4: 
line 5: if exists("g:loaded_tmux_navigator") || &cp || v:version < 700
line 6:   finish
line 7: endif
line 8: let g:loaded_tmux_navigator = 1
line 9: 
line 10: function! s:VimNavigate(direction)
line 17: 
line 18: if !get(g:, 'tmux_navigator_no_mappings', 0)
line 19:   nnoremap <silent> <c-h> :<C-U>TmuxNavigateLeft<cr>
line 20:   nnoremap <silent> <c-j> :<C-U>TmuxNavigateDown<cr>
line 21:   nnoremap <silent> <c-k> :<C-U>TmuxNavigateUp<cr>
line 22:   nnoremap <silent> <c-l> :<C-U>TmuxNavigateRight<cr>
line 23:   nnoremap <silent> <c-\> :<C-U>TmuxNavigatePrevious<cr>
line 24: 
line 25:   if !get(g:, 'tmux_navigator_disable_netrw_workaround', 0)
line 26:     if !exists('g:Netrw_UserMaps')
line 27:       let g:Netrw_UserMaps = [['<C-l>', '<C-U>TmuxNavigateRight<cr>']]
line 28:     else
line 29:       echohl ErrorMsg | echo 'vim-tmux-navigator conflicts with netrw <C-l> mapping. See https://github.com/christoomey/vim-tmux-navigator#netrw or add `let g:tmux_navigator_disable_netrw_workaround = 1` to suppress this warning.' | echohl None
line 29:  echo 'vim-tmux-navigator conflicts with netrw <C-l> mapping. See https://github.com/christoomey/vim-tmux-navigator#netrw or add `let g:tmux_navigator_disable_netrw_workaround = 1` to suppress this warning.' | echohl None
line 29:  echohl None
line 30:     endif
line 31:   endif
line 32: endif
line 33: 
line 34: if empty($TMUX)
line 35:   command! TmuxNavigateLeft call s:VimNavigate('h')
line 36:   command! TmuxNavigateDown call s:VimNavigate('j')
line 37:   command! TmuxNavigateUp call s:VimNavigate('k')
line 38:   command! TmuxNavigateRight call s:VimNavigate('l')
line 39:   command! TmuxNavigatePrevious call s:VimNavigate('p')
line 40:   finish
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/plugin/tmux_navigator.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/editorconfig.lua
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/editorconfig.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/editorconfig.lua
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/gzip.vim
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/gzip.vim"
line 1: " Vim plugin for editing compressed files.
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " Exit quickly when:
line 7: " - this plugin was already loaded
line 8: " - when 'compatible' is set
line 9: " - some autocommands are already taking care of compressed files
line 10: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
line 11:   finish
line 12: endif
line 13: let loaded_gzip = 1
line 14: 
line 15: augroup gzip
line 16:   " Remove all gzip autocommands
line 17:   au!
line 18: 
line 19:   " Enable editing of gzipped files.
line 20:   " The functions are defined in autoload/gzip.vim.
line 21:   "
line 22:   " Set binary mode before reading the file.
line 23:   " Use "gzip -d", gunzip isn't always available.
line 24:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst,*.br,*.lzo setlocal bin
line 25:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")
line 26:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")
line 27:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")
line 28:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")
line 29:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")
line 30:   autocmd BufReadPost,FileReadPost^I*.lz  call gzip#read("lzip -d")
line 31:   autocmd BufReadPost,FileReadPost^I*.zst call gzip#read("zstd -d --rm")
line 32:   autocmd BufReadPost,FileReadPost^I*.br call gzip#read("brotli -d --rm")
line 33:   autocmd BufReadPost,FileReadPost^I*.lzo call gzip#read("lzop -d -U")
line 34:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")
line 35:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")
line 36:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")
line 37:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")
line 38:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")
line 39:   autocmd BufWritePost,FileWritePost^I*.lz  call gzip#write("lzip")
line 40:   autocmd BufWritePost,FileWritePost^I*.zst  call gzip#write("zstd --rm")
line 41:   autocmd BufWritePost,FileWritePost^I*.br  call gzip#write("brotli --rm")
line 42:   autocmd BufWritePost,FileWritePost^I*.lzo  call gzip#write("lzop -U")
line 43:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")
line 44:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")
line 45:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")
line 46:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")
line 47:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")
line 48:   autocmd FileAppendPre^I^I^I*.lz   call gzip#appre("lzip -d")
line 49:   autocmd FileAppendPre^I^I^I*.zst call gzip#appre("zstd -d --rm")
line 50:   autocmd FileAppendPre^I^I^I*.br call gzip#appre("brotli -d --rm")
line 51:   autocmd FileAppendPre^I^I^I*.lzo call gzip#appre("lzop -d -U")
line 52:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")
line 53:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")
line 54:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")
line 55:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")
line 56:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")
line 57:   autocmd FileAppendPost^I^I*.lz call gzip#write("lzip")
line 58:   autocmd FileAppendPost^I^I*.zst call gzip#write("zstd --rm")
line 59:   autocmd FileAppendPost^I^I*.br call gzip#write("brotli --rm")
line 60:   autocmd FileAppendPost^I^I*.lzo call gzip#write("lzop -U")
line 61: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/gzip.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/man.lua
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/man.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/man.lua
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/matchit.vim
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/matchit.vim"
line 1: " Nvim: load the matchit plugin by default.
line 2: if !exists("g:loaded_matchit") && stridx(&packpath, $VIMRUNTIME) >= 0
line 3:   packadd matchit
Searching for "pack/*/start/matchit" in "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/*/start/matchit"
not found in 'packpath': "pack/*/start/matchit"
Searching for "pack/*/opt/matchit" in "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/*/opt/matchit"
line 3: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim"
line 1: "  matchit.vim: (global plugin) Extended "%" matching
line 2: "  Maintainer:  Christian Brabandt
line 3: "  Version:     1.19
line 4: "  Last Change: 2023, June 28th
line 5: "  Repository:  https://github.com/chrisbra/matchit
line 6: "  Previous URL:http://www.vim.org/script.php?script_id=39
line 7: "  Previous Maintainer:  Benji Fisher PhD   <benji@member.AMS.org>
line 8: 
line 9: " Documentation:
line 10: "  The documentation is in a separate file: ../doc/matchit.txt
line 11: 
line 12: " Credits:
line 13: "  Vim editor by Bram Moolenaar (Thanks, Bram!)
line 14: "  Original script and design by Raul Segura Acevedo
line 15: "  Support for comments by Douglas Potts
line 16: "  Support for back references and other improvements by Benji Fisher
line 17: "  Support for many languages by Johannes Zellner
line 18: "  Suggestions for improvement, bug reports, and support for additional
line 19: "  languages by Jordi-Albert Batalla, Neil Bird, Servatius Brandt, Mark
line 20: "  Collett, Stephen Wall, Dany St-Amant, Yuheng Xie, and Johannes Zellner.
line 21: 
line 22: " Debugging:
line 23: "  If you'd like to try the built-in debugging commands...
line 24: "   :MatchDebug      to activate debugging for the current buffer
line 25: "  This saves the values of several key script variables as buffer-local
line 26: "  variables.  See the MatchDebug() function, below, for details.
line 27: 
line 28: " TODO:  I should think about multi-line patterns for b:match_words.
line 29: "   This would require an option:  how many lines to scan (default 1).
line 30: "   This would be useful for Python, maybe also for *ML.
line 31: " TODO:  Maybe I should add a menu so that people will actually use some of
line 32: "   the features that I have implemented.
line 33: " TODO:  Eliminate the MultiMatch function.  Add yet another argument to
line 34: "   Match_wrapper() instead.
line 35: " TODO:  Allow :let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'
line 36: " TODO:  Make backrefs safer by using '\V' (very no-magic).
line 37: " TODO:  Add a level of indirection, so that custom % scripts can use my
line 38: "   work but extend it.
line 39: 
line 40: " Allow user to prevent loading and prevent duplicate loading.
line 41: if exists("g:loaded_matchit") || &cp
line 42:   finish
line 43: endif
line 44: let g:loaded_matchit = 1
line 45: 
line 46: let s:save_cpo = &cpo
line 47: set cpo&vim
line 48: 
line 49: fun MatchEnable()
line 89: 
line 90: fun MatchDisable()
line 108: 
line 109: " Call this function to turn on debugging information.  Every time the main
line 110: " script is run, buffer variables will be saved.  These can be used directly
line 111: " or viewed using the menu items below.
line 112: if !exists(":MatchDebug")
line 113:   command! -nargs=0 MatchDebug call matchit#Match_debug()
line 114: endif
line 115: if !exists(":MatchDisable")
line 116:   command! -nargs=0 MatchDisable :call MatchDisable()
line 117: endif
line 118: if !exists(":MatchEnable")
line 119:   command! -nargs=0 MatchEnable :call MatchEnable()
line 120: endif
line 121: 
line 122: call MatchEnable()
calling MatchEnable()

line 1:   nnoremap <silent> <Plug>(MatchitNormalForward)     :<C-U>call matchit#Match_wrapper('',1,'n')<CR>
line 2:   nnoremap <silent> <Plug>(MatchitNormalBackward)    :<C-U>call matchit#Match_wrapper('',0,'n')<CR>
line 3:   xnoremap <silent> <Plug>(MatchitVisualForward)     :<C-U>call matchit#Match_wrapper('',1,'v')<CR>:if col("''") != col("$") \| exe ":normal! m'" \| endif<cr>gv``
line 5:   xnoremap <silent> <Plug>(MatchitVisualBackward)    :<C-U>call matchit#Match_wrapper('',0,'v')<CR>m'gv``
line 6:   onoremap <silent> <Plug>(MatchitOperationForward)  :<C-U>call matchit#Match_wrapper('',1,'o')<CR>
line 7:   onoremap <silent> <Plug>(MatchitOperationBackward) :<C-U>call matchit#Match_wrapper('',0,'o')<CR>
line 8: 
line 9:   " Analogues of [{ and ]} using matching patterns:
line 10:   nnoremap <silent> <Plug>(MatchitNormalMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>
line 11:   nnoremap <silent> <Plug>(MatchitNormalMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>
line 12:   xnoremap <silent> <Plug>(MatchitVisualMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>m'gv``
line 13:   xnoremap <silent> <Plug>(MatchitVisualMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>m'gv``
line 14:   onoremap <silent> <Plug>(MatchitOperationMultiBackward) :<C-U>call matchit#MultiMatch("bW", "o")<CR>
line 15:   onoremap <silent> <Plug>(MatchitOperationMultiForward)  :<C-U>call matchit#MultiMatch("W",  "o")<CR>
line 16: 
line 17:   " text object:
line 18:   xmap <silent> <Plug>(MatchitVisualTextObject) <Plug>(MatchitVisualMultiBackward)o<Plug>(MatchitVisualMultiForward)
line 19: 
line 20:   if !exists("g:no_plugin_maps")
line 21:     nmap <silent> %  <Plug>(MatchitNormalForward)
line 22:     nmap <silent> g% <Plug>(MatchitNormalBackward)
line 23:     xmap <silent> %  <Plug>(MatchitVisualForward)
line 24:     xmap <silent> g% <Plug>(MatchitVisualBackward)
line 25:     omap <silent> %  <Plug>(MatchitOperationForward)
line 26:     omap <silent> g% <Plug>(MatchitOperationBackward)
line 27: 
line 28:     " Analogues of [{ and ]} using matching patterns:
line 29:     nmap <silent> [% <Plug>(MatchitNormalMultiBackward)
line 30:     nmap <silent> ]% <Plug>(MatchitNormalMultiForward)
line 31:     xmap <silent> [% <Plug>(MatchitVisualMultiBackward)
line 32:     xmap <silent> ]% <Plug>(MatchitVisualMultiForward)
line 33:     omap <silent> [% <Plug>(MatchitOperationMultiBackward)
line 34:     omap <silent> ]% <Plug>(MatchitOperationMultiForward)
line 35: 
line 36:     " Text object
line 37:     xmap a% <Plug>(MatchitVisualTextObject)
line 38:   endif
MatchEnable returning #0

continuing in /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim

line 123: 
line 124: let &cpo = s:save_cpo
line 125: unlet s:save_cpo
line 126: 
line 127: " vim:sts=2:sw=2:et:
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim
continuing in /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/matchit.vim
line 3: augroup filetypedetect
line 3: augroup END
line 4: endif
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/matchit.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/matchparen.vim
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/matchparen.vim"
line 1: " Vim plugin for showing matching parens
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2024 May 18
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " Exit quickly when:
line 7: " - this plugin was already loaded (or disabled)
line 8: " - when 'compatible' is set
line 9: if exists("g:loaded_matchparen") || &cp
line 10:   finish
line 11: endif
line 12: let g:loaded_matchparen = 1
line 13: 
line 14: if !exists("g:matchparen_timeout")
line 15:   let g:matchparen_timeout = 300
line 16: endif
line 17: if !exists("g:matchparen_insert_timeout")
line 18:   let g:matchparen_insert_timeout = 60
line 19: endif
line 20: 
line 21: let s:has_matchaddpos = exists('*matchaddpos')
line 22: 
line 23: augroup matchparen
line 24:   " Replace all matchparen autocommands
line 25:   autocmd! CursorMoved,CursorMovedI,WinEnter,WinScrolled * call s:Highlight_Matching_Pair()
line 26:   autocmd! BufWinEnter * autocmd SafeState * ++once call s:Highlight_Matching_Pair()
line 27:   autocmd! WinLeave,BufLeave * call s:Remove_Matches()
line 28:   if exists('##TextChanged')
line 29:     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
line 30:     autocmd! TextChangedP * call s:Remove_Matches()
line 31:   endif
line 32: augroup END
line 33: 
line 34: " Skip the rest if it was already done.
line 35: if exists("*s:Highlight_Matching_Pair")
line 36:   finish
line 37: endif
line 38: 
line 39: let s:cpo_save = &cpo
line 40: set cpo-=C
line 41: 
line 42: " The function that is invoked (very often) to define a ":match" highlighting
line 43: " for any matching paren.
line 44: func s:Highlight_Matching_Pair()
line 201: 
line 202: func s:Remove_Matches()
line 210: 
line 211: " Define commands that will disable and enable the plugin.
line 212: command DoMatchParen call s:DoMatchParen()
line 213: command NoMatchParen call s:NoMatchParen()
line 214: 
line 215: func s:NoMatchParen()
line 222: 
line 223: func s:DoMatchParen()
line 229: 
line 230: let &cpo = s:cpo_save
line 231: unlet s:cpo_save
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/matchparen.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/netrwPlugin.vim
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/netrwPlugin.vim"
line 1: " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
line 2: "            PLUGIN SECTION
line 3: " Maintainer:^IThis runtime file is looking for a new maintainer.
line 4: " Date:^I^IFeb 09, 2021
line 5: " Last Change:
line 6: "   2024 May 08 by Vim Project: cleanup legacy Win9X checks
line 7: " Former Maintainer:   Charles E Campbell
line 8: " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
line 9: " Copyright:    Copyright (C) 1999-2021 Charles E. Campbell {{{1
line 10: "               Permission is hereby granted to use and distribute this code,
line 11: "               with or without modifications, provided that this copyright
line 12: "               notice is copied with it. Like anything else that's free,
line 13: "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
line 14: "               *as is* and comes with no warranty of any kind, either
line 15: "               expressed or implied. By using this plugin, you agree that
line 16: "               in no event will the copyright holder be liable for any damages
line 17: "               resulting from the use of this software.
line 18: "
line 19: "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
line 20: "  (James 1:22 RSV)
line 21: " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
line 22: " Load Once: {{{1
line 23: if &cp || exists("g:loaded_netrwPlugin")
line 24:  finish
line 25: endif
line 26: let g:loaded_netrwPlugin = "v173"
line 27: let s:keepcpo = &cpo
line 28: set cpo&vim
line 29: "DechoRemOn
line 30: 
line 31: " ---------------------------------------------------------------------
line 32: " Public Interface: {{{1
line 33: 
line 34: " Local Browsing Autocmds: {{{2
line 35: augroup FileExplorer
line 36:  au!
line 37:  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
line 38:  au BufEnter *^Isil call s:LocalBrowse(expand("<amatch>"))
line 39:  au VimEnter *^Isil call s:VimEnter(expand("<amatch>"))
line 40:  if has("win32")
line 41:   au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
line 42:  endif
line 43: augroup END
line 44: 
line 45: " Network Browsing Reading Writing: {{{2
line 46: augroup Network
line 47:  au!
line 48:  au BufReadCmd   file://*^I^I^I^I^I^I^I^I^I^I^Icall netrw#FileUrlEdit(expand("<amatch>"))
line 49:  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
line 50:  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
line 51:  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
line 52:  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
line 53:  try
line 54:   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 55:  catch /^Vim\%((\a\+)\)\=:E216/
line 56:   au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 57:  endtry
line 58: augroup END
line 59: 
line 60: " Commands: :Nread, :Nwrite, :NetUserPass {{{2
line 61: com! -count=1 -nargs=*^INread^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
line 62: com! -range=% -nargs=*^INwrite^I^Ilet s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
line 63: com! -nargs=*^I^INetUserPass^Icall NetUserPass(<f-args>)
line 64: com! -nargs=*^I        Nsource^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
line 65: com! -nargs=?^I^INtree^I^Icall netrw#SetTreetop(1,<q-args>)
line 66: 
line 67: " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
line 68: com! -nargs=* -bar -bang -count=0 -complete=dir^IExplore^I^Icall netrw#Explore(<count>,0,0+<bang>0,<q-args>)
line 69: com! -nargs=* -bar -bang -count=0 -complete=dir^ISexplore^Icall netrw#Explore(<count>,1,0+<bang>0,<q-args>)
line 70: com! -nargs=* -bar -bang -count=0 -complete=dir^IHexplore^Icall netrw#Explore(<count>,1,2+<bang>0,<q-args>)
line 71: com! -nargs=* -bar -bang -count=0 -complete=dir^IVexplore^Icall netrw#Explore(<count>,1,4+<bang>0,<q-args>)
line 72: com! -nargs=* -bar       -count=0 -complete=dir^ITexplore^Icall netrw#Explore(<count>,0,6        ,<q-args>)
line 73: com! -nargs=* -bar -bang^I^I^INexplore^Icall netrw#Explore(-1,0,0,<q-args>)
line 74: com! -nargs=* -bar -bang^I^I^IPexplore^Icall netrw#Explore(-2,0,0,<q-args>)
line 75: com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore^Icall netrw#Lexplore(<count>,<bang>0,<q-args>)
line 76: 
line 77: " Commands: NetrwSettings {{{2
line 78: com! -nargs=0^INetrwSettings^Icall netrwSettings#NetrwSettings()
line 79: com! -bang^INetrwClean^Icall netrw#Clean(<bang>0)
line 80: 
line 81: " Maps:
line 82: if !exists("g:netrw_nogx")
line 83:  if maparg('gx','n') == ""
line 84:   if !hasmapto('<Plug>NetrwBrowseX')
line 85:    nmap <unique> gx <Plug>NetrwBrowseX
line 86:   endif
line 87:   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(netrw#GX(),netrw#CheckIfRemote(netrw#GX()))<cr>
line 88:  endif
line 89:  if maparg('gx','x') == ""
line 90:   if !hasmapto('<Plug>NetrwBrowseXVis')
line 91:    xmap <unique> gx <Plug>NetrwBrowseXVis
line 92:   endif
line 93:   xno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
line 94:  endif
line 95: endif
line 96: if exists("g:netrw_usetab") && g:netrw_usetab
line 97:  if maparg('<c-tab>','n') == ""
line 98:   nmap <unique> <c-tab> <Plug>NetrwShrink
line 99:  endif
line 100:  nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
line 101: endif
line 102: 
line 103: " ---------------------------------------------------------------------
line 104: " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
line 105: fun! s:LocalBrowse(dirname)
line 149: 
line 150: " ---------------------------------------------------------------------
line 151: " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
line 152: "             Its purpose: to look over all windows and run s:LocalBrowse() on
line 153: "             them, which checks if they're directories and will create a directory
line 154: "             listing when appropriate.
line 155: "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
line 156: "             has already been called.
line 157: fun! s:VimEnter(dirname)
line 177: 
line 178: " ---------------------------------------------------------------------
line 179: " NetrwStatusLine: {{{1
line 180: fun! NetrwStatusLine()
line 191: 
line 192: " ------------------------------------------------------------------------
line 193: " NetUserPass: set username and password for subsequent ftp transfer {{{1
line 194: "   Usage:  :call NetUserPass()^I^I^I-- will prompt for userid and password
line 195: "^I    :call NetUserPass("uid")^I^I-- will prompt for password
line 196: "^I    :call NetUserPass("uid","password") -- sets global userid and password
line 197: fun! NetUserPass(...)
line 221: 
line 222: " ------------------------------------------------------------------------
line 223: " Modelines And Restoration: {{{1
line 224: let &cpo= s:keepcpo
line 225: unlet s:keepcpo
line 226: " vim:ts=8 fdm=marker
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/netrwPlugin.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/osc52.lua
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/osc52.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/osc52.lua
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/rplugin.vim
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/rplugin.vim"
line 1: if exists('g:loaded_remote_plugins')
line 2:   finish
line 3: endif
line 4: let g:loaded_remote_plugins = '/path/to/manifest'
line 5: 
line 6: " Get the path to the rplugin manifest file.
line 7: function! s:GetManifestPath() abort
line 26: 
line 27: " Old manifest file based on known script locations.
line 28: function! s:GetOldManifestPaths() abort
line 43: 
line 44: function! s:GetManifest() abort
line 57: 
line 58: function! s:LoadRemotePlugins() abort
line 64: 
line 65: command! -bar UpdateRemotePlugins call remote#host#UpdateRemotePlugins()
line 66: 
line 67: if index(v:argv, "--clean") < 0
line 68:   call s:LoadRemotePlugins()
calling <SNR>48_LoadRemotePlugins()

line 1:   let g:loaded_remote_plugins = s:GetManifest()
calling <SNR>48_GetManifest()

line 1:   let manifest = s:GetManifestPath()
calling <SNR>48_GetManifestPath()

line 1:   let manifest_base = ''
line 2: 
line 3:   if exists('$NVIM_RPLUGIN_MANIFEST')
line 4:     return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')
line 5:   endif
line 6: 
line 7:   let dest = stdpath('data')
line 8:   if !empty(dest)
line 9:     if !isdirectory(dest)
line 10:       if getftype(dest) != "link"
line 11:         call mkdir(dest, 'p', 0700)
line 12:       endif
line 13:     endif
line 14:     let manifest_base = dest
line 15:   endif
line 16: 
line 17:   return manifest_base.'/rplugin.vim'
<SNR>48_GetManifestPath returning '/Users/jkulrativid/.local/share/nvim/rplugin.vim'

continuing in <SNR>48_GetManifest

line 2:   if !filereadable(manifest)
line 3:     " Check if an old manifest file exists and move it to the new location.
line 4:     for old_manifest in s:GetOldManifestPaths()
calling <SNR>48_GetOldManifestPaths()

line 1:   let prefix = exists('$MYVIMRC') ? $MYVIMRC : matchstr(get(split(execute('scriptnames'), '\n'), 0, ''), '\f\+$')
line 4:   let origpath = fnamemodify(expand(prefix, 1), ':h').'/.'.fnamemodify(prefix, ':t').'-rplugin~'
line 6:   if !has('win32')
line 7:     return [origpath]
<SNR>48_GetOldManifestPaths returning ['/Users/jkulrativid/.config/nvim/.init.lua-rplugin~']

continuing in <SNR>48_GetManifest

line 5:       if filereadable(old_manifest)
line 6:         call rename(old_manifest, manifest)
line 7:         break
line 8:       endif
line 9:     endfor
line 4:     for old_manifest in s:GetOldManifestPaths()
line 5:       if filereadable(old_manifest)
line 6:         call rename(old_manifest, manifest)
line 7:         break
line 8:       endif
line 9:     endfor
line 10:   endif
line 11:   return manifest
<SNR>48_GetManifest returning '/Users/jkulrativid/.local/share/nvim/rplugin.vim'

continuing in <SNR>48_LoadRemotePlugins

line 2:   if filereadable(g:loaded_remote_plugins)
line 3:     execute 'source' fnameescape(g:loaded_remote_plugins)
line 4:   endif
<SNR>48_LoadRemotePlugins returning #0

continuing in /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/rplugin.vim

line 69: endif
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/rplugin.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/shada.vim
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/shada.vim"
line 1: if exists('g:loaded_shada_plugin')
line 2:   finish
line 3: endif
line 4: let g:loaded_shada_plugin = 1
line 5: 
line 6: augroup ShaDaCommands
line 7:   autocmd!
line 8:   autocmd BufReadCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call setline('.', shada#get_strings(readfile(expand('<afile>'),'b'))) |setlocal filetype=shada
line 12:   autocmd FileReadCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call append("'[", shada#get_strings(readfile(expand('<afile>'), 'b')))
line 15:   autocmd BufWriteCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |if writefile(shada#get_binstrings(getline(1, '$')),expand('<afile>'), 'b') == 0 |  let &l:modified = (expand('<afile>') is# bufname(+expand('<abuf>'))? 0: stridx(&cpoptions, '+') != -1) |endif
line 23:   autocmd FileWriteCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call writefile(shada#get_binstrings(getline(min([line("'["), line("']")]),max([line("'["), line("']")]))),expand('<afile>'),'b')
line 30:   autocmd FileAppendCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call writefile(shada#get_binstrings(getline(min([line("'["), line("']")]),max([line("'["), line("']")]))),expand('<afile>'),'ab')
line 37:   autocmd SourceCmd *.shada,*.shada.tmp.[a-z] :execute 'rshada' fnameescape(expand('<afile>'))
line 39: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/shada.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/spellfile.vim
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/spellfile.vim"
line 1: " Vim plugin for downloading spell files
line 2: 
line 3: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
line 4:   finish
line 5: endif
line 6: let loaded_spellfile_plugin = 1
line 7: 
line 8: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/spellfile.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/tarPlugin.vim
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/tarPlugin.vim"
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles
line 2: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
line 3: " Modified by Charles E. Campbell
line 4: " Distributed under the GNU General Public License.
line 5: "
line 6: " Updates are available from <http://michael.toren.net/code/>.  If you
line 7: " find this script useful, or have suggestions for improvements, please
line 8: " let me know.
line 9: " Also look there for further comments and documentation.
line 10: "
line 11: " This part only sets the autocommands.  The functions are in autoload/tar.vim.
line 12: " ---------------------------------------------------------------------
line 13: "  Load Once: {{{1
line 14: if &cp || exists("g:loaded_tarPlugin")
line 15:  finish
line 16: endif
line 17: let g:loaded_tarPlugin = "v32"
line 18: let s:keepcpo          = &cpo
line 19: set cpo&vim
line 20: 
line 21: " ---------------------------------------------------------------------
line 22: "  Public Interface: {{{1
line 23: augroup tar
line 24:   au!
line 25:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)
line 26:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)
line 27:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))
line 28:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))
line 29: 
line 30:   if has("unix")
line 31:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)
line 32:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)
line 33:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 34:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 35:   endif
line 36: 
line 37:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))
line 38:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))
line 39:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))
line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))
line 41:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))
line 42:   au BufReadCmd   *.tbz^I^I^Icall tar#Browse(expand("<amatch>"))
line 43:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))
line 44:   au BufReadCmd   *.tar.lzma^Icall tar#Browse(expand("<amatch>"))
line 45:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))
line 46:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))
line 47:   au BufReadCmd   *.tar.zst^I^Icall tar#Browse(expand("<amatch>"))
line 48:   au BufReadCmd   *.tzst^I^I^Icall tar#Browse(expand("<amatch>"))
line 49: augroup END
line 50: 
line 51: " ---------------------------------------------------------------------
line 52: " Restoration And Modelines: {{{1
line 53: " vim: fdm=marker
line 54: let &cpo= s:keepcpo
line 55: unlet s:keepcpo
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/tarPlugin.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/tohtml.lua
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/tohtml.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/tohtml.lua
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/tutor.vim
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/tutor.vim"
line 1: if exists('g:loaded_tutor_mode_plugin') || &compatible
line 2:     finish
line 3: endif
line 4: let g:loaded_tutor_mode_plugin = 1
line 5: 
line 6: command! -nargs=? -complete=custom,tutor#TutorCmdComplete Tutor call tutor#TutorCmd(<q-args>)
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/tutor.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/zipPlugin.vim
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/zipPlugin.vim"
line 1: " zipPlugin.vim: Handles browsing zipfiles
line 2: "            PLUGIN PORTION
line 3: " Date:^I^I^IDec 07, 2021
line 4: " Maintainer:^IThis runtime file is looking for a new maintainer.
line 5: " Former Maintainer:^ICharles E Campbell
line 6: " License:^I^IVim License  (see vim's :help license)
line 7: " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
line 8: "               Permission is hereby granted to use and distribute this code,
line 9: "               with or without modifications, provided that this copyright
line 10: "               notice is copied with it. Like anything else that's free,
line 11: "               zipPlugin.vim is provided *as is* and comes with no warranty
line 12: "               of any kind, either expressed or implied. By using this
line 13: "               plugin, you agree that in no event will the copyright
line 14: "               holder be liable for any damages resulting from the use
line 15: "               of this software.
line 16: "
line 17: " (James 4:8 WEB) Draw near to God, and he will draw near to you.
line 18: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
line 19: " ---------------------------------------------------------------------
line 20: " Load Once: {{{1
line 21: if &cp || exists("g:loaded_zipPlugin")
line 22:  finish
line 23: endif
line 24: let g:loaded_zipPlugin = "v33"
line 25: let s:keepcpo          = &cpo
line 26: set cpo&vim
line 27: 
line 28: " ---------------------------------------------------------------------
line 29: " Options: {{{1
line 30: if !exists("g:zipPlugin_ext")
line 31:  let g:zipPlugin_ext='*.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
line 32: endif
line 33: 
line 34: " ---------------------------------------------------------------------
line 35: " Public Interface: {{{1
line 36: augroup zip
line 37:  au!
line 38:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)
line 39:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)
line 40:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))
line 41:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))
line 42: 
line 43:  if has("unix")
line 44:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)
line 45:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)
line 46:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 47:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 48:  endif
line 49: 
line 50:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
line 50: au BufReadCmd *.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip call zip#Browse(expand("<amatch>"))
line 51: augroup END
line 52: 
line 53: " ---------------------------------------------------------------------
line 54: "  Restoration And Modelines: {{{1
line 55: "  vim: fdm=marker
line 56: let &cpo= s:keepcpo
line 57: unlet s:keepcpo
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/zipPlugin.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing User Autocommands for "LazyDone"
autocommand <Lua 29: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/util.lua:183>

Executing: 
finished sourcing /Users/jkulrativid/.config/nvim/init.lua
Searching for "filetype.lua filetype.vim" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/filetype.lua"
Searching for "/Users/jkulrativid/.config/nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/filetype.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/filetype.lua"
sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/filetype.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/filetype.lua
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/filetype.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/filetype.lua"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/filetype.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/filetype.lua"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/filetype.lua"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/filetype.vim"
Executing: so $VIMRUNTIME/syntax/syntax.vim
sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file is used for ":syntax on".
line 7: " It installs the autocommands and starts highlighting for all buffers.
line 8: 
line 9: if !has("syntax")
line 10:   finish
line 11: endif
line 12: 
line 13: " If Syntax highlighting appears to be on already, turn it off first, so that
line 14: " any leftovers are cleared.
line 15: if exists("syntax_on") || exists("syntax_manual")
line 16:   so <sfile>:p:h/nosyntax.vim
line 17: endif
line 18: 
line 19: " Load the Syntax autocommands and set the default methods for highlighting.
line 20: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/syntax/synload.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/synload.vim"
line 20: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up for syntax highlighting.
line 7: " It is loaded from "syntax.vim" and "manual.vim".
line 8: " 1. Set the default highlight groups.
line 9: " 2. Install Syntax autocommands for all the available syntax files.
line 10: 
line 11: if !has("syntax")
line 12:   finish
line 13: endif
line 14: 
line 15: " let others know that syntax has been switched on
line 16: let syntax_on = 1
line 17: 
line 18: " Line continuation is used here, remove 'C' from 'cpoptions'
line 19: let s:cpo_save = &cpo
line 20: set cpo&vim
line 21: 
line 22: " First remove all old syntax autocommands.
line 23: au! Syntax
line 24: 
line 25: au Syntax *^I^Icall s:SynSet()
line 26: 
line 27: fun! s:SynSet()
line 58: 
line 59: 
line 60: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
line 61: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 66: 
line 67: 
line 68: " Source the user-specified syntax highlighting file
line 69: if exists("mysyntaxfile")
line 70:   let s:fname = expand(mysyntaxfile)
line 71:   if filereadable(s:fname)
line 72:     execute "source " . fnameescape(s:fname)
line 73:   endif
line 74: endif
line 75: 
line 76: " Restore 'cpoptions'
line 77: let &cpo = s:cpo_save
line 78: unlet s:cpo_save
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/synload.vim
continuing in /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/syntax.vim
line 21: 
line 22: " Load the FileType autocommands if not done yet.
line 23: if exists("did_load_filetypes")
line 24:   let s:did_ft = 1
line 25: else
line 26:   filetype on
line 27:   let s:did_ft = 0
line 28: endif
line 29: 
line 30: " Set up the connection between FileType and Syntax autocommands.
line 31: " This makes the syntax automatically set when the file type is detected
line 32: " unless treesitter highlighting is enabled.
line 33: " Avoid an error when 'verbose' is set and <amatch> expansion fails.
line 34: augroup syntaxset
line 35:   au! FileType *^Iif !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
line 36: augroup END
line 37: 
line 38: " Execute the syntax autocommands for the each buffer.
line 39: " If the filetype wasn't detected yet, do that now.
line 40: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 41: " already was set manually (e.g., help buffers).
line 42: doautoall syntaxset FileType
Executing FileType Autocommands for "*"
autocommand if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif

Executing: if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  endif
line 43: if !s:did_ft
line 44:   doautoall filetypedetect BufRead
line 45: endif
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/syntax.vim
Reading ShaDa file "/Users/jkulrativid/.local/state/nvim/shada/main.shada" info marks oldfiles
Executing BufWinEnter Autocommands for "*"
autocommand <Lua 208: ~/.local/share/nvim/lazy/nvim-dap-ui/lua/dapui/windows/init.lua:107>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand autocmd SafeState * ++once call s:Highlight_Matching_Pair()

Executing: autocmd SafeState * ++once call s:Highlight_Matching_Pair()
Executing BufEnter Autocommands for "*"
autocommand <Lua 176: ~/.local/share/nvim/lazy/bufferline.nvim/lua/bufferline.lua:141>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand lua require'lualine.components.branch.git_branch'.find_git_dir()

Executing: lua require'lualine.components.branch.git_branch'.find_git_dir()
autocommand lua require'lualine.components.diff.git_diff'.update_diff_args()

Executing: lua require'lualine.components.diff.git_diff'.update_diff_args()
Executing BufEnter Autocommands for "*"
autocommand sil call s:LocalBrowse(expand("<amatch>"))

Executing: sil call s:LocalBrowse(expand("<amatch>"))
calling <SNR>46_LocalBrowse('')

line 1:   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
line 2:   " Otherwise, the BufEnter event gets triggered when attempts to write to
line 3:   " the DBG buffer are made.
line 4: 
line 5:   if !exists("s:vimentered")
line 6:    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
line 7:    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
line 8: "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
line 9: "   call Dret("s:LocalBrowse")
line 10:    return
<SNR>46_LocalBrowse returning #0

continuing in BufEnter Autocommands for "*"

Executing VimEnter Autocommands for "*"
autocommand <Lua 24: vim/_defaults.lua:0>

Executing: 
Executing VimEnter Autocommands for "*"
autocommand <Lua 73: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/handler/event.lua:72>

Executing: augroup filetypedetect
Executing: augroup END
Executing: autocmd FileType alpha setlocal nofoldenable
Executing VimEnter Autocommands for "*"
autocommand <Lua 249: ~/.local/share/nvim/lazy/alpha-nvim/lua/alpha.lua:784>

Executing FileType Autocommands for "*"
autocommand call s:LoadFTPlugin()

Executing: call s:LoadFTPlugin()
calling <SNR>2_LoadFTPlugin()

line 1:     if exists("b:undo_ftplugin")
line 2:       exe b:undo_ftplugin
line 3:       unlet! b:undo_ftplugin b:did_ftplugin
line 4:     endif
line 5: 
line 6:     let s = expand("<amatch>")
line 7:     if s != ""
line 8:       if &cpo =~# "S" && exists("b:did_ftplugin")
line 9: ^I" In compatible mode options are reset to the global values, need to
line 10: ^I" set the local values also when a plugin was already used.
line 11: ^Iunlet b:did_ftplugin
line 12:       endif
line 13: 
line 14:       " When there is a dot it is used to separate filetype names.  Thus for
line 15:       " "aaa.bbb" load "aaa" and then "bbb".
line 16:       for name in split(s, '\.')
line 17:         " Load Lua ftplugins after Vim ftplugins _per directory_
line 18:         " TODO(clason): use nvim__get_runtime when supports globs and modeline
line 19:         " XXX: "[.]" in the first pattern makes it a wildcard on Windows
line 20:         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
line 20: runtime! ftplugin/alpha[.]{vim,lua} ftplugin/alpha_*.{vim,lua} ftplugin/alpha/*.{vim,lua}
Searching for "ftplugin/alpha[.]{vim,lua} ftplugin/alpha_*.{vim,lua} ftplugin/alpha/*.{vim,lua}" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.config/nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.config/nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/ftplugin/alpha/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/alpha[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/alpha_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/alpha/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/alpha[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/alpha_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/alpha/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/ftplugin/alpha/*.{vim,lua}"
not found in runtime path: "ftplugin/alpha[.]{vim,lua} ftplugin/alpha_*.{vim,lua} ftplugin/alpha/*.{vim,lua}"
line 21:       endfor
line 16:       for name in split(s, '\.')
line 17:         " Load Lua ftplugins after Vim ftplugins _per directory_
line 18:         " TODO(clason): use nvim__get_runtime when supports globs and modeline
line 19:         " XXX: "[.]" in the first pattern makes it a wildcard on Windows
line 20:         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
line 21:       endfor
line 22:     endif
<SNR>2_LoadFTPlugin returning #0

continuing in FileType Autocommands for "*"

Executing FileType Autocommands for "*"
autocommand call s:LoadIndent()

Executing: call s:LoadIndent()
calling <SNR>3_LoadIndent()

line 1:     if exists("b:undo_indent")
line 2:       exe b:undo_indent
line 3:       unlet! b:undo_indent b:did_indent
line 4:     endif
line 5:     let s = expand("<amatch>")
line 6:     if s != ""
line 7:       if exists("b:did_indent")
line 8: ^Iunlet b:did_indent
line 9:       endif
line 10: 
line 11:       " When there is a dot it is used to separate filetype names.  Thus for
line 12:       " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
line 13:       for name in split(s, '\.')
line 14:         " XXX: "[.]" in the pattern makes it a wildcard on Windows
line 15:         exe $'runtime! indent/{name}[.]{{vim,lua}}'
line 15: runtime! indent/alpha[.]{vim,lua}
Searching for "indent/alpha[.]{vim,lua}" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/indent/alpha[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/indent/alpha[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/indent/alpha[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/indent/alpha[.]{vim,lua}"
not found in runtime path: "indent/alpha[.]{vim,lua}"
line 16:       endfor
line 13:       for name in split(s, '\.')
line 14:         " XXX: "[.]" in the pattern makes it a wildcard on Windows
line 15:         exe $'runtime! indent/{name}[.]{{vim,lua}}'
line 16:       endfor
line 17:     endif
<SNR>3_LoadIndent returning #0

continuing in FileType Autocommands for "*"

Executing FileType Autocommands for "*"
autocommand if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif

Executing: if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  endif
Executing FileType Autocommands for "alpha"
autocommand setlocal nofoldenable

Executing: setlocal nofoldenable
Executing: 
Executing: 
Executing VimEnter Autocommands for "*"
autocommand <Lua 121: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:299>

Executing: 
Executing VimEnter Autocommands for "*"
autocommand sil call s:VimEnter(expand("<amatch>"))

Executing: sil call s:VimEnter(expand("<amatch>"))
calling <SNR>46_VimEnter('')

line 1: "  call Dfunc("s:VimEnter(dirname<".a:dirname.">) expand(%)<".expand("%").">")
line 2:   if has('nvim') || v:version < 802
line 3:   " Johann Höchtl: reported that the call range... line causes an E488: Trailing characters
line 4:   "                error with neovim. I suspect its because neovim hasn't updated with recent
line 5:   "                vim patches. As is, this code will have problems with popup terminals
line 6:   "                instantiated before the VimEnter event runs.
line 7:   " Ingo Karkat  : E488 also in Vim 8.1.1602
line 8:   let curwin       = winnr()
line 9:   let s:vimentered = 1
line 10:   windo call s:LocalBrowse(expand("%:p"))
line 10: call s:LocalBrowse(expand("%:p"))
calling <SNR>46_LocalBrowse('')

line 1:   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
line 2:   " Otherwise, the BufEnter event gets triggered when attempts to write to
line 3:   " the DBG buffer are made.
line 4: 
line 5:   if !exists("s:vimentered")
line 6:    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
line 7:    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
line 8: "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
line 9: "   call Dret("s:LocalBrowse")
line 10:    return
line 11:   endif
line 12: 
line 13: "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
line 14: 
line 15:   if has("amiga")
line 16:    " The check against '' is made for the Amiga, where the empty
line 17:    " string is the current directory and not checking would break
line 18:    " things such as the help command.
line 19: "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
line 20:    if a:dirname != '' && isdirectory(a:dirname)
line 21:     sil! call netrw#LocalBrowseCheck(a:dirname)
line 22:     if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
line 23:      exe w:netrw_bannercnt
line 24:     endif
line 25:    endif
line 26: 
line 27:   elseif isdirectory(a:dirname)
line 28: "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
line 29: "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
line 30:    " Jul 13, 2021: for whatever reason, preceding the following call with
line 31:    " a   sil!  causes an unbalanced if-endif vim error
line 32:    call netrw#LocalBrowseCheck(a:dirname)
line 33:    if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
line 34:     exe w:netrw_bannercnt
line 35:    endif
line 36: 
line 37:   else
line 38:    " not a directory, ignore it
line 39: "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
line 40:   endif
line 41: 
line 42: "  call Dret("s:LocalBrowse")
<SNR>46_LocalBrowse returning #0

continuing in <SNR>46_VimEnter

line 11:   exe curwin."wincmd w"
line 11: 1wincmd w
line 12:  else
line 13:   " the following complicated expression comes courtesy of lacygoill; largely does the same thing as the windo and 
line 14:   " wincmd which are commented out, but avoids some side effects. Allows popup terminal before VimEnter.
line 15:   let s:vimentered = 1
line 16:   call range(1, winnr('$'))->map({_, v -> win_execute(win_getid(v), 'call expand("%:p")->s:LocalBrowse()')})
line 17:  endif
line 18: "  call Dret("s:VimEnter")
<SNR>46_VimEnter returning #0

continuing in VimEnter Autocommands for "*"

Executing UIEnter Autocommands for "*"
autocommand <Lua 27: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/config.lua:326>

Executing: 
autocommand <Lua 243: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/util.lua:189>

Executing: 
Searching for "autoload/provider/clipboard.vim" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/autoload/provider/clipboard.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/autoload/provider/clipboard.vim"
sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/autoload/provider/clipboard.vim"
line 1: " The clipboard provider uses shell commands to communicate with the clipboard.
line 2: " The provider function will only be registered if a supported command is
line 3: " available.
line 4: 
line 5: if exists('g:loaded_clipboard_provider')
line 6:   finish
line 7: endif
line 8: " Default to 1.  provider#clipboard#Executable() may set 2.
line 9: " To force a reload:
line 10: "   :unlet g:loaded_clipboard_provider
line 11: "   :runtime autoload/provider/clipboard.vim
line 12: let g:loaded_clipboard_provider = 1
line 13: 
line 14: let s:copy = {}
line 15: let s:paste = {}
line 16: let s:clipboard = {}
line 17: 
line 18: " When caching is enabled, store the jobid of the xclip/xsel process keeping
line 19: " ownership of the selection, so we know how long the cache is valid.
line 20: let s:selection = { 'owner': 0, 'data': [], 'stderr_buffered': v:true }
line 21: 
line 22: function! s:selection.on_exit(jobid, data, event) abort
line 35: 
line 36: let s:selections = { '*': s:selection, '+': copy(s:selection) }
line 37: 
line 38: function! s:try_cmd(cmd, ...) abort
line 51: 
line 52: " Returns TRUE if `cmd` exits with success, else FALSE.
line 53: function! s:cmd_ok(cmd) abort
line 57: 
line 58: function! s:split_cmd(cmd) abort
line 61: 
line 62: let s:cache_enabled = 1
line 63: let s:err = ''
line 64: 
line 65: function! provider#clipboard#Error() abort
line 68: 
line 69: function! provider#clipboard#Executable() abort
line 165: 
line 166: function! s:clipboard.get(reg) abort
line 183: 
line 184: function! s:clipboard.set(lines, regtype, reg) abort
line 242: 
line 243: function! provider#clipboard#Call(method, args) abort
line 254: 
line 255: " eval_has_provider() decides based on this variable.
line 256: let g:loaded_clipboard_provider = empty(provider#clipboard#Executable()) ? 1 : 2
calling provider#clipboard#Executable()

line 1:   " Setting g:clipboard to v:false explicitly opts-in to using the "builtin" clipboard providers below
line 2:   if exists('g:clipboard') && g:clipboard isnot# v:false
line 3:     if type({}) isnot# type(g:clipboard) || type({}) isnot# type(get(g:clipboard, 'copy', v:null)) || type({}) isnot# type(get(g:clipboard, 'paste', v:null))
line 6:       let s:err = 'clipboard: invalid g:clipboard'
line 7:       return ''
line 8:     endif
line 9: 
line 10:     let s:copy = {}
line 11:     let s:copy['+'] = s:split_cmd(get(g:clipboard.copy, '+', v:null))
line 12:     let s:copy['*'] = s:split_cmd(get(g:clipboard.copy, '*', v:null))
line 13: 
line 14:     let s:paste = {}
line 15:     let s:paste['+'] = s:split_cmd(get(g:clipboard.paste, '+', v:null))
line 16:     let s:paste['*'] = s:split_cmd(get(g:clipboard.paste, '*', v:null))
line 17: 
line 18:     let s:cache_enabled = get(g:clipboard, 'cache_enabled', 0)
line 19:     return get(g:clipboard, 'name', 'g:clipboard')
line 20:   elseif has('mac')
line 21:     let s:copy['+'] = ['pbcopy']
line 22:     let s:paste['+'] = ['pbpaste']
line 23:     let s:copy['*'] = s:copy['+']
line 24:     let s:paste['*'] = s:paste['+']
line 25:     let s:cache_enabled = 0
line 26:     return 'pbcopy'
provider#clipboard#Executable returning 'pbcopy'

continuing in /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/autoload/provider/clipboard.vim

finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/autoload/provider/clipboard.vim
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "<buffer=1>"
autocommand <Lua 256: ~/.local/share/nvim/lazy/alpha-nvim/lua/alpha.lua:525>

Executing: 
Executing TextChanged Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in TextChanged Autocommands for "*"

Executing SafeState Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in SafeState Autocommands for "*"

Executing: autocmd User CocDiagnosticChange lua require('bufferline.diagnostics').refresh_coc_diagnostics()
Executing: highlight! lualine_x_filetype_DevIconDefault_normal guifg=#6d8086 guibg=#112638 gui=None
Executing: highlight! lualine_x_filetype_DevIconDefault_insert guifg=#6d8086 guibg=#112638 gui=None
Executing: highlight! lualine_x_filetype_DevIconDefault_visual guifg=#6d8086 guibg=#112638 gui=None
Executing: highlight! lualine_x_filetype_DevIconDefault_replace guifg=#6d8086 guibg=#112638 gui=None
Executing: highlight! lualine_x_filetype_DevIconDefault_command guifg=#6d8086 guibg=#112638 gui=None
Executing: highlight! lualine_x_filetype_DevIconDefault_terminal guifg=#6d8086 guibg=#112638 gui=None
Executing: highlight! lualine_x_filetype_DevIconDefault_inactive guifg=#6d8086 guibg=#2c3043 gui=None
Executing: highlight! lualine_transitional_lualine_a_normal_to_lualine_b_normal guifg=#65D1FF guibg=#112638 gui=None
Executing TermResponse Autocommands for "*"
autocommand <Lua 22: vim/_defaults.lua:0>

Executing: 
Executing User Autocommands for "VeryLazy"
autocommand <Lua 28: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/config.lua:337>

Executing: 
Executing User Autocommands for "VeryLazy"
autocommand <Lua 63: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/handler/event.lua:72>

Executing: source /Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/plugin/which-key.lua
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/plugin/which-key.lua"
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/plugin/which-key.lua
continuing in nvim_exec2() called at User Autocommands for "VeryLazy":0
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/plugin/dressing.lua
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/plugin/dressing.lua"
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/plugin/dressing.lua
continuing in nvim_exec2() called at User Autocommands for "VeryLazy":0
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/plugin/mkdp.vim
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/plugin/mkdp.vim"
line 1: " set to 1, the vim will open the preview window once enter the markdown
line 2: " buffer
line 3: if !exists('g:mkdp_auto_start')
line 4:   let g:mkdp_auto_start = 0
line 5: endif
line 6: 
line 7: " let g:mkdp_auto_open = 0
line 8: " set to 1, the vim will auto open preview window when you edit the
line 9: " markdown file
line 10: 
line 11: " set to 1, the vim will auto close current preview window when change
line 12: " from markdown buffer to another buffer
line 13: if !exists('g:mkdp_auto_close')
line 14:   let g:mkdp_auto_close = 1
line 15: endif
line 16: 
line 17: " set to 1, the vim will just refresh markdown when save the buffer or
line 18: " leave from insert mode, default 0 is auto refresh markdown as you edit or
line 19: " move the cursor
line 20: if !exists('g:mkdp_refresh_slow')
line 21:   let g:mkdp_refresh_slow = 0
line 22: endif
line 23: 
line 24: " set to 1, the MarkdownPreview command can be use for all files,
line 25: " by default it just can be use in markdown file
line 26: if !exists('g:mkdp_command_for_global')
line 27:   let g:mkdp_command_for_global = 0
line 28: endif
line 29: 
line 30: " set to 1, preview server available to others in your network
line 31: " by default, the server only listens on localhost (127.0.0.1)
line 32: if !exists('g:mkdp_open_to_the_world')
line 33:   let g:mkdp_open_to_the_world = 0
line 34: endif
line 35: 
line 36: " use custom ip to open preview page
line 37: " default empty
line 38: if !exists('g:mkdp_open_ip')
line 39:   let g:mkdp_open_ip = ''
line 40: endif
line 41: 
line 42: " set to 1, echo preview page url in command line when open preview page
line 43: " default is 0
line 44: if !exists('g:mkdp_echo_preview_url')
line 45:   let g:mkdp_echo_preview_url = 0
line 46: endif
line 47: 
line 48: " use custom vim function to open preview page
line 49: " this function will receive url as param
line 50: if !exists('g:mkdp_browserfunc')
line 51:   let g:mkdp_browserfunc = ''
line 52: endif
line 53: 
line 54: " specify browser to open preview page
line 55: if !exists('g:mkdp_browser')
line 56:   let g:mkdp_browser = ''
line 57: endif
line 58: 
line 59: if !exists('g:mkdp_preview_options')
line 60:   let g:mkdp_preview_options = { 'mkit': {}, 'katex': {}, 'uml': {}, 'maid': {}, 'disable_sync_scroll': 0, 'sync_scroll_type': 'middle', 'hide_yaml_meta': 1, 'sequence_diagrams': {}, 'flowchart_diagrams': {}, 'content_editable': v:false, 'disable_filename': 0, 'toc': {} }
line 74: elseif !has_key(g:mkdp_preview_options, 'disable_filename')
line 75:   let g:mkdp_preview_options['disable_filename'] = 0
line 76: endif
line 77: 
line 78: " markdown css file absolute path
line 79: if !exists('g:mkdp_markdown_css')
line 80:   let g:mkdp_markdown_css = ''
line 81: endif
line 82: 
line 83: " highlight css file absolute path
line 84: if !exists('g:mkdp_highlight_css')
line 85:   let g:mkdp_highlight_css = ''
line 86: endif
line 87: 
line 88: if !exists('g:mkdp_port')
line 89:   let g:mkdp_port = ''
line 90: endif
line 91: 
line 92: " preview page title
line 93: " ${name} will be replace with the file name
line 94: if !exists('g:mkdp_page_title')
line 95:   let g:mkdp_page_title = '「${name}」'
line 96: endif
line 97: 
line 98: " recognized filetypes
line 99: if !exists('g:mkdp_filetypes')
line 100:   let g:mkdp_filetypes = ['markdown']
line 101: endif
line 102: 
line 103: " markdown images custom path
line 104: if !exists('g:mkdp_images_path')
line 105:   let g:mkdp_images_path = ''
line 106: endif
line 107: 
line 108: " combine preview window
line 109: if !exists('g:mkdp_combine_preview')
line 110:   let g:mkdp_combine_preview = 0
line 111: endif
line 112: 
line 113: " auto refetch combine preview contents when change markdown buffer
line 114: " only when g:mkdp_combine_preview is 1
line 115: if !exists('g:mkdp_combine_preview_auto_refresh')
line 116:   let g:mkdp_combine_preview_auto_refresh = 1
line 117: endif
line 118: 
line 119: " if there are any active preview client
line 120: let g:mkdp_clients_active = 0
line 121: 
line 122: function! s:init_command() abort
line 134: 
line 135: function! s:init() abort
line 151: 
line 152: call s:init()
calling <SNR>65_init()

line 1:   augroup mkdp_init
line 2:     autocmd!
line 3:     if g:mkdp_command_for_global
line 4:       autocmd BufEnter * :call s:init_command()
line 5:     else
line 6:       autocmd BufEnter,FileType * if index(g:mkdp_filetypes, &filetype) !=# -1 | call s:init_command() | endif
line 7:     endif
line 8:     if g:mkdp_auto_start
line 9:       execute 'autocmd BufEnter *.{md,mkd,mdown,mkdn,mdwn,' . join(g:mkdp_filetypes, ',') . '} call mkdp#util#open_preview_page()'
line 10:     endif
line 11:     if g:mkdp_combine_preview && g:mkdp_combine_preview_auto_refresh
line 12:       execute 'autocmd BufEnter *.{md,mkd,mdown,mkdn,mdwn,' . join(g:mkdp_filetypes, ',') . '} call mkdp#util#combine_preview_refresh()'
line 13:     endif
line 14:   augroup END
<SNR>65_init returning #0

continuing in /Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/plugin/mkdp.vim

finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/plugin/mkdp.vim
continuing in nvim_exec2() called at User Autocommands for "VeryLazy":0
Executing: 


--- Terminal info --- {{{
&term: xterm-256color
Description: xterm with 256 colors
Aliases: xterm-256color
Boolean capabilities:
  auto_left_margin          bw         = false
  auto_right_margin         am         = true
  no_esc_ctlc               xsb        = false
  ceol_standout_glitch      xhp        = false
  eat_newline_glitch        xenl       = true
  erase_overstrike          eo         = false
  generic_type              gn         = false
  hard_copy                 hc         = false
  has_meta_key              km         = true
  has_status_line           hs         = false
  insert_null_glitch        in         = false
  memory_above              da         = false
  memory_below              db         = false
  move_insert_mode          mir        = true
  move_standout_mode        msgr       = true
  over_strike               os         = false
  status_line_esc_ok        eslok      = false
  dest_tabs_magic_smso      xt         = false
  tilde_glitch              hz         = false
  transparent_underline     ul         = false
  xon_xoff                  xon        = false
  needs_xon_xoff            nxon       = false
  prtr_silent               mc5i       = true
  hard_cursor               chts       = false
  non_rev_rmcup             nrrmc      = false
  no_pad_char               npc        = true
  non_dest_scroll_region    ndscr      = false
  can_change                ccc        = true
  back_color_erase          bce        = true
  hue_lightness_saturation  hls        = false
  col_addr_glitch           xhpa       = false
  cr_cancels_micro_mode     crxm       = false
  has_print_wheel           daisy      = false
  row_addr_glitch           xvpa       = false
  semi_auto_right_margin    sam        = false
  cpi_changes_res           cpix       = false
  lpi_changes_res           lpix       = false
  backspaces_with_bs        OTbs       = true
  crt_no_scrolling          OTns       = false
  no_correctly_working_cr   OTnc       = false
  gnu_has_meta_key          OTMT       = false
  linefeed_is_newline       OTNL       = false
  has_hardware_tabs         OTpt       = false
  return_does_clr_eol       OTxr       = false
Numeric capabilities:
  columns                   cols       = 80
  init_tabs                 it         = 8
  lines                     lines      = 24
  lines_of_memory           lm         = -1
  magic_cookie_glitch       xmc        = -1
  padding_baud_rate         pb         = -1
  virtual_terminal          vt         = -1
  width_status_line         wsl        = -1
  num_labels                nlab       = -1
  label_height              lh         = -1
  label_width               lw         = -1
  max_attributes            ma         = -1
  maximum_windows           wnum       = -1
  max_colors                colors     = 256
  max_pairs                 pairs      = 32767
  no_color_video            ncv        = -1
  buffer_capacity           bufsz      = -1
  dot_vert_spacing          spinv      = -1
  dot_horz_spacing          spinh      = -1
  max_micro_address         maddr      = -1
  max_micro_jump            mjump      = -1
  micro_col_size            mcs        = -1
  micro_line_size           mls        = -1
  number_of_pins            npins      = -1
  output_res_char           orc        = -1
  output_res_line           orl        = -1
  output_res_horz_inch      orhi       = -1
  output_res_vert_inch      orvi       = -1
  print_rate                cps        = -1
  wide_char_size            widcs      = -1
  buttons                   btns       = -1
  bit_image_entwining       bitwin     = -1
  bit_image_type            bitype     = -1
  magic_cookie_glitch_ul    OTug       = -1
  carriage_return_delay     OTdC       = -1
  new_line_delay            OTdN       = -1
  backspace_delay           OTdB       = -1
  horizontal_tab_delay      OTdT       = -1
  number_of_function_keys   OTkn       = -1
String capabilities:
  back_tab                  cbt        = ^[[Z
  bell                      bel        = ^G
  carriage_return           cr         = ^M
  change_scroll_region      csr        = ^[[%i%p1%d;%p2%dr
  clear_all_tabs            tbc        = ^[[3g
  clear_screen              clear      = ^[[H^[[2J
  clr_eol                   el         = ^[[K
  clr_eos                   ed         = ^[[J
  column_address            hpa        = ^[[%i%p1%dG
  cursor_address            cup        = ^[[%i%p1%d;%p2%dH
  cursor_down               cud1       = ^@
  cursor_home               home       = ^[[H
  cursor_invisible          civis      = ^[[?25l
  cursor_left               cub1       = ^H
  cursor_normal             cnorm      = ^[[?25h
  cursor_right              cuf1       = ^[[C
  cursor_up                 cuu1       = ^[[A
  cursor_visible            cvvis      = ^[[?12;25h
  delete_character          dch1       = ^[[P
  delete_line               dl1        = ^[[M
  enter_alt_charset_mode    smacs      = ^[(0
  enter_blink_mode          blink      = ^[[5m
  enter_bold_mode           bold       = ^[[1m
  enter_ca_mode             smcup      = ^[[?1049h
  enter_dim_mode            dim        = ^[[2m
  enter_insert_mode         smir       = ^[[4h
  enter_secure_mode         invis      = ^[[8m
  enter_reverse_mode        rev        = ^[[7m
  enter_standout_mode       smso       = ^[[7m
  enter_underline_mode      smul       = ^[[4m
  erase_chars               ech        = ^[[%p1%dX
  exit_alt_charset_mode     rmacs      = ^[(B
  exit_attribute_mode       sgr0       = ^[(B^[[m
  exit_ca_mode              rmcup      = ^[[?1049l
  exit_insert_mode          rmir       = ^[[4l
  exit_standout_mode        rmso       = ^[[27m
  exit_underline_mode       rmul       = ^[[24m
  flash_screen              flash      = ^[[?5h$<100/>^[[?5l
  from_status_line          fsl        = ^G
  init_2string              is2        = ^[[!p^[[?3;4l^[[4l^[>
  insert_line               il1        = ^[[L
  key_backspace             kbs        = ^H
  key_dc                    kdch1      = ^[[3~
  key_down                  kcud1      = ^[OB
  key_f1                    kf1        = ^[OP
  key_f10                   kf10       = ^[[21~
  key_f2                    kf2        = ^[OQ
  key_f3                    kf3        = ^[OR
  key_f4                    kf4        = ^[OS
  key_f5                    kf5        = ^[[15~
  key_f6                    kf6        = ^[[17~
  key_f7                    kf7        = ^[[18~
  key_f8                    kf8        = ^[[19~
  key_f9                    kf9        = ^[[20~
  key_home                  khome      = ^[OH
  key_ic                    kich1      = ^[[2~
  key_left                  kcub1      = ^[OD
  key_npage                 knp        = ^[[6~
  key_ppage                 kpp        = ^[[5~
  key_right                 kcuf1      = ^[OC
  key_sf                    kind       = ^[[1;2B
  key_sr                    kri        = ^[[1;2A
  key_up                    kcuu1      = ^[OA
  keypad_local              rmkx       = ^[[?1l^[>
  keypad_xmit               smkx       = ^[[?1h^[=
  meta_off                  rmm        = ^[[?1034l
  meta_on                   smm        = ^[[?1034h
  parm_dch                  dch        = ^[[%p1%dP
  parm_delete_line          dl         = ^[[%p1%dM
  parm_down_cursor          cud        = ^[[%p1%dB
  parm_ich                  ich        = ^[[%p1%d@
  parm_index                indn       = ^[[%p1%dS
  parm_insert_line          il         = ^[[%p1%dL
  parm_left_cursor          cub        = ^[[%p1%dD
  parm_right_cursor         cuf        = ^[[%p1%dC
  parm_rindex               rin        = ^[[%p1%dT
  parm_up_cursor            cuu        = ^[[%p1%dA
  print_screen              mc0        = ^[[i
  prtr_off                  mc4        = ^[[4i
  prtr_on                   mc5        = ^[[5i
  reset_1string             rs1        = ^[c
  reset_2string             rs2        = ^[[!p^[[?3;4l^[[4l^[>
  restore_cursor            rc         = ^[8
  row_address               vpa        = ^[[%i%p1%dd
  save_cursor               sc         = ^[7
  scroll_forward            ind        = ^@
  scroll_reverse            ri         = ^[M
  set_attributes            sgr        = %?%p9%t^[(0%e^[(B%;^[[0%?%p6%t;1%;%?%p5%t;2%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p7%t;8%;m
  set_tab                   hts        = ^[H
  tab                       ht         = 	
  to_status_line            tsl        = ^[]0;
  key_b2                    kb2        = ^[OE
  acs_chars                 acsc       = ``aaffggiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~
  key_btab                  kcbt       = ^[[Z
  enter_am_mode             smam       = ^[[?7h
  exit_am_mode              rmam       = ^[[?7l
  key_end                   kend       = ^[OF
  key_enter                 kent       = ^[OM
  key_sdc                   kDC        = ^[[3;2~
  key_send                  kEND       = ^[[1;2F
  key_shome                 kHOM       = ^[[1;2H
  key_sic                   kIC        = ^[[2;2~
  key_sleft                 kLFT       = ^[[1;2D
  key_snext                 kNXT       = ^[[6;2~
  key_sprevious             kPRV       = ^[[5;2~
  key_sright                kRIT       = ^[[1;2C
  key_f11                   kf11       = ^[[23~
  key_f12                   kf12       = ^[[24~
  key_f13                   kf13       = ^[[1;2P
  key_f14                   kf14       = ^[[1;2Q
  key_f15                   kf15       = ^[[1;2R
  key_f16                   kf16       = ^[[1;2S
  key_f17                   kf17       = ^[[15;2~
  key_f18                   kf18       = ^[[17;2~
  key_f19                   kf19       = ^[[18;2~
  key_f20                   kf20       = ^[[19;2~
  key_f21                   kf21       = ^[[20;2~
  key_f22                   kf22       = ^[[21;2~
  key_f23                   kf23       = ^[[23;2~
  key_f24                   kf24       = ^[[24;2~
  key_f25                   kf25       = ^[[1;5P
  key_f26                   kf26       = ^[[1;5Q
  key_f27                   kf27       = ^[[1;5R
  key_f28                   kf28       = ^[[1;5S
  key_f29                   kf29       = ^[[15;5~
  key_f30                   kf30       = ^[[17;5~
  key_f31                   kf31       = ^[[18;5~
  key_f32                   kf32       = ^[[19;5~
  key_f33                   kf33       = ^[[20;5~
  key_f34                   kf34       = ^[[21;5~
  key_f35                   kf35       = ^[[23;5~
  key_f36                   kf36       = ^[[24;5~
  key_f37                   kf37       = ^[[1;6P
  key_f38                   kf38       = ^[[1;6Q
  key_f39                   kf39       = ^[[1;6R
  key_f40                   kf40       = ^[[1;6S
  key_f41                   kf41       = ^[[15;6~
  key_f42                   kf42       = ^[[17;6~
  key_f43                   kf43       = ^[[18;6~
  key_f44                   kf44       = ^[[19;6~
  key_f45                   kf45       = ^[[20;6~
  key_f46                   kf46       = ^[[21;6~
  key_f47                   kf47       = ^[[23;6~
  key_f48                   kf48       = ^[[24;6~
  key_f49                   kf49       = ^[[1;3P
  key_f50                   kf50       = ^[[1;3Q
  key_f51                   kf51       = ^[[1;3R
  key_f52                   kf52       = ^[[1;3S
  key_f53                   kf53       = ^[[15;3~
  key_f54                   kf54       = ^[[17;3~
  key_f55                   kf55       = ^[[18;3~
  key_f56                   kf56       = ^[[19;3~
  key_f57                   kf57       = ^[[20;3~
  key_f58                   kf58       = ^[[21;3~
  key_f59                   kf59       = ^[[23;3~
  key_f60                   kf60       = ^[[24;3~
  key_f61                   kf61       = ^[[1;4P
  key_f62                   kf62       = ^[[1;4Q
  key_f63                   kf63       = ^[[1;4R
  clr_bol                   el1        = ^[[1K
  user6                     u6         = ^[[%i%d;%dR
  user7                     u7         = ^[[6n
  user8                     u8         = ^[[?1;2c
  user9                     u9         = ^[[c
  orig_pair                 op         = ^[[39;49m
  initialize_color          initc      = ^[]4;%p1%d;rgb:%p2%{255}%*%{1000}%/%2.2X/%p3%{255}%*%{1000}%/%2.2X/%p4%{255}%*%{1000}%/%2.2X^[\
  enter_italics_mode        sitm       = ^[[3m
  exit_italics_mode         ritm       = ^[[23m
  key_mouse                 kmous      = ^[[M
  set_a_foreground          setaf      = ^[[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m
  set_a_background          setab      = ^[[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m
  set_tb_margin             smgtb      = ^[[%i%p1%d;%p2%dr
  memory_lock               meml       = ^[l
  memory_unlock             memu       = ^[m
Extended boolean capabilities:
  AX                        = true
  G0                        = false
  XT                        = true
Extended numeric capabilities:
  U8                        = -1
Extended string capabilities:
  Cr                        = ^[]112^G
  Cs                        = ^[]12;%p1%s^G
  E0                        = 
  E3                        = ^[[3J
  Ms                        = ^[]52;%p1%s;%p2%s^G
  S0                        = 
  Se                        = ^[[2 q
  Ss                        = ^[[%p1%d q
  kDC3                      = ^[[3;3~
  kDC4                      = ^[[3;4~
  kDC5                      = ^[[3;5~
  kDC6                      = ^[[3;6~
  kDC7                      = ^[[3;7~
  kDN                       = ^[[1;2B
  kDN3                      = ^[[1;3B
  kDN4                      = ^[[1;4B
  kDN5                      = ^[[1;5B
  kDN6                      = ^[[1;6B
  kDN7                      = ^[[1;7B
  kEND3                     = ^[[1;3F
  kEND4                     = ^[[1;4F
  kEND5                     = ^[[1;5F
  kEND6                     = ^[[1;6F
  kEND7                     = ^[[1;7F
  kHOM3                     = ^[[1;3H
  kHOM4                     = ^[[1;4H
  kHOM5                     = ^[[1;5H
  kHOM6                     = ^[[1;6H
  kHOM7                     = ^[[1;7H
  kIC3                      = ^[[2;3~
  kIC4                      = ^[[2;4~
  kIC5                      = ^[[2;5~
  kIC6                      = ^[[2;6~
  kIC7                      = ^[[2;7~
  kLFT3                     = ^[[1;3D
  kLFT4                     = ^[[1;4D
  kLFT5                     = ^[[1;5D
  kLFT6                     = ^[[1;6D
  kLFT7                     = ^[[1;7D
  kNXT3                     = ^[[6;3~
  kNXT4                     = ^[[6;4~
  kNXT5                     = ^[[6;5~
  kNXT6                     = ^[[6;6~
  kNXT7                     = ^[[6;7~
  kPRV3                     = ^[[5;3~
  kPRV4                     = ^[[5;4~
  kPRV5                     = ^[[5;5~
  kPRV6                     = ^[[5;6~
  kPRV7                     = ^[[5;7~
  kRIT3                     = ^[[1;3C
  kRIT4                     = ^[[1;4C
  kRIT5                     = ^[[1;5C
  kRIT6                     = ^[[1;6C
  kRIT7                     = ^[[1;7C
  kUP                       = ^[[1;2A
  kUP3                      = ^[[1;3A
  kUP4                      = ^[[1;4A
  kUP5                      = ^[[1;5A
  kUP6                      = ^[[1;6A
  kUP7                      = ^[[1;7A
  ka2                       = 
  kb1                       = 
  kb3                       = 
  kc2                       = 
  ext.resize_screen         = ^[[8;%p1%d;%p2%dt
  ext.reset_scroll_region   = ^[[r
  ext.enter_altfont_mode    = ^[[11m
  setrgbf                   = ^[[38;2;%p1%d;%p2%d;%p3%dm
  setrgbb                   = ^[[48;2;%p1%d;%p2%d;%p3%dm
  ext.save_title            = ^[[22;0t
  ext.restore_title         = ^[[23;0t
  ext.enable_lr_margin      = ^[[?69h
  ext.disable_lr_margin     = ^[[?69l
  ext.enable_bpaste         = ^[[?2004h
  ext.disable_bpaste        = ^[[?2004l
  ext.enable_focus          = ^[[?1004h
  ext.disable_focus         = ^[[?1004l
  ext.enable_mouse          = ^[[?1002h^[[?1006h
  ext.disable_mouse         = ^[[?1002l^[[?1006l
  ext.enable_mouse_move     = ^[[?1003h
  ext.disable_mouse_move    = ^[[?1003l
  ext.set_underline_style   = ^[[4:%p1%dm
  ext.set_underline_color   = ^[[58:2::%p1%d:%p2%d:%p3%dm
  Sync                      = ^[[?2026%?%p1%{1}%-%tl%eh%;
}}}


Executing: qa
Executing ExitPre Autocommands for "*"
autocommand <Lua 128: ~/.local/share/nvim/lazy/nvim-dap/lua/dap.lua:1338>

Executing: 
Executing BufWinLeave Autocommands for "*"
autocommand <Lua 209: ~/.local/share/nvim/lazy/nvim-dap-ui/lua/dapui/windows/init.lua:107>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 216: ~/.local/share/nvim/lazy/dap-helper.nvim/lua/dap-helper/init.lua:79>

Executing: 
Executing BufUnload Autocommands for "<buffer=1>"
autocommand <Lua 253: ~/.local/share/nvim/lazy/alpha-nvim/lua/alpha.lua:664>

Executing: 
Executing VimLeavePre Autocommands for "*"
autocommand <Lua 122: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:337>

Executing: %argdelete
Executing: mks! /Users/jkulrativid/.local/share/nvim/sessions/\%2FUsers\%2Fjkulrativid\%2F\%2Econfig\%2Fnvim.vim
chdir(/Users/jkulrativid/.config/nvim)
Executing: 
Writing ShaDa file "/Users/jkulrativid/.local/state/nvim/shada/main.shada"
Executing:     vnoremenu PopUp.Cut                     "+x
Executing:     vnoremenu PopUp.Copy                    "+y
Executing:     anoremenu PopUp.Paste                   "+gP
Executing:     vnoremenu PopUp.Paste                   "+P
Executing:     vnoremenu PopUp.Delete                  "_x
Executing:     nnoremenu PopUp.Select\ All             ggVG
Executing:     vnoremenu PopUp.Select\ All             gg0oG$
Executing:     inoremenu PopUp.Select\ All             <C-Home><C-O>VG
Executing:     anoremenu PopUp.Inspect                 <Cmd>Inspect<CR>
Executing:     anoremenu PopUp.-1-                     <Nop>
Executing:     anoremenu PopUp.How-to\ disable\ mouse  <Cmd>help disable-mouse<CR>
Executing:   
Searching for "ftplugin.vim" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/ftplugin.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin.vim"
sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin.vim"
line 1: " Vim support file to switch on loading plugins for file types
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last change:^I2023 Aug 10
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: if exists("did_load_ftplugin")
line 8:   finish
line 9: endif
line 10: let did_load_ftplugin = 1
line 11: 
line 12: augroup filetypeplugin
line 13:   au FileType * call s:LoadFTPlugin()
line 14: 
line 15:   func! s:LoadFTPlugin()
line 39: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin.vim
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/ftplugin.vim"
Searching for "indent.vim" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/indent.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/indent.vim"
sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/indent.vim"
line 1: " Vim support file to switch on loading indent files for file types
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last Change:^I2023 Aug 10
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: if exists("did_indent_on")
line 8:   finish
line 9: endif
line 10: let did_indent_on = 1
line 11: 
line 12: augroup filetypeindent
line 13:   au FileType * call s:LoadIndent()
line 14:   func! s:LoadIndent()
line 33: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/indent.vim
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/indent.vim"
could not source "/opt/homebrew/etc/xdg/nvim/sysinit.vim"
could not source "/etc/xdg/nvim/sysinit.vim"
could not source "$VIM/sysinit.vim"
sourcing "/Users/jkulrativid/.config/nvim/init.lua"
Executing: let g:netrw_liststyle = 3
Searching for "spell/en.utf-8.spl" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/spell/en.utf-8.spl"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/spell/en.utf-8.spl"
Reading spell file "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/spell/en.utf-8.spl"
Searching for "spell/en.utf-8.add.spl" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/spell/en.utf-8.add.spl"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/spell/en.utf-8.add.spl"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/spell/en.utf-8.add.spl"
not found in runtime path: "spell/en.utf-8.add.spl"
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/filetype.lua
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/filetype.lua"
Executing:   augroup filetypedetect
Executing:   runtime! ftdetect/*.{vim,lua}
Searching for "ftdetect/*.{vim,lua}" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/ftdetect/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/ftdetect/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftdetect/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/ftdetect/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/ftdetect/*.{vim,lua}"
not found in runtime path: "ftdetect/*.{vim,lua}"
Executing:   augroup END
Executing:   
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/filetype.lua
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: augroup filetypedetect
Executing: augroup END
Executing ColorSchemePre Autocommands for "*"
autocommand <Lua 30: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/loader.lua:31>

Executing: 
Searching for "colors/catppuccin.*" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/colors/catppuccin.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/colors/catppuccin.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/colors/catppuccin.*"
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/colors/catppuccin.vim"
line 1: lua require("catppuccin").load()
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/catppuccin/colors/catppuccin.vim
continuing in /Users/jkulrativid/.config/nvim/init.lua
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/plugin/nvim-web-devicons.vim
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/plugin/nvim-web-devicons.vim"
line 1: if exists('g:loaded_devicons') | finish | endif
line 1:  finish | endif
line 1:  endif
line 2: 
line 3: let s:save_cpo = &cpo
line 4: set cpo&vim
line 5: 
line 6: " TODO change so its easier to get
line 7: let g:nvim_web_devicons = 1
line 8: 
line 9: let &cpo = s:save_cpo
line 10: unlet s:save_cpo
line 11: 
line 12: let g:loaded_devicons = 1
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/plugin/nvim-web-devicons.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing:   highlight default link NvimDapVirtualText Comment
Executing:   highlight default link NvimDapVirtualTextChanged DiagnosticVirtualTextWarn
Executing:   highlight default link NvimDapVirtualTextError DiagnosticVirtualTextError
Executing:   highlight default link NvimDapVirtualTextInfo DiagnosticVirtualTextInfo
Executing:   
Executing:     command! DapVirtualTextEnable :lua require'nvim-dap-virtual-text'.enable()
Executing:     command! DapVirtualTextDisable :lua require'nvim-dap-virtual-text'.disable()
Executing:     command! DapVirtualTextToggle :lua require'nvim-dap-virtual-text'.toggle()
Executing:     command! DapVirtualTextForceRefresh :lua require'nvim-dap-virtual-text'.refresh()
Executing:     
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/plugin/dap.lua
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/plugin/dap.lua"
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/plugin/dap.lua
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing:   augroup DAPUIRefreshHighlights
Executing:     autocmd!
Executing:     autocmd ColorScheme * lua require('dapui.config.highlights').setup()
Executing:   augroup END
Executing:   hi default link DapUINormal Normal
Executing:   hi default link DapUIVariable Normal
Executing:   hi default DapUIScope guifg=#00F1F5
Executing:   hi default DapUIType guifg=#D484FF
Executing:   hi default link DapUIValue Normal
Executing:   hi default DapUIModifiedValue guifg=#00F1F5 gui=bold
Executing:   hi default DapUIDecoration guifg=#00F1F5
Executing:   hi default DapUIThread guifg=#A9FF68
Executing:   hi default DapUIStoppedThread guifg=#00f1f5
Executing:   hi default link DapUIFrameName Normal
Executing:   hi default DapUISource guifg=#D484FF
Executing:   hi default DapUILineNumber guifg=#00f1f5
Executing:   hi default link DapUIFloatNormal NormalFloat
Executing:   hi default DapUIFloatBorder guifg=#00F1F5
Executing:   hi default DapUIWatchesEmpty guifg=#F70067
Executing:   hi default DapUIWatchesValue guifg=#A9FF68
Executing:   hi default DapUIWatchesError guifg=#F70067
Executing:   hi default DapUIBreakpointsPath guifg=#00F1F5
Executing:   hi default DapUIBreakpointsInfo guifg=#A9FF68
Executing:   hi default DapUIBreakpointsCurrentLine guifg=#A9FF68 gui=bold
Executing:   hi default link DapUIBreakpointsLine DapUILineNumber
Executing:   hi default DapUIBreakpointsDisabledLine guifg=#424242
Executing:   hi default link DapUICurrentFrameName DapUIBreakpointsCurrentLine
Executing:   hi default DapUIStepOver guifg=#00f1f5
Executing:   hi default DapUIStepInto guifg=#00f1f5
Executing:   hi default DapUIStepBack guifg=#00f1f5
Executing:   hi default DapUIStepOut guifg=#00f1f5
Executing:   hi default DapUIStop guifg=#F70067
Executing:   hi default DapUIPlayPause guifg=#A9FF68
Executing:   hi default DapUIRestart guifg=#A9FF68
Executing:   hi default DapUIUnavailable guifg=#424242
Executing:   hi default DapUIWinSelect ctermfg=Cyan guifg=#00f1f5 gui=bold
Executing:   hi default link DapUIEndofBuffer EndofBuffer
Executing:   
Executing:   hi default link DapUINormal Normal
Executing:   hi default link DapUIVariable Normal
Executing:   hi default DapUIScope guifg=#00F1F5
Executing:   hi default DapUIType guifg=#D484FF
Executing:   hi default link DapUIValue Normal
Executing:   hi default DapUIModifiedValue guifg=#00F1F5 gui=bold
Executing:   hi default DapUIDecoration guifg=#00F1F5
Executing:   hi default DapUIThread guifg=#A9FF68
Executing:   hi default DapUIStoppedThread guifg=#00f1f5
Executing:   hi default link DapUIFrameName Normal
Executing:   hi default DapUISource guifg=#D484FF
Executing:   hi default DapUILineNumber guifg=#00f1f5
Executing:   hi default link DapUIFloatNormal NormalFloat
Executing:   hi default DapUIFloatBorder guifg=#00F1F5
Executing:   hi default DapUIWatchesEmpty guifg=#F70067
Executing:   hi default DapUIWatchesValue guifg=#A9FF68
Executing:   hi default DapUIWatchesError guifg=#F70067
Executing:   hi default DapUIBreakpointsPath guifg=#00F1F5
Executing:   hi default DapUIBreakpointsInfo guifg=#A9FF68
Executing:   hi default DapUIBreakpointsCurrentLine guifg=#A9FF68 gui=bold
Executing:   hi default link DapUIBreakpointsLine DapUILineNumber
Executing:   hi default DapUIBreakpointsDisabledLine guifg=#424242
Executing:   hi default link DapUICurrentFrameName DapUIBreakpointsCurrentLine
Executing:   hi default DapUIStepOver guifg=#00f1f5
Executing:   hi default DapUIStepInto guifg=#00f1f5
Executing:   hi default DapUIStepBack guifg=#00f1f5
Executing:   hi default DapUIStepOut guifg=#00f1f5
Executing:   hi default DapUIStop guifg=#F70067
Executing:   hi default DapUIPlayPause guifg=#A9FF68
Executing:   hi default DapUIRestart guifg=#A9FF68
Executing:   hi default DapUIUnavailable guifg=#424242
Executing:   hi default DapUIWinSelect ctermfg=Cyan guifg=#00f1f5 gui=bold
Executing:   hi default link DapUIEndofBuffer EndofBuffer
Executing:   
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/plugin/lsplines.vim
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/plugin/lsplines.vim"
line 1: if exists("g:loaded_lsplines")
line 2:   finish
line 3: endif
line 4: 
line 5: lua require("lsp_lines").setup()
line 6: 
line 7: let g:loaded_lsplines = 1
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/plugin/lsplines.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/plugin/plenary.vim
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/plugin/plenary.vim"
line 1: 
line 2: " Create command for running busted
line 3: command! -nargs=1 -complete=file PlenaryBustedFile lua require('plenary.test_harness').test_file([[<args>]])
line 5: 
line 6: command! -nargs=+ -complete=file PlenaryBustedDirectory lua require('plenary.test_harness').test_directory_command([[<args>]])
line 8: 
line 9: nnoremap <Plug>PlenaryTestFile :lua require('plenary.test_harness').test_file(vim.fn.expand("%:p"))<CR>
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/plugin/plenary.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/plugin/telescope.lua
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/plugin/telescope.lua"
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/plugin/telescope.lua
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: augroup filetypedetect
Executing: augroup END
Executing:  highlight default link NvimDapSubtleFrame Comment 
Executing:  highlight default link NvimDapSubtleFrame Comment 
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/plugin/tmux_navigator.vim
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/plugin/tmux_navigator.vim"
line 1: " Maps <C-h/j/k/l> to switch vim splits in the given direction. If there are
line 2: " no more windows in that direction, forwards the operation to tmux.
line 3: " Additionally, <C-\> toggles between last active vim splits/tmux panes.
line 4: 
line 5: if exists("g:loaded_tmux_navigator") || &cp || v:version < 700
line 6:   finish
line 7: endif
line 8: let g:loaded_tmux_navigator = 1
line 9: 
line 10: function! s:VimNavigate(direction)
line 17: 
line 18: if !get(g:, 'tmux_navigator_no_mappings', 0)
line 19:   nnoremap <silent> <c-h> :<C-U>TmuxNavigateLeft<cr>
line 20:   nnoremap <silent> <c-j> :<C-U>TmuxNavigateDown<cr>
line 21:   nnoremap <silent> <c-k> :<C-U>TmuxNavigateUp<cr>
line 22:   nnoremap <silent> <c-l> :<C-U>TmuxNavigateRight<cr>
line 23:   nnoremap <silent> <c-\> :<C-U>TmuxNavigatePrevious<cr>
line 24: 
line 25:   if !get(g:, 'tmux_navigator_disable_netrw_workaround', 0)
line 26:     if !exists('g:Netrw_UserMaps')
line 27:       let g:Netrw_UserMaps = [['<C-l>', '<C-U>TmuxNavigateRight<cr>']]
line 28:     else
line 29:       echohl ErrorMsg | echo 'vim-tmux-navigator conflicts with netrw <C-l> mapping. See https://github.com/christoomey/vim-tmux-navigator#netrw or add `let g:tmux_navigator_disable_netrw_workaround = 1` to suppress this warning.' | echohl None
line 29:  echo 'vim-tmux-navigator conflicts with netrw <C-l> mapping. See https://github.com/christoomey/vim-tmux-navigator#netrw or add `let g:tmux_navigator_disable_netrw_workaround = 1` to suppress this warning.' | echohl None
line 29:  echohl None
line 30:     endif
line 31:   endif
line 32: endif
line 33: 
line 34: if empty($TMUX)
line 35:   command! TmuxNavigateLeft call s:VimNavigate('h')
line 36:   command! TmuxNavigateDown call s:VimNavigate('j')
line 37:   command! TmuxNavigateUp call s:VimNavigate('k')
line 38:   command! TmuxNavigateRight call s:VimNavigate('l')
line 39:   command! TmuxNavigatePrevious call s:VimNavigate('p')
line 40:   finish
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/plugin/tmux_navigator.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup lualine | exe "autocmd!" | augroup END
Executing:  exe "autocmd!" | augroup END
Executing: autocmd!
Executing:  augroup END
Executing: highlight! lualine_b_normal guifg=#c3ccdc guibg=#112638 gui=None
Executing: highlight! lualine_c_normal guifg=#c3ccdc guibg=#112638 gui=None
Executing: highlight! lualine_a_normal guifg=#112638 guibg=#65D1FF gui=bold
Executing: highlight! lualine_b_command guifg=#c3ccdc guibg=#112638 gui=None
Executing: highlight! lualine_c_command guifg=#c3ccdc guibg=#112638 gui=None
Executing: highlight! lualine_a_command guifg=#112638 guibg=#FFDA7B gui=bold
Executing: highlight! lualine_b_insert guifg=#c3ccdc guibg=#112638 gui=None
Executing: highlight! lualine_c_insert guifg=#c3ccdc guibg=#112638 gui=None
Executing: highlight! lualine_a_insert guifg=#112638 guibg=#3EFFDC gui=bold
Executing: highlight! lualine_b_visual guifg=#c3ccdc guibg=#112638 gui=None
Executing: highlight! lualine_c_visual guifg=#c3ccdc guibg=#112638 gui=None
Executing: highlight! lualine_a_visual guifg=#112638 guibg=#FF61EF gui=bold
Executing: highlight! lualine_b_inactive guifg=None guibg=#2c3043 gui=None
Executing: highlight! lualine_c_inactive guifg=None guibg=#2c3043 gui=None
Executing: highlight! lualine_a_inactive guifg=None guibg=#2c3043 gui=bold
Executing: highlight! lualine_b_replace guifg=#c3ccdc guibg=#112638 gui=None
Executing: highlight! lualine_c_replace guifg=#c3ccdc guibg=#112638 gui=None
Executing: highlight! lualine_a_replace guifg=#112638 guibg=#FF4A4A gui=bold
Executing: autocmd lualine ColorScheme * lua require'lualine'.setup()
Executing:     autocmd lualine OptionSet background lua require'lualine'.setup()
Executing: au lualine BufEnter *
--- Autocommands ---
Executing: autocmd lualine BufEnter * lua require'lualine.components.branch.git_branch'.find_git_dir()
Executing: highlight! lualine_b_diff_added_normal guifg=#a6da95 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_added_insert guifg=#a6da95 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_added_visual guifg=#a6da95 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_added_replace guifg=#a6da95 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_added_command guifg=#a6da95 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_added_terminal guifg=#a6da95 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_added_inactive guifg=#a6da95 guibg=#2c3043 gui=None
Executing: highlight! lualine_b_diff_modified_normal guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_modified_insert guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_modified_visual guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_modified_replace guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_modified_command guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_modified_terminal guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_modified_inactive guifg=#eed49f guibg=#2c3043 gui=None
Executing: highlight! lualine_b_diff_removed_normal guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_removed_insert guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_removed_visual guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_removed_replace guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_removed_command guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_removed_terminal guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diff_removed_inactive guifg=#ed8796 guibg=#2c3043 gui=None
Executing: au lualine BufEnter *
--- Autocommands ---
lualine  BufEnter
    *         lua require'lualine.components.branch.git_branch'.find_git_dir()
	Last set from ~/.config/nvim/vim/_editor.lua
Executing: autocmd lualine BufEnter * lua require'lualine.components.diff.git_diff'.update_diff_args()
Executing: au lualine BufWritePost *
--- Autocommands ---
Executing: autocmd lualine BufWritePost * lua require'lualine.components.diff.git_diff'.update_git_diff()
Executing: highlight! lualine_b_diagnostics_error_normal guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_error_insert guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_error_visual guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_error_replace guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_error_command guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_error_terminal guifg=#ed8796 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_error_inactive guifg=#ed8796 guibg=#2c3043 gui=None
Executing: highlight! lualine_b_diagnostics_warn_normal guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_warn_insert guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_warn_visual guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_warn_replace guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_warn_command guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_warn_terminal guifg=#eed49f guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_warn_inactive guifg=#eed49f guibg=#2c3043 gui=None
Executing: highlight! lualine_b_diagnostics_info_normal guifg=#91d7e3 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_info_insert guifg=#91d7e3 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_info_visual guifg=#91d7e3 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_info_replace guifg=#91d7e3 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_info_command guifg=#91d7e3 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_info_terminal guifg=#91d7e3 guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_info_inactive guifg=#91d7e3 guibg=#2c3043 gui=None
Executing: highlight! lualine_b_diagnostics_hint_normal guifg=#8bd5ca guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_hint_insert guifg=#8bd5ca guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_hint_visual guifg=#8bd5ca guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_hint_replace guifg=#8bd5ca guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_hint_command guifg=#8bd5ca guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_hint_terminal guifg=#8bd5ca guibg=#112638 gui=None
Executing: highlight! lualine_b_diagnostics_hint_inactive guifg=#8bd5ca guibg=#2c3043 gui=None
Searching for "lua/lualine/components/copilot.lua" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/lua/lualine/components/copilot.lua"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/lualine/components/copilot.lua"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/lua/lualine/components/copilot.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/lua/lualine/components/copilot.lua"
Executing: highlight! lualine_x_copilot_sleep_normal guifg=#AEB7D0 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_sleep_insert guifg=#AEB7D0 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_sleep_visual guifg=#AEB7D0 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_sleep_replace guifg=#AEB7D0 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_sleep_command guifg=#AEB7D0 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_sleep_terminal guifg=#AEB7D0 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_sleep_inactive guifg=#AEB7D0 guibg=#2c3043 gui=None
Executing: highlight! lualine_x_copilot_enabled_normal guifg=#50FA7B guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_enabled_insert guifg=#50FA7B guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_enabled_visual guifg=#50FA7B guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_enabled_replace guifg=#50FA7B guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_enabled_command guifg=#50FA7B guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_enabled_terminal guifg=#50FA7B guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_enabled_inactive guifg=#50FA7B guibg=#2c3043 gui=None
Executing: highlight! lualine_x_copilot_disabled_normal guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_disabled_insert guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_disabled_visual guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_disabled_replace guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_disabled_command guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_disabled_terminal guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_disabled_inactive guifg=#6272A4 guibg=#2c3043 gui=None
Executing: highlight! lualine_x_copilot_offline_normal guifg=#FFB86C guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_offline_insert guifg=#FFB86C guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_offline_visual guifg=#FFB86C guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_offline_replace guifg=#FFB86C guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_offline_command guifg=#FFB86C guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_offline_terminal guifg=#FFB86C guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_offline_inactive guifg=#FFB86C guibg=#2c3043 gui=None
Executing: highlight! lualine_x_copilot_unknown_normal guifg=#FF5555 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_unknown_insert guifg=#FF5555 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_unknown_visual guifg=#FF5555 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_unknown_replace guifg=#FF5555 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_unknown_command guifg=#FF5555 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_unknown_terminal guifg=#FF5555 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_unknown_inactive guifg=#FF5555 guibg=#2c3043 gui=None
Executing: highlight! lualine_x_copilot_spinner_normal guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_spinner_insert guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_spinner_visual guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_spinner_replace guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_spinner_command guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_spinner_terminal guifg=#6272A4 guibg=#112638 gui=None
Executing: highlight! lualine_x_copilot_spinner_inactive guifg=#6272A4 guibg=#2c3043 gui=None
Executing: highlight! lualine_x_9_normal guifg=#ff9e64 guibg=#112638 gui=None
Executing: highlight! lualine_x_9_insert guifg=#ff9e64 guibg=#112638 gui=None
Executing: highlight! lualine_x_9_visual guifg=#ff9e64 guibg=#112638 gui=None
Executing: highlight! lualine_x_9_replace guifg=#ff9e64 guibg=#112638 gui=None
Executing: highlight! lualine_x_9_command guifg=#ff9e64 guibg=#112638 gui=None
Executing: highlight! lualine_x_9_terminal guifg=#ff9e64 guibg=#112638 gui=None
Executing: highlight! lualine_x_9_inactive guifg=#ff9e64 guibg=#2c3043 gui=None
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/editorconfig.lua
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/editorconfig.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/editorconfig.lua
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/gzip.vim
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/gzip.vim"
line 1: " Vim plugin for editing compressed files.
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " Exit quickly when:
line 7: " - this plugin was already loaded
line 8: " - when 'compatible' is set
line 9: " - some autocommands are already taking care of compressed files
line 10: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
line 11:   finish
line 12: endif
line 13: let loaded_gzip = 1
line 14: 
line 15: augroup gzip
line 16:   " Remove all gzip autocommands
line 17:   au!
line 18: 
line 19:   " Enable editing of gzipped files.
line 20:   " The functions are defined in autoload/gzip.vim.
line 21:   "
line 22:   " Set binary mode before reading the file.
line 23:   " Use "gzip -d", gunzip isn't always available.
line 24:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst,*.br,*.lzo setlocal bin
line 25:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")
line 26:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")
line 27:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")
line 28:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")
line 29:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")
line 30:   autocmd BufReadPost,FileReadPost^I*.lz  call gzip#read("lzip -d")
line 31:   autocmd BufReadPost,FileReadPost^I*.zst call gzip#read("zstd -d --rm")
line 32:   autocmd BufReadPost,FileReadPost^I*.br call gzip#read("brotli -d --rm")
line 33:   autocmd BufReadPost,FileReadPost^I*.lzo call gzip#read("lzop -d -U")
line 34:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")
line 35:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")
line 36:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")
line 37:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")
line 38:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")
line 39:   autocmd BufWritePost,FileWritePost^I*.lz  call gzip#write("lzip")
line 40:   autocmd BufWritePost,FileWritePost^I*.zst  call gzip#write("zstd --rm")
line 41:   autocmd BufWritePost,FileWritePost^I*.br  call gzip#write("brotli --rm")
line 42:   autocmd BufWritePost,FileWritePost^I*.lzo  call gzip#write("lzop -U")
line 43:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")
line 44:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")
line 45:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")
line 46:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")
line 47:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")
line 48:   autocmd FileAppendPre^I^I^I*.lz   call gzip#appre("lzip -d")
line 49:   autocmd FileAppendPre^I^I^I*.zst call gzip#appre("zstd -d --rm")
line 50:   autocmd FileAppendPre^I^I^I*.br call gzip#appre("brotli -d --rm")
line 51:   autocmd FileAppendPre^I^I^I*.lzo call gzip#appre("lzop -d -U")
line 52:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")
line 53:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")
line 54:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")
line 55:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")
line 56:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")
line 57:   autocmd FileAppendPost^I^I*.lz call gzip#write("lzip")
line 58:   autocmd FileAppendPost^I^I*.zst call gzip#write("zstd --rm")
line 59:   autocmd FileAppendPost^I^I*.br call gzip#write("brotli --rm")
line 60:   autocmd FileAppendPost^I^I*.lzo call gzip#write("lzop -U")
line 61: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/gzip.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/man.lua
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/man.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/man.lua
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/matchit.vim
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/matchit.vim"
line 1: " Nvim: load the matchit plugin by default.
line 2: if !exists("g:loaded_matchit") && stridx(&packpath, $VIMRUNTIME) >= 0
line 3:   packadd matchit
Searching for "pack/*/start/matchit" in "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/*/start/matchit"
not found in 'packpath': "pack/*/start/matchit"
Searching for "pack/*/opt/matchit" in "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/*/opt/matchit"
line 3: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim"
line 1: "  matchit.vim: (global plugin) Extended "%" matching
line 2: "  Maintainer:  Christian Brabandt
line 3: "  Version:     1.19
line 4: "  Last Change: 2023, June 28th
line 5: "  Repository:  https://github.com/chrisbra/matchit
line 6: "  Previous URL:http://www.vim.org/script.php?script_id=39
line 7: "  Previous Maintainer:  Benji Fisher PhD   <benji@member.AMS.org>
line 8: 
line 9: " Documentation:
line 10: "  The documentation is in a separate file: ../doc/matchit.txt
line 11: 
line 12: " Credits:
line 13: "  Vim editor by Bram Moolenaar (Thanks, Bram!)
line 14: "  Original script and design by Raul Segura Acevedo
line 15: "  Support for comments by Douglas Potts
line 16: "  Support for back references and other improvements by Benji Fisher
line 17: "  Support for many languages by Johannes Zellner
line 18: "  Suggestions for improvement, bug reports, and support for additional
line 19: "  languages by Jordi-Albert Batalla, Neil Bird, Servatius Brandt, Mark
line 20: "  Collett, Stephen Wall, Dany St-Amant, Yuheng Xie, and Johannes Zellner.
line 21: 
line 22: " Debugging:
line 23: "  If you'd like to try the built-in debugging commands...
line 24: "   :MatchDebug      to activate debugging for the current buffer
line 25: "  This saves the values of several key script variables as buffer-local
line 26: "  variables.  See the MatchDebug() function, below, for details.
line 27: 
line 28: " TODO:  I should think about multi-line patterns for b:match_words.
line 29: "   This would require an option:  how many lines to scan (default 1).
line 30: "   This would be useful for Python, maybe also for *ML.
line 31: " TODO:  Maybe I should add a menu so that people will actually use some of
line 32: "   the features that I have implemented.
line 33: " TODO:  Eliminate the MultiMatch function.  Add yet another argument to
line 34: "   Match_wrapper() instead.
line 35: " TODO:  Allow :let b:match_words = '\(\(foo\)\(bar\)\):\3\2:end\1'
line 36: " TODO:  Make backrefs safer by using '\V' (very no-magic).
line 37: " TODO:  Add a level of indirection, so that custom % scripts can use my
line 38: "   work but extend it.
line 39: 
line 40: " Allow user to prevent loading and prevent duplicate loading.
line 41: if exists("g:loaded_matchit") || &cp
line 42:   finish
line 43: endif
line 44: let g:loaded_matchit = 1
line 45: 
line 46: let s:save_cpo = &cpo
line 47: set cpo&vim
line 48: 
line 49: fun MatchEnable()
line 89: 
line 90: fun MatchDisable()
line 108: 
line 109: " Call this function to turn on debugging information.  Every time the main
line 110: " script is run, buffer variables will be saved.  These can be used directly
line 111: " or viewed using the menu items below.
line 112: if !exists(":MatchDebug")
line 113:   command! -nargs=0 MatchDebug call matchit#Match_debug()
line 114: endif
line 115: if !exists(":MatchDisable")
line 116:   command! -nargs=0 MatchDisable :call MatchDisable()
line 117: endif
line 118: if !exists(":MatchEnable")
line 119:   command! -nargs=0 MatchEnable :call MatchEnable()
line 120: endif
line 121: 
line 122: call MatchEnable()
calling MatchEnable()

line 1:   nnoremap <silent> <Plug>(MatchitNormalForward)     :<C-U>call matchit#Match_wrapper('',1,'n')<CR>
line 2:   nnoremap <silent> <Plug>(MatchitNormalBackward)    :<C-U>call matchit#Match_wrapper('',0,'n')<CR>
line 3:   xnoremap <silent> <Plug>(MatchitVisualForward)     :<C-U>call matchit#Match_wrapper('',1,'v')<CR>:if col("''") != col("$") \| exe ":normal! m'" \| endif<cr>gv``
line 5:   xnoremap <silent> <Plug>(MatchitVisualBackward)    :<C-U>call matchit#Match_wrapper('',0,'v')<CR>m'gv``
line 6:   onoremap <silent> <Plug>(MatchitOperationForward)  :<C-U>call matchit#Match_wrapper('',1,'o')<CR>
line 7:   onoremap <silent> <Plug>(MatchitOperationBackward) :<C-U>call matchit#Match_wrapper('',0,'o')<CR>
line 8: 
line 9:   " Analogues of [{ and ]} using matching patterns:
line 10:   nnoremap <silent> <Plug>(MatchitNormalMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>
line 11:   nnoremap <silent> <Plug>(MatchitNormalMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>
line 12:   xnoremap <silent> <Plug>(MatchitVisualMultiBackward)    :<C-U>call matchit#MultiMatch("bW", "n")<CR>m'gv``
line 13:   xnoremap <silent> <Plug>(MatchitVisualMultiForward)     :<C-U>call matchit#MultiMatch("W",  "n")<CR>m'gv``
line 14:   onoremap <silent> <Plug>(MatchitOperationMultiBackward) :<C-U>call matchit#MultiMatch("bW", "o")<CR>
line 15:   onoremap <silent> <Plug>(MatchitOperationMultiForward)  :<C-U>call matchit#MultiMatch("W",  "o")<CR>
line 16: 
line 17:   " text object:
line 18:   xmap <silent> <Plug>(MatchitVisualTextObject) <Plug>(MatchitVisualMultiBackward)o<Plug>(MatchitVisualMultiForward)
line 19: 
line 20:   if !exists("g:no_plugin_maps")
line 21:     nmap <silent> %  <Plug>(MatchitNormalForward)
line 22:     nmap <silent> g% <Plug>(MatchitNormalBackward)
line 23:     xmap <silent> %  <Plug>(MatchitVisualForward)
line 24:     xmap <silent> g% <Plug>(MatchitVisualBackward)
line 25:     omap <silent> %  <Plug>(MatchitOperationForward)
line 26:     omap <silent> g% <Plug>(MatchitOperationBackward)
line 27: 
line 28:     " Analogues of [{ and ]} using matching patterns:
line 29:     nmap <silent> [% <Plug>(MatchitNormalMultiBackward)
line 30:     nmap <silent> ]% <Plug>(MatchitNormalMultiForward)
line 31:     xmap <silent> [% <Plug>(MatchitVisualMultiBackward)
line 32:     xmap <silent> ]% <Plug>(MatchitVisualMultiForward)
line 33:     omap <silent> [% <Plug>(MatchitOperationMultiBackward)
line 34:     omap <silent> ]% <Plug>(MatchitOperationMultiForward)
line 35: 
line 36:     " Text object
line 37:     xmap a% <Plug>(MatchitVisualTextObject)
line 38:   endif
MatchEnable returning #0

continuing in /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim

line 123: 
line 124: let &cpo = s:save_cpo
line 125: unlet s:save_cpo
line 126: 
line 127: " vim:sts=2:sw=2:et:
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/plugin/matchit.vim
continuing in /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/matchit.vim
line 3: augroup filetypedetect
line 3: augroup END
line 4: endif
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/matchit.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/matchparen.vim
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/matchparen.vim"
line 1: " Vim plugin for showing matching parens
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2024 May 18
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " Exit quickly when:
line 7: " - this plugin was already loaded (or disabled)
line 8: " - when 'compatible' is set
line 9: if exists("g:loaded_matchparen") || &cp
line 10:   finish
line 11: endif
line 12: let g:loaded_matchparen = 1
line 13: 
line 14: if !exists("g:matchparen_timeout")
line 15:   let g:matchparen_timeout = 300
line 16: endif
line 17: if !exists("g:matchparen_insert_timeout")
line 18:   let g:matchparen_insert_timeout = 60
line 19: endif
line 20: 
line 21: let s:has_matchaddpos = exists('*matchaddpos')
line 22: 
line 23: augroup matchparen
line 24:   " Replace all matchparen autocommands
line 25:   autocmd! CursorMoved,CursorMovedI,WinEnter,WinScrolled * call s:Highlight_Matching_Pair()
line 26:   autocmd! BufWinEnter * autocmd SafeState * ++once call s:Highlight_Matching_Pair()
line 27:   autocmd! WinLeave,BufLeave * call s:Remove_Matches()
line 28:   if exists('##TextChanged')
line 29:     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
line 30:     autocmd! TextChangedP * call s:Remove_Matches()
line 31:   endif
line 32: augroup END
line 33: 
line 34: " Skip the rest if it was already done.
line 35: if exists("*s:Highlight_Matching_Pair")
line 36:   finish
line 37: endif
line 38: 
line 39: let s:cpo_save = &cpo
line 40: set cpo-=C
line 41: 
line 42: " The function that is invoked (very often) to define a ":match" highlighting
line 43: " for any matching paren.
line 44: func s:Highlight_Matching_Pair()
line 201: 
line 202: func s:Remove_Matches()
line 210: 
line 211: " Define commands that will disable and enable the plugin.
line 212: command DoMatchParen call s:DoMatchParen()
line 213: command NoMatchParen call s:NoMatchParen()
line 214: 
line 215: func s:NoMatchParen()
line 222: 
line 223: func s:DoMatchParen()
line 229: 
line 230: let &cpo = s:cpo_save
line 231: unlet s:cpo_save
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/matchparen.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/netrwPlugin.vim
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/netrwPlugin.vim"
line 1: " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
line 2: "            PLUGIN SECTION
line 3: " Maintainer:^IThis runtime file is looking for a new maintainer.
line 4: " Date:^I^IFeb 09, 2021
line 5: " Last Change:
line 6: "   2024 May 08 by Vim Project: cleanup legacy Win9X checks
line 7: " Former Maintainer:   Charles E Campbell
line 8: " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
line 9: " Copyright:    Copyright (C) 1999-2021 Charles E. Campbell {{{1
line 10: "               Permission is hereby granted to use and distribute this code,
line 11: "               with or without modifications, provided that this copyright
line 12: "               notice is copied with it. Like anything else that's free,
line 13: "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
line 14: "               *as is* and comes with no warranty of any kind, either
line 15: "               expressed or implied. By using this plugin, you agree that
line 16: "               in no event will the copyright holder be liable for any damages
line 17: "               resulting from the use of this software.
line 18: "
line 19: "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
line 20: "  (James 1:22 RSV)
line 21: " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
line 22: " Load Once: {{{1
line 23: if &cp || exists("g:loaded_netrwPlugin")
line 24:  finish
line 25: endif
line 26: let g:loaded_netrwPlugin = "v173"
line 27: let s:keepcpo = &cpo
line 28: set cpo&vim
line 29: "DechoRemOn
line 30: 
line 31: " ---------------------------------------------------------------------
line 32: " Public Interface: {{{1
line 33: 
line 34: " Local Browsing Autocmds: {{{2
line 35: augroup FileExplorer
line 36:  au!
line 37:  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
line 38:  au BufEnter *^Isil call s:LocalBrowse(expand("<amatch>"))
line 39:  au VimEnter *^Isil call s:VimEnter(expand("<amatch>"))
line 40:  if has("win32")
line 41:   au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
line 42:  endif
line 43: augroup END
line 44: 
line 45: " Network Browsing Reading Writing: {{{2
line 46: augroup Network
line 47:  au!
line 48:  au BufReadCmd   file://*^I^I^I^I^I^I^I^I^I^I^Icall netrw#FileUrlEdit(expand("<amatch>"))
line 49:  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
line 50:  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
line 51:  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
line 52:  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
line 53:  try
line 54:   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 55:  catch /^Vim\%((\a\+)\)\=:E216/
line 56:   au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 57:  endtry
line 58: augroup END
line 59: 
line 60: " Commands: :Nread, :Nwrite, :NetUserPass {{{2
line 61: com! -count=1 -nargs=*^INread^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
line 62: com! -range=% -nargs=*^INwrite^I^Ilet s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
line 63: com! -nargs=*^I^INetUserPass^Icall NetUserPass(<f-args>)
line 64: com! -nargs=*^I        Nsource^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
line 65: com! -nargs=?^I^INtree^I^Icall netrw#SetTreetop(1,<q-args>)
line 66: 
line 67: " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
line 68: com! -nargs=* -bar -bang -count=0 -complete=dir^IExplore^I^Icall netrw#Explore(<count>,0,0+<bang>0,<q-args>)
line 69: com! -nargs=* -bar -bang -count=0 -complete=dir^ISexplore^Icall netrw#Explore(<count>,1,0+<bang>0,<q-args>)
line 70: com! -nargs=* -bar -bang -count=0 -complete=dir^IHexplore^Icall netrw#Explore(<count>,1,2+<bang>0,<q-args>)
line 71: com! -nargs=* -bar -bang -count=0 -complete=dir^IVexplore^Icall netrw#Explore(<count>,1,4+<bang>0,<q-args>)
line 72: com! -nargs=* -bar       -count=0 -complete=dir^ITexplore^Icall netrw#Explore(<count>,0,6        ,<q-args>)
line 73: com! -nargs=* -bar -bang^I^I^INexplore^Icall netrw#Explore(-1,0,0,<q-args>)
line 74: com! -nargs=* -bar -bang^I^I^IPexplore^Icall netrw#Explore(-2,0,0,<q-args>)
line 75: com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore^Icall netrw#Lexplore(<count>,<bang>0,<q-args>)
line 76: 
line 77: " Commands: NetrwSettings {{{2
line 78: com! -nargs=0^INetrwSettings^Icall netrwSettings#NetrwSettings()
line 79: com! -bang^INetrwClean^Icall netrw#Clean(<bang>0)
line 80: 
line 81: " Maps:
line 82: if !exists("g:netrw_nogx")
line 83:  if maparg('gx','n') == ""
line 84:   if !hasmapto('<Plug>NetrwBrowseX')
line 85:    nmap <unique> gx <Plug>NetrwBrowseX
line 86:   endif
line 87:   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(netrw#GX(),netrw#CheckIfRemote(netrw#GX()))<cr>
line 88:  endif
line 89:  if maparg('gx','x') == ""
line 90:   if !hasmapto('<Plug>NetrwBrowseXVis')
line 91:    xmap <unique> gx <Plug>NetrwBrowseXVis
line 92:   endif
line 93:   xno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
line 94:  endif
line 95: endif
line 96: if exists("g:netrw_usetab") && g:netrw_usetab
line 97:  if maparg('<c-tab>','n') == ""
line 98:   nmap <unique> <c-tab> <Plug>NetrwShrink
line 99:  endif
line 100:  nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
line 101: endif
line 102: 
line 103: " ---------------------------------------------------------------------
line 104: " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
line 105: fun! s:LocalBrowse(dirname)
line 149: 
line 150: " ---------------------------------------------------------------------
line 151: " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
line 152: "             Its purpose: to look over all windows and run s:LocalBrowse() on
line 153: "             them, which checks if they're directories and will create a directory
line 154: "             listing when appropriate.
line 155: "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
line 156: "             has already been called.
line 157: fun! s:VimEnter(dirname)
line 177: 
line 178: " ---------------------------------------------------------------------
line 179: " NetrwStatusLine: {{{1
line 180: fun! NetrwStatusLine()
line 191: 
line 192: " ------------------------------------------------------------------------
line 193: " NetUserPass: set username and password for subsequent ftp transfer {{{1
line 194: "   Usage:  :call NetUserPass()^I^I^I-- will prompt for userid and password
line 195: "^I    :call NetUserPass("uid")^I^I-- will prompt for password
line 196: "^I    :call NetUserPass("uid","password") -- sets global userid and password
line 197: fun! NetUserPass(...)
line 221: 
line 222: " ------------------------------------------------------------------------
line 223: " Modelines And Restoration: {{{1
line 224: let &cpo= s:keepcpo
line 225: unlet s:keepcpo
line 226: " vim:ts=8 fdm=marker
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/netrwPlugin.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/osc52.lua
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/osc52.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/osc52.lua
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/rplugin.vim
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/rplugin.vim"
line 1: if exists('g:loaded_remote_plugins')
line 2:   finish
line 3: endif
line 4: let g:loaded_remote_plugins = '/path/to/manifest'
line 5: 
line 6: " Get the path to the rplugin manifest file.
line 7: function! s:GetManifestPath() abort
line 26: 
line 27: " Old manifest file based on known script locations.
line 28: function! s:GetOldManifestPaths() abort
line 43: 
line 44: function! s:GetManifest() abort
line 57: 
line 58: function! s:LoadRemotePlugins() abort
line 64: 
line 65: command! -bar UpdateRemotePlugins call remote#host#UpdateRemotePlugins()
line 66: 
line 67: if index(v:argv, "--clean") < 0
line 68:   call s:LoadRemotePlugins()
calling <SNR>48_LoadRemotePlugins()

line 1:   let g:loaded_remote_plugins = s:GetManifest()
calling <SNR>48_GetManifest()

line 1:   let manifest = s:GetManifestPath()
calling <SNR>48_GetManifestPath()

line 1:   let manifest_base = ''
line 2: 
line 3:   if exists('$NVIM_RPLUGIN_MANIFEST')
line 4:     return fnamemodify($NVIM_RPLUGIN_MANIFEST, ':p')
line 5:   endif
line 6: 
line 7:   let dest = stdpath('data')
line 8:   if !empty(dest)
line 9:     if !isdirectory(dest)
line 10:       if getftype(dest) != "link"
line 11:         call mkdir(dest, 'p', 0700)
line 12:       endif
line 13:     endif
line 14:     let manifest_base = dest
line 15:   endif
line 16: 
line 17:   return manifest_base.'/rplugin.vim'
<SNR>48_GetManifestPath returning '/Users/jkulrativid/.local/share/nvim/rplugin.vim'

continuing in <SNR>48_GetManifest

line 2:   if !filereadable(manifest)
line 3:     " Check if an old manifest file exists and move it to the new location.
line 4:     for old_manifest in s:GetOldManifestPaths()
calling <SNR>48_GetOldManifestPaths()

line 1:   let prefix = exists('$MYVIMRC') ? $MYVIMRC : matchstr(get(split(execute('scriptnames'), '\n'), 0, ''), '\f\+$')
line 4:   let origpath = fnamemodify(expand(prefix, 1), ':h').'/.'.fnamemodify(prefix, ':t').'-rplugin~'
line 6:   if !has('win32')
line 7:     return [origpath]
<SNR>48_GetOldManifestPaths returning ['/Users/jkulrativid/.config/nvim/.init.lua-rplugin~']

continuing in <SNR>48_GetManifest

line 5:       if filereadable(old_manifest)
line 6:         call rename(old_manifest, manifest)
line 7:         break
line 8:       endif
line 9:     endfor
line 4:     for old_manifest in s:GetOldManifestPaths()
line 5:       if filereadable(old_manifest)
line 6:         call rename(old_manifest, manifest)
line 7:         break
line 8:       endif
line 9:     endfor
line 10:   endif
line 11:   return manifest
<SNR>48_GetManifest returning '/Users/jkulrativid/.local/share/nvim/rplugin.vim'

continuing in <SNR>48_LoadRemotePlugins

line 2:   if filereadable(g:loaded_remote_plugins)
line 3:     execute 'source' fnameescape(g:loaded_remote_plugins)
line 4:   endif
<SNR>48_LoadRemotePlugins returning #0

continuing in /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/rplugin.vim

line 69: endif
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/rplugin.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/shada.vim
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/shada.vim"
line 1: if exists('g:loaded_shada_plugin')
line 2:   finish
line 3: endif
line 4: let g:loaded_shada_plugin = 1
line 5: 
line 6: augroup ShaDaCommands
line 7:   autocmd!
line 8:   autocmd BufReadCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call setline('.', shada#get_strings(readfile(expand('<afile>'),'b'))) |setlocal filetype=shada
line 12:   autocmd FileReadCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call append("'[", shada#get_strings(readfile(expand('<afile>'), 'b')))
line 15:   autocmd BufWriteCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |if writefile(shada#get_binstrings(getline(1, '$')),expand('<afile>'), 'b') == 0 |  let &l:modified = (expand('<afile>') is# bufname(+expand('<abuf>'))? 0: stridx(&cpoptions, '+') != -1) |endif
line 23:   autocmd FileWriteCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call writefile(shada#get_binstrings(getline(min([line("'["), line("']")]),max([line("'["), line("']")]))),expand('<afile>'),'b')
line 30:   autocmd FileAppendCmd *.shada,*.shada.tmp.[a-z] :if !empty(v:cmdarg)|throw '++opt not supported'|endif |call writefile(shada#get_binstrings(getline(min([line("'["), line("']")]),max([line("'["), line("']")]))),expand('<afile>'),'ab')
line 37:   autocmd SourceCmd *.shada,*.shada.tmp.[a-z] :execute 'rshada' fnameescape(expand('<afile>'))
line 39: augroup END
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/shada.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/spellfile.vim
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/spellfile.vim"
line 1: " Vim plugin for downloading spell files
line 2: 
line 3: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
line 4:   finish
line 5: endif
line 6: let loaded_spellfile_plugin = 1
line 7: 
line 8: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/spellfile.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/tarPlugin.vim
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/tarPlugin.vim"
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles
line 2: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
line 3: " Modified by Charles E. Campbell
line 4: " Distributed under the GNU General Public License.
line 5: "
line 6: " Updates are available from <http://michael.toren.net/code/>.  If you
line 7: " find this script useful, or have suggestions for improvements, please
line 8: " let me know.
line 9: " Also look there for further comments and documentation.
line 10: "
line 11: " This part only sets the autocommands.  The functions are in autoload/tar.vim.
line 12: " ---------------------------------------------------------------------
line 13: "  Load Once: {{{1
line 14: if &cp || exists("g:loaded_tarPlugin")
line 15:  finish
line 16: endif
line 17: let g:loaded_tarPlugin = "v32"
line 18: let s:keepcpo          = &cpo
line 19: set cpo&vim
line 20: 
line 21: " ---------------------------------------------------------------------
line 22: "  Public Interface: {{{1
line 23: augroup tar
line 24:   au!
line 25:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)
line 26:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)
line 27:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))
line 28:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))
line 29: 
line 30:   if has("unix")
line 31:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)
line 32:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)
line 33:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 34:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 35:   endif
line 36: 
line 37:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))
line 38:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))
line 39:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))
line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))
line 41:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))
line 42:   au BufReadCmd   *.tbz^I^I^Icall tar#Browse(expand("<amatch>"))
line 43:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))
line 44:   au BufReadCmd   *.tar.lzma^Icall tar#Browse(expand("<amatch>"))
line 45:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))
line 46:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))
line 47:   au BufReadCmd   *.tar.zst^I^Icall tar#Browse(expand("<amatch>"))
line 48:   au BufReadCmd   *.tzst^I^I^Icall tar#Browse(expand("<amatch>"))
line 49: augroup END
line 50: 
line 51: " ---------------------------------------------------------------------
line 52: " Restoration And Modelines: {{{1
line 53: " vim: fdm=marker
line 54: let &cpo= s:keepcpo
line 55: unlet s:keepcpo
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/tarPlugin.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/tohtml.lua
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/tohtml.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/tohtml.lua
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/tutor.vim
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/tutor.vim"
line 1: if exists('g:loaded_tutor_mode_plugin') || &compatible
line 2:     finish
line 3: endif
line 4: let g:loaded_tutor_mode_plugin = 1
line 5: 
line 6: command! -nargs=? -complete=custom,tutor#TutorCmdComplete Tutor call tutor#TutorCmd(<q-args>)
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/tutor.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing: source /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/zipPlugin.vim
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/zipPlugin.vim"
line 1: " zipPlugin.vim: Handles browsing zipfiles
line 2: "            PLUGIN PORTION
line 3: " Date:^I^I^IDec 07, 2021
line 4: " Maintainer:^IThis runtime file is looking for a new maintainer.
line 5: " Former Maintainer:^ICharles E Campbell
line 6: " License:^I^IVim License  (see vim's :help license)
line 7: " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
line 8: "               Permission is hereby granted to use and distribute this code,
line 9: "               with or without modifications, provided that this copyright
line 10: "               notice is copied with it. Like anything else that's free,
line 11: "               zipPlugin.vim is provided *as is* and comes with no warranty
line 12: "               of any kind, either expressed or implied. By using this
line 13: "               plugin, you agree that in no event will the copyright
line 14: "               holder be liable for any damages resulting from the use
line 15: "               of this software.
line 16: "
line 17: " (James 4:8 WEB) Draw near to God, and he will draw near to you.
line 18: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
line 19: " ---------------------------------------------------------------------
line 20: " Load Once: {{{1
line 21: if &cp || exists("g:loaded_zipPlugin")
line 22:  finish
line 23: endif
line 24: let g:loaded_zipPlugin = "v33"
line 25: let s:keepcpo          = &cpo
line 26: set cpo&vim
line 27: 
line 28: " ---------------------------------------------------------------------
line 29: " Options: {{{1
line 30: if !exists("g:zipPlugin_ext")
line 31:  let g:zipPlugin_ext='*.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
line 32: endif
line 33: 
line 34: " ---------------------------------------------------------------------
line 35: " Public Interface: {{{1
line 36: augroup zip
line 37:  au!
line 38:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)
line 39:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)
line 40:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))
line 41:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))
line 42: 
line 43:  if has("unix")
line 44:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)
line 45:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)
line 46:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 47:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 48:  endif
line 49: 
line 50:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
line 50: au BufReadCmd *.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip call zip#Browse(expand("<amatch>"))
line 51: augroup END
line 52: 
line 53: " ---------------------------------------------------------------------
line 54: "  Restoration And Modelines: {{{1
line 55: "  vim: fdm=marker
line 56: let &cpo= s:keepcpo
line 57: unlet s:keepcpo
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/zipPlugin.vim
continuing in nvim_exec2() called at /Users/jkulrativid/.config/nvim/init.lua:0
Executing User Autocommands for "LazyDone"
autocommand <Lua 29: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/util.lua:183>

Executing: 
finished sourcing /Users/jkulrativid/.config/nvim/init.lua
Searching for "filetype.lua filetype.vim" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/filetype.lua"
Searching for "/Users/jkulrativid/.config/nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/filetype.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/filetype.lua"
sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/filetype.lua"
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/filetype.lua
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/filetype.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/filetype.lua"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/filetype.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/filetype.lua"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/filetype.vim"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/filetype.lua"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/filetype.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/filetype.lua"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/filetype.vim"
Executing: so $VIMRUNTIME/syntax/syntax.vim
sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file is used for ":syntax on".
line 7: " It installs the autocommands and starts highlighting for all buffers.
line 8: 
line 9: if !has("syntax")
line 10:   finish
line 11: endif
line 12: 
line 13: " If Syntax highlighting appears to be on already, turn it off first, so that
line 14: " any leftovers are cleared.
line 15: if exists("syntax_on") || exists("syntax_manual")
line 16:   so <sfile>:p:h/nosyntax.vim
line 17: endif
line 18: 
line 19: " Load the Syntax autocommands and set the default methods for highlighting.
line 20: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/syntax/synload.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/syntax/synload.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/synload.vim"
line 20: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up for syntax highlighting.
line 7: " It is loaded from "syntax.vim" and "manual.vim".
line 8: " 1. Set the default highlight groups.
line 9: " 2. Install Syntax autocommands for all the available syntax files.
line 10: 
line 11: if !has("syntax")
line 12:   finish
line 13: endif
line 14: 
line 15: " let others know that syntax has been switched on
line 16: let syntax_on = 1
line 17: 
line 18: " Line continuation is used here, remove 'C' from 'cpoptions'
line 19: let s:cpo_save = &cpo
line 20: set cpo&vim
line 21: 
line 22: " First remove all old syntax autocommands.
line 23: au! Syntax
line 24: 
line 25: au Syntax *^I^Icall s:SynSet()
line 26: 
line 27: fun! s:SynSet()
line 58: 
line 59: 
line 60: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
line 61: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 66: 
line 67: 
line 68: " Source the user-specified syntax highlighting file
line 69: if exists("mysyntaxfile")
line 70:   let s:fname = expand(mysyntaxfile)
line 71:   if filereadable(s:fname)
line 72:     execute "source " . fnameescape(s:fname)
line 73:   endif
line 74: endif
line 75: 
line 76: " Restore 'cpoptions'
line 77: let &cpo = s:cpo_save
line 78: unlet s:cpo_save
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/synload.vim
continuing in /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/syntax.vim
line 21: 
line 22: " Load the FileType autocommands if not done yet.
line 23: if exists("did_load_filetypes")
line 24:   let s:did_ft = 1
line 25: else
line 26:   filetype on
line 27:   let s:did_ft = 0
line 28: endif
line 29: 
line 30: " Set up the connection between FileType and Syntax autocommands.
line 31: " This makes the syntax automatically set when the file type is detected
line 32: " unless treesitter highlighting is enabled.
line 33: " Avoid an error when 'verbose' is set and <amatch> expansion fails.
line 34: augroup syntaxset
line 35:   au! FileType *^Iif !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
line 36: augroup END
line 37: 
line 38: " Execute the syntax autocommands for the each buffer.
line 39: " If the filetype wasn't detected yet, do that now.
line 40: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 41: " already was set manually (e.g., help buffers).
line 42: doautoall syntaxset FileType
Executing FileType Autocommands for "*"
autocommand if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif

Executing: if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  endif
line 43: if !s:did_ft
line 44:   doautoall filetypedetect BufRead
line 45: endif
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/syntax.vim
Reading ShaDa file "/Users/jkulrativid/.local/state/nvim/shada/main.shada" info marks oldfiles
Executing BufWinEnter Autocommands for "*"
autocommand <Lua 160: ~/.local/share/nvim/lazy/nvim-dap-ui/lua/dapui/windows/init.lua:107>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand autocmd SafeState * ++once call s:Highlight_Matching_Pair()

Executing: autocmd SafeState * ++once call s:Highlight_Matching_Pair()
Executing BufEnter Autocommands for "*"
autocommand <Lua 122: ~/.local/share/nvim/lazy/bufferline.nvim/lua/bufferline.lua:141>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand lua require'lualine.components.branch.git_branch'.find_git_dir()

Executing: lua require'lualine.components.branch.git_branch'.find_git_dir()
autocommand lua require'lualine.components.diff.git_diff'.update_diff_args()

Executing: lua require'lualine.components.diff.git_diff'.update_diff_args()
Executing BufEnter Autocommands for "*"
autocommand sil call s:LocalBrowse(expand("<amatch>"))

Executing: sil call s:LocalBrowse(expand("<amatch>"))
calling <SNR>46_LocalBrowse('')

line 1:   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
line 2:   " Otherwise, the BufEnter event gets triggered when attempts to write to
line 3:   " the DBG buffer are made.
line 4: 
line 5:   if !exists("s:vimentered")
line 6:    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
line 7:    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
line 8: "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
line 9: "   call Dret("s:LocalBrowse")
line 10:    return
<SNR>46_LocalBrowse returning #0

continuing in BufEnter Autocommands for "*"

Executing VimEnter Autocommands for "*"
autocommand <Lua 24: vim/_defaults.lua:0>

Executing: 
Executing VimEnter Autocommands for "*"
autocommand <Lua 40: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/handler/event.lua:72>

Executing: augroup filetypedetect
Executing: augroup END
Executing: autocmd FileType alpha setlocal nofoldenable
Executing VimEnter Autocommands for "*"
autocommand <Lua 238: ~/.local/share/nvim/lazy/alpha-nvim/lua/alpha.lua:784>

Executing FileType Autocommands for "*"
autocommand call s:LoadFTPlugin()

Executing: call s:LoadFTPlugin()
calling <SNR>2_LoadFTPlugin()

line 1:     if exists("b:undo_ftplugin")
line 2:       exe b:undo_ftplugin
line 3:       unlet! b:undo_ftplugin b:did_ftplugin
line 4:     endif
line 5: 
line 6:     let s = expand("<amatch>")
line 7:     if s != ""
line 8:       if &cpo =~# "S" && exists("b:did_ftplugin")
line 9: ^I" In compatible mode options are reset to the global values, need to
line 10: ^I" set the local values also when a plugin was already used.
line 11: ^Iunlet b:did_ftplugin
line 12:       endif
line 13: 
line 14:       " When there is a dot it is used to separate filetype names.  Thus for
line 15:       " "aaa.bbb" load "aaa" and then "bbb".
line 16:       for name in split(s, '\.')
line 17:         " Load Lua ftplugins after Vim ftplugins _per directory_
line 18:         " TODO(clason): use nvim__get_runtime when supports globs and modeline
line 19:         " XXX: "[.]" in the first pattern makes it a wildcard on Windows
line 20:         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
line 20: runtime! ftplugin/alpha[.]{vim,lua} ftplugin/alpha_*.{vim,lua} ftplugin/alpha/*.{vim,lua}
Searching for "ftplugin/alpha[.]{vim,lua} ftplugin/alpha_*.{vim,lua} ftplugin/alpha/*.{vim,lua}" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.config/nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.config/nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/ftplugin/alpha/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/alpha[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/alpha_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/alpha/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/alpha[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/alpha_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/alpha/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/ftplugin/alpha[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/ftplugin/alpha_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/ftplugin/alpha/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/ftplugin/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/ftplugin/alpha_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/ftplugin/alpha/*.{vim,lua}"
not found in runtime path: "ftplugin/alpha[.]{vim,lua} ftplugin/alpha_*.{vim,lua} ftplugin/alpha/*.{vim,lua}"
line 21:       endfor
line 16:       for name in split(s, '\.')
line 17:         " Load Lua ftplugins after Vim ftplugins _per directory_
line 18:         " TODO(clason): use nvim__get_runtime when supports globs and modeline
line 19:         " XXX: "[.]" in the first pattern makes it a wildcard on Windows
line 20:         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
line 21:       endfor
line 22:     endif
<SNR>2_LoadFTPlugin returning #0

continuing in FileType Autocommands for "*"

Executing FileType Autocommands for "*"
autocommand call s:LoadIndent()

Executing: call s:LoadIndent()
calling <SNR>3_LoadIndent()

line 1:     if exists("b:undo_indent")
line 2:       exe b:undo_indent
line 3:       unlet! b:undo_indent b:did_indent
line 4:     endif
line 5:     let s = expand("<amatch>")
line 6:     if s != ""
line 7:       if exists("b:did_indent")
line 8: ^Iunlet b:did_indent
line 9:       endif
line 10: 
line 11:       " When there is a dot it is used to separate filetype names.  Thus for
line 12:       " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
line 13:       for name in split(s, '\.')
line 14:         " XXX: "[.]" in the pattern makes it a wildcard on Windows
line 15:         exe $'runtime! indent/{name}[.]{{vim,lua}}'
line 15: runtime! indent/alpha[.]{vim,lua}
Searching for "indent/alpha[.]{vim,lua}" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/indent/alpha[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/indent/alpha[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/indent/alpha[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/indent/alpha[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/indent/alpha[.]{vim,lua}"
not found in runtime path: "indent/alpha[.]{vim,lua}"
line 16:       endfor
line 13:       for name in split(s, '\.')
line 14:         " XXX: "[.]" in the pattern makes it a wildcard on Windows
line 15:         exe $'runtime! indent/{name}[.]{{vim,lua}}'
line 16:       endfor
line 17:     endif
<SNR>3_LoadIndent returning #0

continuing in FileType Autocommands for "*"

Executing FileType Autocommands for "*"
autocommand if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif

Executing: if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  endif
Executing FileType Autocommands for "alpha"
autocommand setlocal nofoldenable

Executing: setlocal nofoldenable
Executing: 
Executing: 
Executing VimEnter Autocommands for "*"
autocommand <Lua 179: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:299>

Executing: 
Executing VimEnter Autocommands for "*"
autocommand sil call s:VimEnter(expand("<amatch>"))

Executing: sil call s:VimEnter(expand("<amatch>"))
calling <SNR>46_VimEnter('')

line 1: "  call Dfunc("s:VimEnter(dirname<".a:dirname.">) expand(%)<".expand("%").">")
line 2:   if has('nvim') || v:version < 802
line 3:   " Johann Höchtl: reported that the call range... line causes an E488: Trailing characters
line 4:   "                error with neovim. I suspect its because neovim hasn't updated with recent
line 5:   "                vim patches. As is, this code will have problems with popup terminals
line 6:   "                instantiated before the VimEnter event runs.
line 7:   " Ingo Karkat  : E488 also in Vim 8.1.1602
line 8:   let curwin       = winnr()
line 9:   let s:vimentered = 1
line 10:   windo call s:LocalBrowse(expand("%:p"))
line 10: call s:LocalBrowse(expand("%:p"))
calling <SNR>46_LocalBrowse('')

line 1:   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
line 2:   " Otherwise, the BufEnter event gets triggered when attempts to write to
line 3:   " the DBG buffer are made.
line 4: 
line 5:   if !exists("s:vimentered")
line 6:    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
line 7:    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
line 8: "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
line 9: "   call Dret("s:LocalBrowse")
line 10:    return
line 11:   endif
line 12: 
line 13: "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
line 14: 
line 15:   if has("amiga")
line 16:    " The check against '' is made for the Amiga, where the empty
line 17:    " string is the current directory and not checking would break
line 18:    " things such as the help command.
line 19: "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
line 20:    if a:dirname != '' && isdirectory(a:dirname)
line 21:     sil! call netrw#LocalBrowseCheck(a:dirname)
line 22:     if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
line 23:      exe w:netrw_bannercnt
line 24:     endif
line 25:    endif
line 26: 
line 27:   elseif isdirectory(a:dirname)
line 28: "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
line 29: "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
line 30:    " Jul 13, 2021: for whatever reason, preceding the following call with
line 31:    " a   sil!  causes an unbalanced if-endif vim error
line 32:    call netrw#LocalBrowseCheck(a:dirname)
line 33:    if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
line 34:     exe w:netrw_bannercnt
line 35:    endif
line 36: 
line 37:   else
line 38:    " not a directory, ignore it
line 39: "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
line 40:   endif
line 41: 
line 42: "  call Dret("s:LocalBrowse")
<SNR>46_LocalBrowse returning #0

continuing in <SNR>46_VimEnter

line 11:   exe curwin."wincmd w"
line 11: 1wincmd w
line 12:  else
line 13:   " the following complicated expression comes courtesy of lacygoill; largely does the same thing as the windo and 
line 14:   " wincmd which are commented out, but avoids some side effects. Allows popup terminal before VimEnter.
line 15:   let s:vimentered = 1
line 16:   call range(1, winnr('$'))->map({_, v -> win_execute(win_getid(v), 'call expand("%:p")->s:LocalBrowse()')})
line 17:  endif
line 18: "  call Dret("s:VimEnter")
<SNR>46_VimEnter returning #0

continuing in VimEnter Autocommands for "*"

Executing UIEnter Autocommands for "*"
autocommand <Lua 27: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/config.lua:326>

Executing: 
autocommand <Lua 232: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/util.lua:189>

Executing: 
Searching for "autoload/provider/clipboard.vim" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/autoload/provider/clipboard.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/autoload/provider/clipboard.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/autoload/provider/clipboard.vim"
sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/autoload/provider/clipboard.vim"
line 1: " The clipboard provider uses shell commands to communicate with the clipboard.
line 2: " The provider function will only be registered if a supported command is
line 3: " available.
line 4: 
line 5: if exists('g:loaded_clipboard_provider')
line 6:   finish
line 7: endif
line 8: " Default to 1.  provider#clipboard#Executable() may set 2.
line 9: " To force a reload:
line 10: "   :unlet g:loaded_clipboard_provider
line 11: "   :runtime autoload/provider/clipboard.vim
line 12: let g:loaded_clipboard_provider = 1
line 13: 
line 14: let s:copy = {}
line 15: let s:paste = {}
line 16: let s:clipboard = {}
line 17: 
line 18: " When caching is enabled, store the jobid of the xclip/xsel process keeping
line 19: " ownership of the selection, so we know how long the cache is valid.
line 20: let s:selection = { 'owner': 0, 'data': [], 'stderr_buffered': v:true }
line 21: 
line 22: function! s:selection.on_exit(jobid, data, event) abort
line 35: 
line 36: let s:selections = { '*': s:selection, '+': copy(s:selection) }
line 37: 
line 38: function! s:try_cmd(cmd, ...) abort
line 51: 
line 52: " Returns TRUE if `cmd` exits with success, else FALSE.
line 53: function! s:cmd_ok(cmd) abort
line 57: 
line 58: function! s:split_cmd(cmd) abort
line 61: 
line 62: let s:cache_enabled = 1
line 63: let s:err = ''
line 64: 
line 65: function! provider#clipboard#Error() abort
line 68: 
line 69: function! provider#clipboard#Executable() abort
line 165: 
line 166: function! s:clipboard.get(reg) abort
line 183: 
line 184: function! s:clipboard.set(lines, regtype, reg) abort
line 242: 
line 243: function! provider#clipboard#Call(method, args) abort
line 254: 
line 255: " eval_has_provider() decides based on this variable.
line 256: let g:loaded_clipboard_provider = empty(provider#clipboard#Executable()) ? 1 : 2
calling provider#clipboard#Executable()

line 1:   " Setting g:clipboard to v:false explicitly opts-in to using the "builtin" clipboard providers below
line 2:   if exists('g:clipboard') && g:clipboard isnot# v:false
line 3:     if type({}) isnot# type(g:clipboard) || type({}) isnot# type(get(g:clipboard, 'copy', v:null)) || type({}) isnot# type(get(g:clipboard, 'paste', v:null))
line 6:       let s:err = 'clipboard: invalid g:clipboard'
line 7:       return ''
line 8:     endif
line 9: 
line 10:     let s:copy = {}
line 11:     let s:copy['+'] = s:split_cmd(get(g:clipboard.copy, '+', v:null))
line 12:     let s:copy['*'] = s:split_cmd(get(g:clipboard.copy, '*', v:null))
line 13: 
line 14:     let s:paste = {}
line 15:     let s:paste['+'] = s:split_cmd(get(g:clipboard.paste, '+', v:null))
line 16:     let s:paste['*'] = s:split_cmd(get(g:clipboard.paste, '*', v:null))
line 17: 
line 18:     let s:cache_enabled = get(g:clipboard, 'cache_enabled', 0)
line 19:     return get(g:clipboard, 'name', 'g:clipboard')
line 20:   elseif has('mac')
line 21:     let s:copy['+'] = ['pbcopy']
line 22:     let s:paste['+'] = ['pbpaste']
line 23:     let s:copy['*'] = s:copy['+']
line 24:     let s:paste['*'] = s:paste['+']
line 25:     let s:cache_enabled = 0
line 26:     return 'pbcopy'
provider#clipboard#Executable returning 'pbcopy'

continuing in /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/autoload/provider/clipboard.vim

finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/autoload/provider/clipboard.vim
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "<buffer=1>"
autocommand <Lua 245: ~/.local/share/nvim/lazy/alpha-nvim/lua/alpha.lua:525>

Executing: 
Executing TextChanged Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in TextChanged Autocommands for "*"

Executing SafeState Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in SafeState Autocommands for "*"

Executing: autocmd User CocDiagnosticChange lua require('bufferline.diagnostics').refresh_coc_diagnostics()
Executing: highlight! lualine_x_filetype_DevIconDefault_normal guifg=#6d8086 guibg=#112638 gui=None
Executing: highlight! lualine_x_filetype_DevIconDefault_insert guifg=#6d8086 guibg=#112638 gui=None
Executing: highlight! lualine_x_filetype_DevIconDefault_visual guifg=#6d8086 guibg=#112638 gui=None
Executing: highlight! lualine_x_filetype_DevIconDefault_replace guifg=#6d8086 guibg=#112638 gui=None
Executing: highlight! lualine_x_filetype_DevIconDefault_command guifg=#6d8086 guibg=#112638 gui=None
Executing: highlight! lualine_x_filetype_DevIconDefault_terminal guifg=#6d8086 guibg=#112638 gui=None
Executing: highlight! lualine_x_filetype_DevIconDefault_inactive guifg=#6d8086 guibg=#2c3043 gui=None
Executing: highlight! lualine_transitional_lualine_a_normal_to_lualine_b_normal guifg=#65D1FF guibg=#112638 gui=None
Executing TermResponse Autocommands for "*"
autocommand <Lua 22: vim/_defaults.lua:0>

Executing: 
Executing User Autocommands for "VeryLazy"
autocommand <Lua 28: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/config.lua:337>

Executing: 
Executing User Autocommands for "VeryLazy"
autocommand <Lua 41: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/handler/event.lua:72>

Executing: source /Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/plugin/which-key.lua
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/plugin/which-key.lua"
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/plugin/which-key.lua
continuing in nvim_exec2() called at User Autocommands for "VeryLazy":0
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/plugin/dressing.lua
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/plugin/dressing.lua"
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/plugin/dressing.lua
continuing in nvim_exec2() called at User Autocommands for "VeryLazy":0
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/plugin/mkdp.vim
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/plugin/mkdp.vim"
line 1: " set to 1, the vim will open the preview window once enter the markdown
line 2: " buffer
line 3: if !exists('g:mkdp_auto_start')
line 4:   let g:mkdp_auto_start = 0
line 5: endif
line 6: 
line 7: " let g:mkdp_auto_open = 0
line 8: " set to 1, the vim will auto open preview window when you edit the
line 9: " markdown file
line 10: 
line 11: " set to 1, the vim will auto close current preview window when change
line 12: " from markdown buffer to another buffer
line 13: if !exists('g:mkdp_auto_close')
line 14:   let g:mkdp_auto_close = 1
line 15: endif
line 16: 
line 17: " set to 1, the vim will just refresh markdown when save the buffer or
line 18: " leave from insert mode, default 0 is auto refresh markdown as you edit or
line 19: " move the cursor
line 20: if !exists('g:mkdp_refresh_slow')
line 21:   let g:mkdp_refresh_slow = 0
line 22: endif
line 23: 
line 24: " set to 1, the MarkdownPreview command can be use for all files,
line 25: " by default it just can be use in markdown file
line 26: if !exists('g:mkdp_command_for_global')
line 27:   let g:mkdp_command_for_global = 0
line 28: endif
line 29: 
line 30: " set to 1, preview server available to others in your network
line 31: " by default, the server only listens on localhost (127.0.0.1)
line 32: if !exists('g:mkdp_open_to_the_world')
line 33:   let g:mkdp_open_to_the_world = 0
line 34: endif
line 35: 
line 36: " use custom ip to open preview page
line 37: " default empty
line 38: if !exists('g:mkdp_open_ip')
line 39:   let g:mkdp_open_ip = ''
line 40: endif
line 41: 
line 42: " set to 1, echo preview page url in command line when open preview page
line 43: " default is 0
line 44: if !exists('g:mkdp_echo_preview_url')
line 45:   let g:mkdp_echo_preview_url = 0
line 46: endif
line 47: 
line 48: " use custom vim function to open preview page
line 49: " this function will receive url as param
line 50: if !exists('g:mkdp_browserfunc')
line 51:   let g:mkdp_browserfunc = ''
line 52: endif
line 53: 
line 54: " specify browser to open preview page
line 55: if !exists('g:mkdp_browser')
line 56:   let g:mkdp_browser = ''
line 57: endif
line 58: 
line 59: if !exists('g:mkdp_preview_options')
line 60:   let g:mkdp_preview_options = { 'mkit': {}, 'katex': {}, 'uml': {}, 'maid': {}, 'disable_sync_scroll': 0, 'sync_scroll_type': 'middle', 'hide_yaml_meta': 1, 'sequence_diagrams': {}, 'flowchart_diagrams': {}, 'content_editable': v:false, 'disable_filename': 0, 'toc': {} }
line 74: elseif !has_key(g:mkdp_preview_options, 'disable_filename')
line 75:   let g:mkdp_preview_options['disable_filename'] = 0
line 76: endif
line 77: 
line 78: " markdown css file absolute path
line 79: if !exists('g:mkdp_markdown_css')
line 80:   let g:mkdp_markdown_css = ''
line 81: endif
line 82: 
line 83: " highlight css file absolute path
line 84: if !exists('g:mkdp_highlight_css')
line 85:   let g:mkdp_highlight_css = ''
line 86: endif
line 87: 
line 88: if !exists('g:mkdp_port')
line 89:   let g:mkdp_port = ''
line 90: endif
line 91: 
line 92: " preview page title
line 93: " ${name} will be replace with the file name
line 94: if !exists('g:mkdp_page_title')
line 95:   let g:mkdp_page_title = '「${name}」'
line 96: endif
line 97: 
line 98: " recognized filetypes
line 99: if !exists('g:mkdp_filetypes')
line 100:   let g:mkdp_filetypes = ['markdown']
line 101: endif
line 102: 
line 103: " markdown images custom path
line 104: if !exists('g:mkdp_images_path')
line 105:   let g:mkdp_images_path = ''
line 106: endif
line 107: 
line 108: " combine preview window
line 109: if !exists('g:mkdp_combine_preview')
line 110:   let g:mkdp_combine_preview = 0
line 111: endif
line 112: 
line 113: " auto refetch combine preview contents when change markdown buffer
line 114: " only when g:mkdp_combine_preview is 1
line 115: if !exists('g:mkdp_combine_preview_auto_refresh')
line 116:   let g:mkdp_combine_preview_auto_refresh = 1
line 117: endif
line 118: 
line 119: " if there are any active preview client
line 120: let g:mkdp_clients_active = 0
line 121: 
line 122: function! s:init_command() abort
line 134: 
line 135: function! s:init() abort
line 151: 
line 152: call s:init()
calling <SNR>65_init()

line 1:   augroup mkdp_init
line 2:     autocmd!
line 3:     if g:mkdp_command_for_global
line 4:       autocmd BufEnter * :call s:init_command()
line 5:     else
line 6:       autocmd BufEnter,FileType * if index(g:mkdp_filetypes, &filetype) !=# -1 | call s:init_command() | endif
line 7:     endif
line 8:     if g:mkdp_auto_start
line 9:       execute 'autocmd BufEnter *.{md,mkd,mdown,mkdn,mdwn,' . join(g:mkdp_filetypes, ',') . '} call mkdp#util#open_preview_page()'
line 10:     endif
line 11:     if g:mkdp_combine_preview && g:mkdp_combine_preview_auto_refresh
line 12:       execute 'autocmd BufEnter *.{md,mkd,mdown,mkdn,mdwn,' . join(g:mkdp_filetypes, ',') . '} call mkdp#util#combine_preview_refresh()'
line 13:     endif
line 14:   augroup END
<SNR>65_init returning #0

continuing in /Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/plugin/mkdp.vim

finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/plugin/mkdp.vim
continuing in nvim_exec2() called at User Autocommands for "VeryLazy":0
Executing: 


--- Terminal info --- {{{
&term: xterm-256color
Description: xterm with 256 colors
Aliases: xterm-256color
Boolean capabilities:
  auto_left_margin          bw         = false
  auto_right_margin         am         = true
  no_esc_ctlc               xsb        = false
  ceol_standout_glitch      xhp        = false
  eat_newline_glitch        xenl       = true
  erase_overstrike          eo         = false
  generic_type              gn         = false
  hard_copy                 hc         = false
  has_meta_key              km         = true
  has_status_line           hs         = false
  insert_null_glitch        in         = false
  memory_above              da         = false
  memory_below              db         = false
  move_insert_mode          mir        = true
  move_standout_mode        msgr       = true
  over_strike               os         = false
  status_line_esc_ok        eslok      = false
  dest_tabs_magic_smso      xt         = false
  tilde_glitch              hz         = false
  transparent_underline     ul         = false
  xon_xoff                  xon        = false
  needs_xon_xoff            nxon       = false
  prtr_silent               mc5i       = true
  hard_cursor               chts       = false
  non_rev_rmcup             nrrmc      = false
  no_pad_char               npc        = true
  non_dest_scroll_region    ndscr      = false
  can_change                ccc        = true
  back_color_erase          bce        = true
  hue_lightness_saturation  hls        = false
  col_addr_glitch           xhpa       = false
  cr_cancels_micro_mode     crxm       = false
  has_print_wheel           daisy      = false
  row_addr_glitch           xvpa       = false
  semi_auto_right_margin    sam        = false
  cpi_changes_res           cpix       = false
  lpi_changes_res           lpix       = false
  backspaces_with_bs        OTbs       = true
  crt_no_scrolling          OTns       = false
  no_correctly_working_cr   OTnc       = false
  gnu_has_meta_key          OTMT       = false
  linefeed_is_newline       OTNL       = false
  has_hardware_tabs         OTpt       = false
  return_does_clr_eol       OTxr       = false
Numeric capabilities:
  columns                   cols       = 80
  init_tabs                 it         = 8
  lines                     lines      = 24
  lines_of_memory           lm         = -1
  magic_cookie_glitch       xmc        = -1
  padding_baud_rate         pb         = -1
  virtual_terminal          vt         = -1
  width_status_line         wsl        = -1
  num_labels                nlab       = -1
  label_height              lh         = -1
  label_width               lw         = -1
  max_attributes            ma         = -1
  maximum_windows           wnum       = -1
  max_colors                colors     = 256
  max_pairs                 pairs      = 32767
  no_color_video            ncv        = -1
  buffer_capacity           bufsz      = -1
  dot_vert_spacing          spinv      = -1
  dot_horz_spacing          spinh      = -1
  max_micro_address         maddr      = -1
  max_micro_jump            mjump      = -1
  micro_col_size            mcs        = -1
  micro_line_size           mls        = -1
  number_of_pins            npins      = -1
  output_res_char           orc        = -1
  output_res_line           orl        = -1
  output_res_horz_inch      orhi       = -1
  output_res_vert_inch      orvi       = -1
  print_rate                cps        = -1
  wide_char_size            widcs      = -1
  buttons                   btns       = -1
  bit_image_entwining       bitwin     = -1
  bit_image_type            bitype     = -1
  magic_cookie_glitch_ul    OTug       = -1
  carriage_return_delay     OTdC       = -1
  new_line_delay            OTdN       = -1
  backspace_delay           OTdB       = -1
  horizontal_tab_delay      OTdT       = -1
  number_of_function_keys   OTkn       = -1
String capabilities:
  back_tab                  cbt        = ^[[Z
  bell                      bel        = ^G
  carriage_return           cr         = ^M
  change_scroll_region      csr        = ^[[%i%p1%d;%p2%dr
  clear_all_tabs            tbc        = ^[[3g
  clear_screen              clear      = ^[[H^[[2J
  clr_eol                   el         = ^[[K
  clr_eos                   ed         = ^[[J
  column_address            hpa        = ^[[%i%p1%dG
  cursor_address            cup        = ^[[%i%p1%d;%p2%dH
  cursor_down               cud1       = ^@
  cursor_home               home       = ^[[H
  cursor_invisible          civis      = ^[[?25l
  cursor_left               cub1       = ^H
  cursor_normal             cnorm      = ^[[?25h
  cursor_right              cuf1       = ^[[C
  cursor_up                 cuu1       = ^[[A
  cursor_visible            cvvis      = ^[[?12;25h
  delete_character          dch1       = ^[[P
  delete_line               dl1        = ^[[M
  enter_alt_charset_mode    smacs      = ^[(0
  enter_blink_mode          blink      = ^[[5m
  enter_bold_mode           bold       = ^[[1m
  enter_ca_mode             smcup      = ^[[?1049h
  enter_dim_mode            dim        = ^[[2m
  enter_insert_mode         smir       = ^[[4h
  enter_secure_mode         invis      = ^[[8m
  enter_reverse_mode        rev        = ^[[7m
  enter_standout_mode       smso       = ^[[7m
  enter_underline_mode      smul       = ^[[4m
  erase_chars               ech        = ^[[%p1%dX
  exit_alt_charset_mode     rmacs      = ^[(B
  exit_attribute_mode       sgr0       = ^[(B^[[m
  exit_ca_mode              rmcup      = ^[[?1049l
  exit_insert_mode          rmir       = ^[[4l
  exit_standout_mode        rmso       = ^[[27m
  exit_underline_mode       rmul       = ^[[24m
  flash_screen              flash      = ^[[?5h$<100/>^[[?5l
  from_status_line          fsl        = ^G
  init_2string              is2        = ^[[!p^[[?3;4l^[[4l^[>
  insert_line               il1        = ^[[L
  key_backspace             kbs        = ^H
  key_dc                    kdch1      = ^[[3~
  key_down                  kcud1      = ^[OB
  key_f1                    kf1        = ^[OP
  key_f10                   kf10       = ^[[21~
  key_f2                    kf2        = ^[OQ
  key_f3                    kf3        = ^[OR
  key_f4                    kf4        = ^[OS
  key_f5                    kf5        = ^[[15~
  key_f6                    kf6        = ^[[17~
  key_f7                    kf7        = ^[[18~
  key_f8                    kf8        = ^[[19~
  key_f9                    kf9        = ^[[20~
  key_home                  khome      = ^[OH
  key_ic                    kich1      = ^[[2~
  key_left                  kcub1      = ^[OD
  key_npage                 knp        = ^[[6~
  key_ppage                 kpp        = ^[[5~
  key_right                 kcuf1      = ^[OC
  key_sf                    kind       = ^[[1;2B
  key_sr                    kri        = ^[[1;2A
  key_up                    kcuu1      = ^[OA
  keypad_local              rmkx       = ^[[?1l^[>
  keypad_xmit               smkx       = ^[[?1h^[=
  meta_off                  rmm        = ^[[?1034l
  meta_on                   smm        = ^[[?1034h
  parm_dch                  dch        = ^[[%p1%dP
  parm_delete_line          dl         = ^[[%p1%dM
  parm_down_cursor          cud        = ^[[%p1%dB
  parm_ich                  ich        = ^[[%p1%d@
  parm_index                indn       = ^[[%p1%dS
  parm_insert_line          il         = ^[[%p1%dL
  parm_left_cursor          cub        = ^[[%p1%dD
  parm_right_cursor         cuf        = ^[[%p1%dC
  parm_rindex               rin        = ^[[%p1%dT
  parm_up_cursor            cuu        = ^[[%p1%dA
  print_screen              mc0        = ^[[i
  prtr_off                  mc4        = ^[[4i
  prtr_on                   mc5        = ^[[5i
  reset_1string             rs1        = ^[c
  reset_2string             rs2        = ^[[!p^[[?3;4l^[[4l^[>
  restore_cursor            rc         = ^[8
  row_address               vpa        = ^[[%i%p1%dd
  save_cursor               sc         = ^[7
  scroll_forward            ind        = ^@
  scroll_reverse            ri         = ^[M
  set_attributes            sgr        = %?%p9%t^[(0%e^[(B%;^[[0%?%p6%t;1%;%?%p5%t;2%;%?%p2%t;4%;%?%p1%p3%|%t;7%;%?%p4%t;5%;%?%p7%t;8%;m
  set_tab                   hts        = ^[H
  tab                       ht         = 	
  to_status_line            tsl        = ^[]0;
  key_b2                    kb2        = ^[OE
  acs_chars                 acsc       = ``aaffggiijjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~
  key_btab                  kcbt       = ^[[Z
  enter_am_mode             smam       = ^[[?7h
  exit_am_mode              rmam       = ^[[?7l
  key_end                   kend       = ^[OF
  key_enter                 kent       = ^[OM
  key_sdc                   kDC        = ^[[3;2~
  key_send                  kEND       = ^[[1;2F
  key_shome                 kHOM       = ^[[1;2H
  key_sic                   kIC        = ^[[2;2~
  key_sleft                 kLFT       = ^[[1;2D
  key_snext                 kNXT       = ^[[6;2~
  key_sprevious             kPRV       = ^[[5;2~
  key_sright                kRIT       = ^[[1;2C
  key_f11                   kf11       = ^[[23~
  key_f12                   kf12       = ^[[24~
  key_f13                   kf13       = ^[[1;2P
  key_f14                   kf14       = ^[[1;2Q
  key_f15                   kf15       = ^[[1;2R
  key_f16                   kf16       = ^[[1;2S
  key_f17                   kf17       = ^[[15;2~
  key_f18                   kf18       = ^[[17;2~
  key_f19                   kf19       = ^[[18;2~
  key_f20                   kf20       = ^[[19;2~
  key_f21                   kf21       = ^[[20;2~
  key_f22                   kf22       = ^[[21;2~
  key_f23                   kf23       = ^[[23;2~
  key_f24                   kf24       = ^[[24;2~
  key_f25                   kf25       = ^[[1;5P
  key_f26                   kf26       = ^[[1;5Q
  key_f27                   kf27       = ^[[1;5R
  key_f28                   kf28       = ^[[1;5S
  key_f29                   kf29       = ^[[15;5~
  key_f30                   kf30       = ^[[17;5~
  key_f31                   kf31       = ^[[18;5~
  key_f32                   kf32       = ^[[19;5~
  key_f33                   kf33       = ^[[20;5~
  key_f34                   kf34       = ^[[21;5~
  key_f35                   kf35       = ^[[23;5~
  key_f36                   kf36       = ^[[24;5~
  key_f37                   kf37       = ^[[1;6P
  key_f38                   kf38       = ^[[1;6Q
  key_f39                   kf39       = ^[[1;6R
  key_f40                   kf40       = ^[[1;6S
  key_f41                   kf41       = ^[[15;6~
  key_f42                   kf42       = ^[[17;6~
  key_f43                   kf43       = ^[[18;6~
  key_f44                   kf44       = ^[[19;6~
  key_f45                   kf45       = ^[[20;6~
  key_f46                   kf46       = ^[[21;6~
  key_f47                   kf47       = ^[[23;6~
  key_f48                   kf48       = ^[[24;6~
  key_f49                   kf49       = ^[[1;3P
  key_f50                   kf50       = ^[[1;3Q
  key_f51                   kf51       = ^[[1;3R
  key_f52                   kf52       = ^[[1;3S
  key_f53                   kf53       = ^[[15;3~
  key_f54                   kf54       = ^[[17;3~
  key_f55                   kf55       = ^[[18;3~
  key_f56                   kf56       = ^[[19;3~
  key_f57                   kf57       = ^[[20;3~
  key_f58                   kf58       = ^[[21;3~
  key_f59                   kf59       = ^[[23;3~
  key_f60                   kf60       = ^[[24;3~
  key_f61                   kf61       = ^[[1;4P
  key_f62                   kf62       = ^[[1;4Q
  key_f63                   kf63       = ^[[1;4R
  clr_bol                   el1        = ^[[1K
  user6                     u6         = ^[[%i%d;%dR
  user7                     u7         = ^[[6n
  user8                     u8         = ^[[?1;2c
  user9                     u9         = ^[[c
  orig_pair                 op         = ^[[39;49m
  initialize_color          initc      = ^[]4;%p1%d;rgb:%p2%{255}%*%{1000}%/%2.2X/%p3%{255}%*%{1000}%/%2.2X/%p4%{255}%*%{1000}%/%2.2X^[\
  enter_italics_mode        sitm       = ^[[3m
  exit_italics_mode         ritm       = ^[[23m
  key_mouse                 kmous      = ^[[M
  set_a_foreground          setaf      = ^[[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m
  set_a_background          setab      = ^[[%?%p1%{8}%<%t4%p1%d%e%p1%{16}%<%t10%p1%{8}%-%d%e48;5;%p1%d%;m
  set_tb_margin             smgtb      = ^[[%i%p1%d;%p2%dr
  memory_lock               meml       = ^[l
  memory_unlock             memu       = ^[m
Extended boolean capabilities:
  AX                        = true
  G0                        = false
  XT                        = true
Extended numeric capabilities:
  U8                        = -1
Extended string capabilities:
  Cr                        = ^[]112^G
  Cs                        = ^[]12;%p1%s^G
  E0                        = 
  E3                        = ^[[3J
  Ms                        = ^[]52;%p1%s;%p2%s^G
  S0                        = 
  Se                        = ^[[2 q
  Ss                        = ^[[%p1%d q
  kDC3                      = ^[[3;3~
  kDC4                      = ^[[3;4~
  kDC5                      = ^[[3;5~
  kDC6                      = ^[[3;6~
  kDC7                      = ^[[3;7~
  kDN                       = ^[[1;2B
  kDN3                      = ^[[1;3B
  kDN4                      = ^[[1;4B
  kDN5                      = ^[[1;5B
  kDN6                      = ^[[1;6B
  kDN7                      = ^[[1;7B
  kEND3                     = ^[[1;3F
  kEND4                     = ^[[1;4F
  kEND5                     = ^[[1;5F
  kEND6                     = ^[[1;6F
  kEND7                     = ^[[1;7F
  kHOM3                     = ^[[1;3H
  kHOM4                     = ^[[1;4H
  kHOM5                     = ^[[1;5H
  kHOM6                     = ^[[1;6H
  kHOM7                     = ^[[1;7H
  kIC3                      = ^[[2;3~
  kIC4                      = ^[[2;4~
  kIC5                      = ^[[2;5~
  kIC6                      = ^[[2;6~
  kIC7                      = ^[[2;7~
  kLFT3                     = ^[[1;3D
  kLFT4                     = ^[[1;4D
  kLFT5                     = ^[[1;5D
  kLFT6                     = ^[[1;6D
  kLFT7                     = ^[[1;7D
  kNXT3                     = ^[[6;3~
  kNXT4                     = ^[[6;4~
  kNXT5                     = ^[[6;5~
  kNXT6                     = ^[[6;6~
  kNXT7                     = ^[[6;7~
  kPRV3                     = ^[[5;3~
  kPRV4                     = ^[[5;4~
  kPRV5                     = ^[[5;5~
  kPRV6                     = ^[[5;6~
  kPRV7                     = ^[[5;7~
  kRIT3                     = ^[[1;3C
  kRIT4                     = ^[[1;4C
  kRIT5                     = ^[[1;5C
  kRIT6                     = ^[[1;6C
  kRIT7                     = ^[[1;7C
  kUP                       = ^[[1;2A
  kUP3                      = ^[[1;3A
  kUP4                      = ^[[1;4A
  kUP5                      = ^[[1;5A
  kUP6                      = ^[[1;6A
  kUP7                      = ^[[1;7A
  ka2                       = 
  kb1                       = 
  kb3                       = 
  kc2                       = 
  ext.resize_screen         = ^[[8;%p1%d;%p2%dt
  ext.reset_scroll_region   = ^[[r
  ext.enter_altfont_mode    = ^[[11m
  setrgbf                   = ^[[38;2;%p1%d;%p2%d;%p3%dm
  setrgbb                   = ^[[48;2;%p1%d;%p2%d;%p3%dm
  ext.save_title            = ^[[22;0t
  ext.restore_title         = ^[[23;0t
  ext.enable_lr_margin      = ^[[?69h
  ext.disable_lr_margin     = ^[[?69l
  ext.enable_bpaste         = ^[[?2004h
  ext.disable_bpaste        = ^[[?2004l
  ext.enable_focus          = ^[[?1004h
  ext.disable_focus         = ^[[?1004l
  ext.enable_mouse          = ^[[?1002h^[[?1006h
  ext.disable_mouse         = ^[[?1002l^[[?1006l
  ext.enable_mouse_move     = ^[[?1003h
  ext.disable_mouse_move    = ^[[?1003l
  ext.set_underline_style   = ^[[4:%p1%dm
  ext.set_underline_color   = ^[[58:2::%p1%d:%p2%d:%p3%dm
  Sync                      = ^[[?2026%?%p1%{1}%-%tl%eh%;
}}}

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "<buffer=1>"
autocommand <Lua 245: ~/.local/share/nvim/lazy/alpha-nvim/lua/alpha.lua:525>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "<buffer=1>"
autocommand <Lua 245: ~/.local/share/nvim/lazy/alpha-nvim/lua/alpha.lua:525>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "<buffer=1>"
autocommand <Lua 245: ~/.local/share/nvim/lazy/alpha-nvim/lua/alpha.lua:525>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "<buffer=1>"
autocommand <Lua 245: ~/.local/share/nvim/lazy/alpha-nvim/lua/alpha.lua:525>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "<buffer=1>"
autocommand <Lua 245: ~/.local/share/nvim/lazy/alpha-nvim/lua/alpha.lua:525>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "<buffer=1>"
autocommand <Lua 245: ~/.local/share/nvim/lazy/alpha-nvim/lua/alpha.lua:525>

Executing: 
Executing: augroup filetypedetect
Executing: augroup END
Executing: silent! autocmd! FileExplorer *
Executing: autocmd VimEnter * ++once silent! autocmd! FileExplorer *
Executing: hi def NvimTreeFolderIcon guifg=#8094b4 ctermfg=Blue
Executing: hi def NvimTreeWindowPicker guifg=#ededed guibg=#4493c8 gui=bold ctermfg=White ctermbg=DarkBlue
Executing: hi link NvimTreeGitNewIcon NvimTreeGitNew
Executing: hi link NvimTreeGitDirtyIcon NvimTreeGitDirty
Executing: hi link NvimTreeGitDeletedIcon NvimTreeGitDeleted
Executing: hi link NvimTreeOpenedHL NvimTreeOpenedFile
Executing: hi def link NvimTreeNormal Normal
Executing: hi def link NvimTreeNormalFloat NormalFloat
Executing: hi def link NvimTreeNormalFloatBorder FloatBorder
Executing: hi def link NvimTreeNormalNC NvimTreeNormal
Executing: hi def link NvimTreeLineNr LineNr
Executing: hi def link NvimTreeWinSeparator WinSeparator
Executing: hi def link NvimTreeEndOfBuffer EndOfBuffer
Executing: hi def link NvimTreePopup Normal
Executing: hi def link NvimTreeSignColumn NvimTreeNormal
Executing: hi def link NvimTreeCursorColumn CursorColumn
Executing: hi def link NvimTreeCursorLine CursorLine
Executing: hi def link NvimTreeCursorLineNr CursorLineNr
Executing: hi def link NvimTreeStatusLine StatusLine
Executing: hi def link NvimTreeStatusLineNC StatusLineNC
Executing: hi def link NvimTreeExecFile Question
Executing: hi def link NvimTreeImageFile Question
Executing: hi def link NvimTreeSpecialFile Title
Executing: hi def link NvimTreeSymlink Underlined
Executing: hi def link NvimTreeRootFolder Title
Executing: hi def link NvimTreeFolderName Directory
Executing: hi def link NvimTreeEmptyFolderName Directory
Executing: hi def link NvimTreeOpenedFolderName Directory
Executing: hi def link NvimTreeSymlinkFolderName Directory
Executing: hi def link NvimTreeFileIcon NvimTreeNormal
Executing: hi def link NvimTreeSymlinkIcon NvimTreeNormal
Executing: hi def link NvimTreeOpenedFolderIcon NvimTreeFolderIcon
Executing: hi def link NvimTreeClosedFolderIcon NvimTreeFolderIcon
Executing: hi def link NvimTreeFolderArrowClosed NvimTreeIndentMarker
Executing: hi def link NvimTreeFolderArrowOpen NvimTreeIndentMarker
Executing: hi def link NvimTreeIndentMarker NvimTreeFolderIcon
Executing: hi def link NvimTreeLiveFilterPrefix PreProc
Executing: hi def link NvimTreeLiveFilterValue ModeMsg
Executing: hi def link NvimTreeCutHL SpellBad
Executing: hi def link NvimTreeCopiedHL SpellRare
Executing: hi def link NvimTreeBookmarkIcon NvimTreeFolderIcon
Executing: hi def link NvimTreeBookmarkHL SpellLocal
Executing: hi def link NvimTreeModifiedIcon Type
Executing: hi def link NvimTreeModifiedFileHL NvimTreeModifiedIcon
Executing: hi def link NvimTreeModifiedFolderHL NvimTreeModifiedFileHL
Executing: hi def link NvimTreeHiddenIcon Conceal
Executing: hi def link NvimTreeHiddenFileHL NvimTreeHiddenIcon
Executing: hi def link NvimTreeHiddenFolderHL NvimTreeHiddenFileHL
Executing: hi def link NvimTreeHiddenDisplay Conceal
Executing: hi def link NvimTreeOpenedHL Special
Executing: hi def link NvimTreeGitDeletedIcon Statement
Executing: hi def link NvimTreeGitDirtyIcon Statement
Executing: hi def link NvimTreeGitIgnoredIcon Comment
Executing: hi def link NvimTreeGitMergeIcon Constant
Executing: hi def link NvimTreeGitNewIcon PreProc
Executing: hi def link NvimTreeGitRenamedIcon PreProc
Executing: hi def link NvimTreeGitStagedIcon Constant
Executing: hi def link NvimTreeGitFileDeletedHL NvimTreeGitDeletedIcon
Executing: hi def link NvimTreeGitFileDirtyHL NvimTreeGitDirtyIcon
Executing: hi def link NvimTreeGitFileIgnoredHL NvimTreeGitIgnoredIcon
Executing: hi def link NvimTreeGitFileMergeHL NvimTreeGitMergeIcon
Executing: hi def link NvimTreeGitFileNewHL NvimTreeGitNewIcon
Executing: hi def link NvimTreeGitFileRenamedHL NvimTreeGitRenamedIcon
Executing: hi def link NvimTreeGitFileStagedHL NvimTreeGitStagedIcon
Executing: hi def link NvimTreeGitFolderDeletedHL NvimTreeGitFileDeletedHL
Executing: hi def link NvimTreeGitFolderDirtyHL NvimTreeGitFileDirtyHL
Executing: hi def link NvimTreeGitFolderIgnoredHL NvimTreeGitFileIgnoredHL
Executing: hi def link NvimTreeGitFolderMergeHL NvimTreeGitFileMergeHL
Executing: hi def link NvimTreeGitFolderNewHL NvimTreeGitFileNewHL
Executing: hi def link NvimTreeGitFolderRenamedHL NvimTreeGitFileRenamedHL
Executing: hi def link NvimTreeGitFolderStagedHL NvimTreeGitFileStagedHL
Executing: hi def link NvimTreeDiagnosticErrorIcon DiagnosticError
Executing: hi def link NvimTreeDiagnosticWarnIcon DiagnosticWarn
Executing: hi def link NvimTreeDiagnosticInfoIcon DiagnosticInfo
Executing: hi def link NvimTreeDiagnosticHintIcon DiagnosticHint
Executing: hi def link NvimTreeDiagnosticErrorFileHL DiagnosticUnderlineError
Executing: hi def link NvimTreeDiagnosticWarnFileHL DiagnosticUnderlineWarn
Executing: hi def link NvimTreeDiagnosticInfoFileHL DiagnosticUnderlineInfo
Executing: hi def link NvimTreeDiagnosticHintFileHL DiagnosticUnderlineHint
Executing: hi def link NvimTreeDiagnosticErrorFolderHL NvimTreeDiagnosticErrorFileHL
Executing: hi def link NvimTreeDiagnosticWarnFolderHL NvimTreeDiagnosticWarnFileHL
Executing: hi def link NvimTreeDiagnosticInfoFolderHL NvimTreeDiagnosticInfoFileHL
Executing: hi def link NvimTreeDiagnosticHintFolderHL NvimTreeDiagnosticHintFileHL

Executing: NvimTreeToggle
Executing command: "'/usr/bin/git' '-C' '/Users/jkulrativid/.config/nvim' 'rev-parse' '--show-toplevel' '--absolute-git-dir'"


Executing command: "'/usr/bin/git' '-C' '/Users/jkulrativid/.config' 'config' 'status.showUntrackedFiles'"


Executing BufNew Autocommands for "*"
autocommand <Lua 219: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:135>

Executing: 
Executing BufFilePost Autocommands for "*"
autocommand <Lua 223: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/editorconfig.lua:4>

Executing: 
Executing FileType Autocommands for "*"
autocommand call s:LoadFTPlugin()

Executing: call s:LoadFTPlugin()
calling <SNR>2_LoadFTPlugin()

line 1:     if exists("b:undo_ftplugin")
line 2:       exe b:undo_ftplugin
line 3:       unlet! b:undo_ftplugin b:did_ftplugin
line 4:     endif
line 5: 
line 6:     let s = expand("<amatch>")
line 7:     if s != ""
line 8:       if &cpo =~# "S" && exists("b:did_ftplugin")
line 9: ^I" In compatible mode options are reset to the global values, need to
line 10: ^I" set the local values also when a plugin was already used.
line 11: ^Iunlet b:did_ftplugin
line 12:       endif
line 13: 
line 14:       " When there is a dot it is used to separate filetype names.  Thus for
line 15:       " "aaa.bbb" load "aaa" and then "bbb".
line 16:       for name in split(s, '\.')
line 17:         " Load Lua ftplugins after Vim ftplugins _per directory_
line 18:         " TODO(clason): use nvim__get_runtime when supports globs and modeline
line 19:         " XXX: "[.]" in the first pattern makes it a wildcard on Windows
line 20:         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
line 20: runtime! ftplugin/NvimTree[.]{vim,lua} ftplugin/NvimTree_*.{vim,lua} ftplugin/NvimTree/*.{vim,lua}
Searching for "ftplugin/NvimTree[.]{vim,lua} ftplugin/NvimTree_*.{vim,lua} ftplugin/NvimTree/*.{vim,lua}" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.config/nvim/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.config/nvim/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/ftplugin/NvimTree/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/ftplugin/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/ftplugin/NvimTree_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/ftplugin/NvimTree/*.{vim,lua}"
not found in runtime path: "ftplugin/NvimTree[.]{vim,lua} ftplugin/NvimTree_*.{vim,lua} ftplugin/NvimTree/*.{vim,lua}"
line 21:       endfor
line 16:       for name in split(s, '\.')
line 17:         " Load Lua ftplugins after Vim ftplugins _per directory_
line 18:         " TODO(clason): use nvim__get_runtime when supports globs and modeline
line 19:         " XXX: "[.]" in the first pattern makes it a wildcard on Windows
line 20:         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
line 21:       endfor
line 22:     endif
<SNR>2_LoadFTPlugin returning #0

continuing in FileType Autocommands for "*"

Executing FileType Autocommands for "*"
autocommand call s:LoadIndent()

Executing: call s:LoadIndent()
calling <SNR>3_LoadIndent()

line 1:     if exists("b:undo_indent")
line 2:       exe b:undo_indent
line 3:       unlet! b:undo_indent b:did_indent
line 4:     endif
line 5:     let s = expand("<amatch>")
line 6:     if s != ""
line 7:       if exists("b:did_indent")
line 8: ^Iunlet b:did_indent
line 9:       endif
line 10: 
line 11:       " When there is a dot it is used to separate filetype names.  Thus for
line 12:       " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
line 13:       for name in split(s, '\.')
line 14:         " XXX: "[.]" in the pattern makes it a wildcard on Windows
line 15:         exe $'runtime! indent/{name}[.]{{vim,lua}}'
line 15: runtime! indent/NvimTree[.]{vim,lua}
Searching for "indent/NvimTree[.]{vim,lua}" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/indent/NvimTree[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/indent/NvimTree[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/indent/NvimTree[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/indent/NvimTree[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/indent/NvimTree[.]{vim,lua}"
not found in runtime path: "indent/NvimTree[.]{vim,lua}"
line 16:       endfor
line 13:       for name in split(s, '\.')
line 14:         " XXX: "[.]" in the pattern makes it a wildcard on Windows
line 15:         exe $'runtime! indent/{name}[.]{{vim,lua}}'
line 16:       endfor
line 17:     endif
<SNR>3_LoadIndent returning #0

continuing in FileType Autocommands for "*"

Executing FileType Autocommands for "*"
autocommand if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif

Executing: if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  endif
Executing FileType Autocommands for "*"
autocommand if index(g:mkdp_filetypes, &filetype) !=# -1 | call s:init_command() | endif

Executing: if index(g:mkdp_filetypes, &filetype) !=# -1 | call s:init_command() | endif
Executing:  call s:init_command() | endif
Executing:  endif
Executing WinLeave Autocommands for "*"
autocommand call s:Remove_Matches()

Executing: call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in WinLeave Autocommands for "*"

Executing WinEnter Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinEnter Autocommands for "*"

Executing: buffer 2
Executing BufLeave Autocommands for "*"
autocommand call s:Remove_Matches()

Executing: call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in BufLeave Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand <Lua 122: ~/.local/share/nvim/lazy/bufferline.nvim/lua/bufferline.lua:141>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand lua require'lualine.components.branch.git_branch'.find_git_dir()

Executing: lua require'lualine.components.branch.git_branch'.find_git_dir()
autocommand lua require'lualine.components.diff.git_diff'.update_diff_args()

Executing: lua require'lualine.components.diff.git_diff'.update_diff_args()
Executing BufEnter Autocommands for "*"
autocommand if index(g:mkdp_filetypes, &filetype) !=# -1 | call s:init_command() | endif

Executing: if index(g:mkdp_filetypes, &filetype) !=# -1 | call s:init_command() | endif
Executing:  call s:init_command() | endif
Executing:  endif
Executing BufEnter Autocommands for "*"
autocommand <Lua 227: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:145>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 154: ~/.local/share/nvim/lazy/nvim-tree.lua/lua/nvim-tree.lua:101>

Executing: 
Executing BufEnter Autocommands for "NvimTree_*"
autocommand <Lua 543: ~/.local/share/nvim/lazy/nvim-tree.lua/lua/nvim-tree/explorer/init.lua:127>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand <Lua 160: ~/.local/share/nvim/lazy/nvim-dap-ui/lua/dapui/windows/init.lua:107>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand autocmd SafeState * ++once call s:Highlight_Matching_Pair()

Executing: autocmd SafeState * ++once call s:Highlight_Matching_Pair()
Executing: unlet! b:keymap_name
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing TextChanged Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in TextChanged Autocommands for "*"

Executing SafeState Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in SafeState Autocommands for "*"

Executing: unlet! b:keymap_name
Executing: unlet! b:keymap_name
Executing WinClosed Autocommands for "*"
autocommand <Lua 181: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:350>

Executing: 
Executing BufWinLeave Autocommands for "*"
autocommand <Lua 161: ~/.local/share/nvim/lazy/nvim-dap-ui/lua/dapui/windows/init.lua:107>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 146: ~/.local/share/nvim/lazy/dap-helper.nvim/lua/dap-helper/init.lua:79>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 544: ~/.local/share/nvim/lazy/nvim-tree.lua/lua/nvim-tree/explorer/init.lua:115>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 181: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:350>

Executing: 
Executing BufWinLeave Autocommands for "*"
autocommand <Lua 161: ~/.local/share/nvim/lazy/nvim-dap-ui/lua/dapui/windows/init.lua:107>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 146: ~/.local/share/nvim/lazy/dap-helper.nvim/lua/dap-helper/init.lua:79>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 544: ~/.local/share/nvim/lazy/nvim-tree.lua/lua/nvim-tree/explorer/init.lua:115>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing command: "'/usr/bin/git' '-C' '/Users/jkulrativid/.config/nvim/lua' 'rev-parse' '--show-toplevel' '--absolute-git-dir'"


Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing TextChanged Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in TextChanged Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing command: "'/usr/bin/git' '-C' '/Users/jkulrativid/.config/nvim/lua/jetnipit' 'rev-parse' '--show-toplevel' '--absolute-git-dir'"


Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing TextChanged Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in TextChanged Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing command: "'/usr/bin/git' '-C' '/Users/jkulrativid/.config/nvim/lua/jetnipit/plugins' 'rev-parse' '--show-toplevel' '--absolute-git-dir'"


Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing TextChanged Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in TextChanged Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing BufLeave Autocommands for "*"
autocommand call s:Remove_Matches()

Executing: call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in BufLeave Autocommands for "*"

Executing WinLeave Autocommands for "*"
autocommand call s:Remove_Matches()

Executing: call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in WinLeave Autocommands for "*"

Executing WinLeave Autocommands for "NvimTree_*"
autocommand <Lua 125: ~/.local/share/nvim/lazy/nvim-tree.lua/lua/nvim-tree.lua:232>

Executing: 
Executing WinEnter Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinEnter Autocommands for "*"

Executing BufNew Autocommands for "*"
autocommand <Lua 219: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:135>

Executing: 
Executing BufLeave Autocommands for "*"
autocommand call s:Remove_Matches()

Executing: call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in BufLeave Autocommands for "*"

Executing BufWinLeave Autocommands for "*"
autocommand <Lua 161: ~/.local/share/nvim/lazy/nvim-dap-ui/lua/dapui/windows/init.lua:107>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 146: ~/.local/share/nvim/lazy/dap-helper.nvim/lua/dap-helper/init.lua:79>

Executing: 
Executing BufUnload Autocommands for "<buffer=1>"
autocommand <Lua 242: ~/.local/share/nvim/lazy/alpha-nvim/lua/alpha.lua:664>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 544: ~/.local/share/nvim/lazy/nvim-tree.lua/lua/nvim-tree/explorer/init.lua:115>

Executing: 
Executing BufWipeout Autocommands for "<buffer=1>"
autocommand <Lua 155: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/diagnostic.lua:329>

Executing: 
auto-removing autocommand: BufWipeout <buffer=1>
Executing SwapExists Autocommands for "*"
autocommand <Lua 20: vim/_defaults.lua:0>

W325: Ignoring swapfile from Nvim process 7013
Executing: 
Executing BufReadPre Autocommands for "*"
autocommand <Lua 39: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/handler/event.lua:72>

Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/plugin/conform.lua
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/plugin/conform.lua"
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/plugin/conform.lua
continuing in nvim_exec2() called at BufReadPre Autocommands for "*":0
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/plugin/todo.vim
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/plugin/todo.vim"
line 1: command! -nargs=* TodoQuickFix lua require("todo-comments.search").setqflist(<q-args>)
line 2: command! -nargs=* TodoLocList lua require("todo-comments.search").setloclist(<q-args>)
line 3: command! -nargs=* TodoTelescope Telescope todo-comments todo <args>
line 4: command! -nargs=* TodoFzfLua lua require("todo-comments.fzf").todo() <args>
line 5: command! -nargs=* TodoTrouble Trouble todo <args>
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/plugin/todo.vim
continuing in nvim_exec2() called at BufReadPre Autocommands for "*":0
Executing: augroup filetypedetect
Executing: augroup END
Executing: hi def TodoBgWARN guibg=#eed49f guifg=#24273a gui=BOLD
Executing: hi def TodoFgWARN guibg=NONE guifg=#eed49f gui=NONE
Executing: hi def TodoSignWARN guibg=NONE guifg=#eed49f gui=NONE
Executing: hi def TodoBgHACK guibg=#eed49f guifg=#24273a gui=BOLD
Executing: hi def TodoFgHACK guibg=NONE guifg=#eed49f gui=NONE
Executing: hi def TodoSignHACK guibg=NONE guifg=#eed49f gui=NONE
Executing: hi def TodoBgTODO guibg=#91d7e3 guifg=#24273a gui=BOLD
Executing: hi def TodoFgTODO guibg=NONE guifg=#91d7e3 gui=NONE
Executing: hi def TodoSignTODO guibg=NONE guifg=#91d7e3 gui=NONE
Executing: hi def TodoBgTEST guibg=#f0c6c6 guifg=#24273a gui=BOLD
Executing: hi def TodoFgTEST guibg=NONE guifg=#f0c6c6 gui=NONE
Executing: hi def TodoSignTEST guibg=NONE guifg=#f0c6c6 gui=NONE
Executing: hi def TodoBgFIX guibg=#ed8796 guifg=#24273a gui=BOLD
Executing: hi def TodoFgFIX guibg=NONE guifg=#ed8796 gui=NONE
Executing: hi def TodoSignFIX guibg=NONE guifg=#ed8796 gui=NONE
Executing: hi def TodoBgNOTE guibg=#8bd5ca guifg=#24273a gui=BOLD
Executing: hi def TodoFgNOTE guibg=NONE guifg=#8bd5ca gui=NONE
Executing: hi def TodoSignNOTE guibg=NONE guifg=#8bd5ca gui=NONE
Executing: hi def TodoBgPERF guibg=#f0c6c6 guifg=#24273a gui=BOLD
Executing: hi def TodoFgPERF guibg=NONE guifg=#f0c6c6 gui=NONE
Executing: hi def TodoSignPERF guibg=NONE guifg=#f0c6c6 gui=NONE
Executing: augroup Todo
Executing:         autocmd!
Executing:         autocmd BufWinEnter,WinNew * lua require("todo-comments.highlight").attach()
Executing:         autocmd WinScrolled * lua require("todo-comments.highlight").highlight_win()
Executing:         autocmd ColorScheme * lua vim.defer_fn(require("todo-comments.config").colors, 10)
Executing:       augroup end
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/plugin/nvim-ts-autotag.lua
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/plugin/nvim-ts-autotag.lua"
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/plugin/nvim-ts-autotag.lua
continuing in nvim_exec2() called at BufReadPre Autocommands for "*":0
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/plugin/nvim-treesitter.lua
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/plugin/nvim-treesitter.lua"
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#installed_parsers TSUninstall lua require'nvim-treesitter.install'.commands.TSUninstall['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -bang -complete=custom,nvim_treesitter#installable_parsers TSInstallFromGrammar lua require'nvim-treesitter.install'.commands.TSInstallFromGrammar['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -bang -complete=custom,nvim_treesitter#installable_parsers TSInstall lua require'nvim-treesitter.install'.commands.TSInstall['run<bang>'](<f-args>)
Executing: command! -bar -nargs=* -complete=custom,nvim_treesitter#installed_parsers TSUpdateSync lua require'nvim-treesitter.install'.commands.TSUpdateSync['run<bang>'](<f-args>)
Executing: command! -bar -nargs=* -complete=custom,nvim_treesitter#installed_parsers TSUpdate lua require'nvim-treesitter.install'.commands.TSUpdate['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -bang -complete=custom,nvim_treesitter#installable_parsers TSInstallSync lua require'nvim-treesitter.install'.commands.TSInstallSync['run<bang>'](<f-args>)
Executing: command! -bar -nargs=0 TSInstallInfo lua require'nvim-treesitter.info'.commands.TSInstallInfo['run<bang>'](<f-args>)
Executing: command! -bar -nargs=? -complete=custom,nvim_treesitter#available_modules TSModuleInfo lua require'nvim-treesitter.info'.commands.TSModuleInfo['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_modules TSToggle lua require'nvim-treesitter.configs'.commands.TSToggle['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_modules TSDisable lua require'nvim-treesitter.configs'.commands.TSDisable['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_modules TSEnable lua require'nvim-treesitter.configs'.commands.TSEnable['run<bang>'](<f-args>)
Executing: command! -bar -nargs=1 -complete=custom,nvim_treesitter#available_modules TSBufToggle lua require'nvim-treesitter.configs'.commands.TSBufToggle['run<bang>'](<f-args>)
Executing: command! -bar -nargs=1 -complete=custom,nvim_treesitter#available_modules TSBufDisable lua require'nvim-treesitter.configs'.commands.TSBufDisable['run<bang>'](<f-args>)
Executing: command! -bar -nargs=1 -complete=custom,nvim_treesitter#available_modules TSBufEnable lua require'nvim-treesitter.configs'.commands.TSBufEnable['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_query_groups TSEditQueryUserAfter lua require'nvim-treesitter.configs'.commands.TSEditQueryUserAfter['run<bang>'](<f-args>)
Executing: command! -bar -nargs=+ -complete=custom,nvim_treesitter#available_query_groups TSEditQuery lua require'nvim-treesitter.configs'.commands.TSEditQuery['run<bang>'](<f-args>)
Executing: command! -bar -nargs=0 TSConfigInfo lua require'nvim-treesitter.configs'.commands.TSConfigInfo['run<bang>'](<f-args>)
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/plugin/nvim-treesitter.lua
continuing in nvim_exec2() called at BufReadPre Autocommands for "*":0
Executing: augroup filetypedetect
Executing: augroup END
Searching for "parser/json.so" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/json.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/json.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/json.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/json.so"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/json.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/json.so"
Searching for "parser/javascript.so" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/javascript.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/javascript.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/javascript.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/javascript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/javascript.so"
Searching for "parser/typescript.so" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/typescript.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/typescript.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/typescript.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/typescript.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/typescript.so"
Searching for "parser/tsx.so" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/tsx.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/tsx.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/tsx.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/tsx.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/tsx.so"
Searching for "parser/yaml.so" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/yaml.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/yaml.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/yaml.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/yaml.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/yaml.so"
Searching for "parser/html.so" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/html.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/html.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/html.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/html.so"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/html.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/html.so"
Searching for "parser/css.so" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/css.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/css.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/css.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/css.so"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/css.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/css.so"
Searching for "parser/prisma.so" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/prisma.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/prisma.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/prisma.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/prisma.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/prisma.so"
Searching for "parser/markdown.so" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/markdown.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/markdown.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/markdown.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/markdown.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/markdown.so"
Searching for "parser/markdown_inline.so" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/markdown_inline.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/markdown_inline.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/markdown_inline.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/markdown_inline.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/markdown_inline.so"
Searching for "parser/svelte.so" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/svelte.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/svelte.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/svelte.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/svelte.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/svelte.so"
Searching for "parser/graphql.so" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/graphql.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/graphql.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/graphql.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/graphql.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/graphql.so"
Searching for "parser/bash.so" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/bash.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/bash.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/bash.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/bash.so"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/bash.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/bash.so"
Searching for "parser/lua.so" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/lua.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/lua.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/lua.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/lua.so"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/lua.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/lua.so"
Searching for "parser/vim.so" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/vim.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/vim.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/vim.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/vim.so"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/vim.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/vim.so"
Searching for "parser/dockerfile.so" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/dockerfile.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/dockerfile.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/dockerfile.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/dockerfile.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/dockerfile.so"
Searching for "parser/gitignore.so" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/gitignore.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/gitignore.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/gitignore.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/gitignore.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/gitignore.so"
Searching for "parser/query.so" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/query.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/query.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/query.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/query.so"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/query.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/query.so"
Searching for "parser/vimdoc.so" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/vimdoc.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/vimdoc.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/vimdoc.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/vimdoc.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/vimdoc.so"
Searching for "parser/c.so" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/c.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/c.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/c.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/c.so"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/c.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/c.so"
Searching for "parser/go.so" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/go.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/go.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/go.so"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/go.so"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/go.so"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/go.so"
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/plugin/cmp_nvim_lsp.lua
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/plugin/cmp_nvim_lsp.lua"
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/plugin/cmp_nvim_lsp.lua
continuing in nvim_exec2() called at BufReadPre Autocommands for "*":0
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/plugin/lspconfig.lua
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/plugin/lspconfig.lua"
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/plugin/lspconfig.lua
continuing in nvim_exec2() called at BufReadPre Autocommands for "*":0
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/plugin/ts_context_commentstring.lua
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/plugin/ts_context_commentstring.lua"
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/plugin/ts_context_commentstring.lua
continuing in nvim_exec2() called at BufReadPre Autocommands for "*":0
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/plugin/Comment.lua
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/plugin/Comment.lua"
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/plugin/Comment.lua
continuing in nvim_exec2() called at BufReadPre Autocommands for "*":0
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/plugin/commands.lua
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/plugin/commands.lua"
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/plugin/commands.lua
continuing in nvim_exec2() called at BufReadPre Autocommands for "*":0
Executing: 
Reading ShaDa file "/Users/jkulrativid/.local/state/nvim/shada/main.shada" marks
Executing BufReadPost Autocommands for "*"
autocommand <Lua 93: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/filetype.lua:10>

Executing FileType Autocommands for "*"
autocommand call s:LoadFTPlugin()

Executing: call s:LoadFTPlugin()
calling <SNR>2_LoadFTPlugin()

line 1:     if exists("b:undo_ftplugin")
line 2:       exe b:undo_ftplugin
line 3:       unlet! b:undo_ftplugin b:did_ftplugin
line 4:     endif
line 5: 
line 6:     let s = expand("<amatch>")
line 7:     if s != ""
line 8:       if &cpo =~# "S" && exists("b:did_ftplugin")
line 9: ^I" In compatible mode options are reset to the global values, need to
line 10: ^I" set the local values also when a plugin was already used.
line 11: ^Iunlet b:did_ftplugin
line 12:       endif
line 13: 
line 14:       " When there is a dot it is used to separate filetype names.  Thus for
line 15:       " "aaa.bbb" load "aaa" and then "bbb".
line 16:       for name in split(s, '\.')
line 17:         " Load Lua ftplugins after Vim ftplugins _per directory_
line 18:         " TODO(clason): use nvim__get_runtime when supports globs and modeline
line 19:         " XXX: "[.]" in the first pattern makes it a wildcard on Windows
line 20:         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
line 20: runtime! ftplugin/lua[.]{vim,lua} ftplugin/lua_*.{vim,lua} ftplugin/lua/*.{vim,lua}
Searching for "ftplugin/lua[.]{vim,lua} ftplugin/lua_*.{vim,lua} ftplugin/lua/*.{vim,lua}" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.config/nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.config/nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/ftplugin/lua/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/lua[.]{vim,lua}"
line 20: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/lua.vim"
line 1: " Vim filetype plugin file.
line 2: " Language:^I^ILua
line 3: " Maintainer:^I^IDoug Kearns <dougkearns@gmail.com>
line 4: " Previous Maintainer:^IMax Ischenko <mfi@ukr.net>
line 5: " Contributor:^I^IDorai Sitaram <ds26@gte.com>
line 6: "^I^I^IC.D. MacEachern <craig.daniel.maceachern@gmail.com>
line 7: "^I^I^ITyler Miller <tmillr@proton.me>
line 8: " Last Change:^I^I2024 Jan 14
line 9: 
line 10: if exists("b:did_ftplugin")
line 11:   finish
line 12: endif
line 13: let b:did_ftplugin = 1
line 14: 
line 15: let s:cpo_save = &cpo
line 16: set cpo&vim
line 17: 
line 18: setlocal comments=:---,:--
line 19: setlocal commentstring=--\ %s
line 20: setlocal formatoptions-=t formatoptions+=croql
line 21: 
line 22: let &l:define = '\<function\|\<local\%(\s\+function\)\='
line 23: 
line 24: " TODO: handle init.lua
line 25: setlocal includeexpr=tr(v:fname,'.','/')
line 26: setlocal suffixesadd=.lua
line 27: 
line 28: let b:undo_ftplugin = "setlocal cms< com< def< fo< inex< sua<"
line 29: 
line 30: if exists("loaded_matchit") && !exists("b:match_words")
line 31:   let b:match_ignorecase = 0
line 32:   let b:match_words = '\<\%(do\|function\|if\)\>:' .. '\<\%(return\|else\|elseif\)\>:' .. '\<end\>,' .. '\<repeat\>:\<until\>,' .. '\%(--\)\=\[\(=*\)\[:]\1]'
line 38:   let b:undo_ftplugin ..= " | unlet! b:match_words b:match_ignorecase"
line 39: endif
line 40: 
line 41: if (has("gui_win32") || has("gui_gtk")) && !exists("b:browsefilter")
line 42:   let b:browsefilter = "Lua Source Files (*.lua)\t*.lua\n"
line 43:   if has("win32")
line 44:     let b:browsefilter ..= "All Files (*.*)\t*\n"
line 45:   else
line 46:     let b:browsefilter ..= "All Files (*)\t*\n"
line 47:   endif
line 48:   let b:undo_ftplugin ..= " | unlet! b:browsefilter"
line 49: endif
line 50: 
line 51: let &cpo = s:cpo_save
line 52: unlet s:cpo_save
line 53: 
line 54: " vim: nowrap sw=2 sts=2 ts=8 noet:
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/lua.vim
continuing in <SNR>2_LoadFTPlugin
line 20: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/lua.lua"
Searching for "parser/lua.*" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/lua.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/lua.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/parser/lua.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/parser/lua.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/parser/lua.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/parser/lua.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/parser/lua.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/parser/lua.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/parser/lua.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/parser/lua.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/parser/lua.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/lua.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/lua.*"
Searching for "queries/lua/injections.scm" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/queries/lua/injections.scm"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/queries/lua/injections.scm"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/queries/lua/injections.scm"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/queries/lua/injections.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/queries/lua/injections.scm"
Executing Syntax Autocommands for "*"
autocommand call s:SynSet()

Executing: call s:SynSet()
calling <SNR>56_SynSet()

line 1:   " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
line 2:   syn clear
line 3:   if exists("b:current_syntax")
line 4:     unlet b:current_syntax
line 5:   endif
line 6: 
line 7:   0verbose let s = expand("<amatch>")
line 8:   if s == "ON"
line 9:     " :set syntax=ON
line 10:     if &filetype == ""
line 11:       echohl ErrorMsg
line 12:       echo "filetype unknown"
line 13:       echohl None
line 14:     endif
line 15:     let s = &filetype
line 16:   elseif s == "OFF"
line 17:     let s = ""
line 18:   endif
line 19: 
line 20:   if s != ""
line 21:     " Load the syntax file(s).  When there are several, separated by dots,
line 22:     " load each in sequence.  Skip empty entries.
line 23:     for name in split(s, '\.')
line 24:       if !empty(name)
line 25:         " XXX: "[.]" in the first pattern makes it a wildcard on Windows
line 26:         exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
line 27:       endif
line 28:     endfor
line 29:   endif
<SNR>56_SynSet returning #0

continuing in Syntax Autocommands for "*"

finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/lua.lua
continuing in <SNR>2_LoadFTPlugin
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/lua_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/lua/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/lua[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/lua_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/lua/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/ftplugin/lua[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/ftplugin/lua_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/ftplugin/lua/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/ftplugin/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/ftplugin/lua_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/ftplugin/lua/*.{vim,lua}"
line 21:       endfor
line 16:       for name in split(s, '\.')
line 17:         " Load Lua ftplugins after Vim ftplugins _per directory_
line 18:         " TODO(clason): use nvim__get_runtime when supports globs and modeline
line 19:         " XXX: "[.]" in the first pattern makes it a wildcard on Windows
line 20:         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
line 21:       endfor
line 22:     endif
<SNR>2_LoadFTPlugin returning #0

continuing in FileType Autocommands for "*"

Executing FileType Autocommands for "*"
autocommand call s:LoadIndent()

Executing: call s:LoadIndent()
calling <SNR>3_LoadIndent()

line 1:     if exists("b:undo_indent")
line 2:       exe b:undo_indent
line 3:       unlet! b:undo_indent b:did_indent
line 4:     endif
line 5:     let s = expand("<amatch>")
line 6:     if s != ""
line 7:       if exists("b:did_indent")
line 8: ^Iunlet b:did_indent
line 9:       endif
line 10: 
line 11:       " When there is a dot it is used to separate filetype names.  Thus for
line 12:       " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
line 13:       for name in split(s, '\.')
line 14:         " XXX: "[.]" in the pattern makes it a wildcard on Windows
line 15:         exe $'runtime! indent/{name}[.]{{vim,lua}}'
line 15: runtime! indent/lua[.]{vim,lua}
Searching for "indent/lua[.]{vim,lua}" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/indent/lua[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/indent/lua[.]{vim,lua}"
line 15: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/indent/lua.vim"
line 1: " Vim indent file
line 2: " Language:^ILua script
line 3: " Maintainer:^IMarcus Aurelius Farias <marcus.cf 'at' bol.com.br>
line 4: " First Author:^IMax Ischenko <mfi 'at' ukr.net>
line 5: " Last Change:^I2017 Jun 13
line 6: "^I^I2022 Sep 07: b:undo_indent added by Doug Kearns
line 7: 
line 8: " Only load this indent file when no other was loaded.
line 9: if exists("b:did_indent")
line 10:   finish
line 11: endif
line 12: let b:did_indent = 1
line 13: 
line 14: setlocal indentexpr=GetLuaIndent()
line 15: 
line 16: " To make Vim call GetLuaIndent() when it finds '\s*end' or '\s*until'
line 17: " on the current line ('else' is default and includes 'elseif').
line 18: setlocal indentkeys+=0=end,0=until
line 19: 
line 20: setlocal autoindent
line 21: 
line 22: let b:undo_indent = "setlocal autoindent< indentexpr< indentkeys<"
line 23: 
line 24: " Only define the function once.
line 25: if exists("*GetLuaIndent")
line 26:   finish
line 27: endif
line 28: 
line 29: function! GetLuaIndent()
line 38: 
line 39: function! GetLuaIndentIntern()
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/indent/lua.vim
continuing in <SNR>3_LoadIndent
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/indent/lua[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/indent/lua[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/indent/lua[.]{vim,lua}"
line 16:       endfor
line 13:       for name in split(s, '\.')
line 14:         " XXX: "[.]" in the pattern makes it a wildcard on Windows
line 15:         exe $'runtime! indent/{name}[.]{{vim,lua}}'
line 16:       endfor
line 17:     endif
<SNR>3_LoadIndent returning #0

continuing in FileType Autocommands for "*"

Executing FileType Autocommands for "*"
autocommand if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif

Executing: if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  endif
Executing FileType Autocommands for "*"
autocommand if index(g:mkdp_filetypes, &filetype) !=# -1 | call s:init_command() | endif

Executing: if index(g:mkdp_filetypes, &filetype) !=# -1 | call s:init_command() | endif
Executing:  call s:init_command() | endif
Executing:  endif
Executing FileType Autocommands for "*"
autocommand <Lua 298: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/configs.lua:132>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 297: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/configs.lua:132>

Searching for "queries/lua/indents.scm" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/queries/lua/indents.scm"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/queries/lua/indents.scm"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/queries/lua/indents.scm"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/queries/lua/indents.scm"
Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 296: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/configs.lua:132>

Searching for "queries/lua/highlights.scm" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/queries/lua/highlights.scm"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/queries/lua/highlights.scm"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/queries/lua/highlights.scm"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/queries/lua/highlights.scm"
Executing Syntax Autocommands for "*"
autocommand call s:SynSet()

Executing: call s:SynSet()
calling <SNR>56_SynSet()

line 1:   " clear syntax for :set syntax=OFF  and any syntax name that doesn't exist
line 2:   syn clear
line 3:   if exists("b:current_syntax")
line 4:     unlet b:current_syntax
line 5:   endif
line 6: 
line 7:   0verbose let s = expand("<amatch>")
line 8:   if s == "ON"
line 9:     " :set syntax=ON
line 10:     if &filetype == ""
line 11:       echohl ErrorMsg
line 12:       echo "filetype unknown"
line 13:       echohl None
line 14:     endif
line 15:     let s = &filetype
line 16:   elseif s == "OFF"
line 17:     let s = ""
line 18:   endif
line 19: 
line 20:   if s != ""
line 21:     " Load the syntax file(s).  When there are several, separated by dots,
line 22:     " load each in sequence.  Skip empty entries.
line 23:     for name in split(s, '\.')
line 24:       if !empty(name)
line 25:         " XXX: "[.]" in the first pattern makes it a wildcard on Windows
line 26:         exe $'runtime! syntax/{name}[.]{{vim,lua}} syntax/{name}/*.{{vim,lua}}'
line 27:       endif
line 28:     endfor
line 29:   endif
<SNR>56_SynSet returning #0

continuing in Syntax Autocommands for "*"

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 299: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/configs.lua:132>

Executing: 
Executing FileType Autocommands for "lua"
autocommand <Lua 499: ~/.local/share/nvim/lazy/nvim-lspconfig/lua/lspconfig/configs.lua:111>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 454: ~/.local/share/nvim/lazy/nvim-ts-context-commentstring/plugin/ts_context_commentstring.lua:11>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 288: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing: 
autocommand if !did_filetype() && expand('<amatch>') !~ g:ft_ignore_pat | runtime! scripts.vim | endif

Executing: if !did_filetype() && expand('<amatch>') !~ g:ft_ignore_pat | runtime! scripts.vim | endif
Executing:  runtime! scripts.vim | endif
Executing:  endif
Executing BufReadPost Autocommands for "*"
autocommand <Lua 121: ~/.local/share/nvim/lazy/bufferline.nvim/lua/bufferline.lua:136>

Executing: 
Executing BufReadPost Autocommands for "*"
autocommand <Lua 152: ~/.local/share/nvim/lazy/dap-helper.nvim/lua/dap-helper/init.lua:95>

Executing: 
Executing BufReadPost Autocommands for "*"
autocommand <Lua 222: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/plugin/editorconfig.lua:4>

Executing: 
Executing BufReadPost Autocommands for "*"
autocommand <Lua 218: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:135>

Executing: 
Executing BufReadPost Autocommands for "*"
autocommand <Lua 545: ~/.local/share/nvim/lazy/nvim-tree.lua/lua/nvim-tree/explorer/init.lua:103>

Executing: 
Executing BufReadPost Autocommands for "*"
autocommand <Lua 455: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns.lua:148>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 122: ~/.local/share/nvim/lazy/bufferline.nvim/lua/bufferline.lua:141>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand lua require'lualine.components.branch.git_branch'.find_git_dir()

Executing: lua require'lualine.components.branch.git_branch'.find_git_dir()
autocommand lua require'lualine.components.diff.git_diff'.update_diff_args()

Executing: lua require'lualine.components.diff.git_diff'.update_diff_args()
Executing BufEnter Autocommands for "*"
autocommand if index(g:mkdp_filetypes, &filetype) !=# -1 | call s:init_command() | endif

Executing: if index(g:mkdp_filetypes, &filetype) !=# -1 | call s:init_command() | endif
Executing:  call s:init_command() | endif
Executing:  endif
Executing BufEnter Autocommands for "*"
autocommand <Lua 227: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:145>

Executing: 
Executing BufEnter Autocommands for "*"
autocommand <Lua 154: ~/.local/share/nvim/lazy/nvim-tree.lua/lua/nvim-tree.lua:101>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand <Lua 160: ~/.local/share/nvim/lazy/nvim-dap-ui/lua/dapui/windows/init.lua:107>

Executing: 
Executing BufWinEnter Autocommands for "*"
autocommand autocmd SafeState * ++once call s:Highlight_Matching_Pair()

Executing: autocmd SafeState * ++once call s:Highlight_Matching_Pair()
Executing BufWinEnter Autocommands for "*"
autocommand lua require("todo-comments.highlight").attach()

Executing: lua require("todo-comments.highlight").attach()
Executing BufWinEnter Autocommands for "*"
autocommand <Lua 291: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing: unlet! b:keymap_name
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing SafeState Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in SafeState Autocommands for "*"

Searching for "queries/lua/highlights.scm" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/queries/lua/highlights.scm"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/queries/lua/highlights.scm"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/queries/lua/highlights.scm"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/queries/lua/highlights.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/queries/lua/highlights.scm"
Executing: highlight! lualine_x_filetype_DevIconLua_normal guifg=#51a0cf guibg=#112638 gui=None
Executing: highlight! lualine_x_filetype_DevIconLua_insert guifg=#51a0cf guibg=#112638 gui=None
Executing: highlight! lualine_x_filetype_DevIconLua_visual guifg=#51a0cf guibg=#112638 gui=None
Executing: highlight! lualine_x_filetype_DevIconLua_replace guifg=#51a0cf guibg=#112638 gui=None
Executing: highlight! lualine_x_filetype_DevIconLua_command guifg=#51a0cf guibg=#112638 gui=None
Executing: highlight! lualine_x_filetype_DevIconLua_terminal guifg=#51a0cf guibg=#112638 gui=None
Executing: highlight! lualine_x_filetype_DevIconLua_inactive guifg=#51a0cf guibg=#2c3043 gui=None
Executing command: "'/usr/bin/git' '-C' '/Users/jkulrativid/.config/nvim/lua/jetnipit/core' 'rev-parse' '--show-toplevel' '--absolute-git-dir'"


Executing LspAttach Autocommands for "*"
autocommand <Lua 190: ~/.local/share/nvim/lazy/copilot-lualine/lua/lualine/components/copilot.lua:79>

Executing: 
Executing LspAttach Autocommands for "*"
autocommand <Lua 215: ~/.local/share/nvim/lazy/copilot-cmp/lua/copilot_cmp/init.lua:55>

Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/after/plugin/cmp_buffer.lua
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/after/plugin/cmp_buffer.lua"
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/after/plugin/cmp_buffer.lua
continuing in nvim_exec2() called at LspAttach Autocommands for "*":0
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/cmp-path/after/plugin/cmp_path.lua
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/after/plugin/cmp_path.lua"
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/cmp-path/after/plugin/cmp_path.lua
continuing in nvim_exec2() called at LspAttach Autocommands for "*":0
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/plugin/copilot.lua
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/plugin/copilot.lua"
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/plugin/copilot.lua
continuing in nvim_exec2() called at LspAttach Autocommands for "*":0
Executing: augroup filetypedetect
Executing: augroup END
Executing: highlight default link CopilotSuggestion Comment
Executing: highlight default link CopilotAnnotation Comment
Searching for "copilot/index.js" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/copilot/index.js"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/copilot/index.js"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/copilot/index.js"
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/plugin/luasnip.lua
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/plugin/luasnip.lua"
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/plugin/luasnip.lua
continuing in nvim_exec2() called at LspAttach Autocommands for "*":0
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/plugin/luasnip.vim
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/plugin/luasnip.vim"
line 1: function! luasnip#expandable()
line 4: 
line 5: function! luasnip#expand_or_jumpable()
line 8: 
line 9: function! luasnip#expand_or_locally_jumpable()
line 12: 
line 13: function! luasnip#locally_jumpable(direction)
line 16: 
line 17: function! luasnip#jumpable(direction)
line 20: 
line 21: function! luasnip#choice_active()
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/plugin/luasnip.vim
continuing in nvim_exec2() called at LspAttach Autocommands for "*":0
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/after/plugin/cmp_luasnip.lua
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/after/plugin/cmp_luasnip.lua"
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/after/plugin/cmp_luasnip.lua
continuing in nvim_exec2() called at LspAttach Autocommands for "*":0
Executing: augroup filetypedetect
Executing: augroup END
Executing: augroup filetypedetect
Executing: augroup END
Executing: source /Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/plugin/cmp.lua
line 0: sourcing "/Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/plugin/cmp.lua"
Executing: doautocmd <nomodeline> User CmpReady
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/plugin/cmp.lua
continuing in nvim_exec2() called at LspAttach Autocommands for "*":0
Executing: augroup filetypedetect
Executing: augroup END
Searching for "package.json" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lspkind.nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/friendly-snippets/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/package.json"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/package.json"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/package.json"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/package.json"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/after/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/after/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/after/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/package.json"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/package.json"
Searching for "package.jsonc" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lspkind.nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/friendly-snippets/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/package.jsonc"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/package.jsonc"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/package.jsonc"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/package.jsonc"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/after/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/after/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/after/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/package.jsonc"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/package.jsonc"
not found in runtime path: "package.jsonc"
Executing: 
Executing LspAttach Autocommands for "*"
autocommand <Lua 216: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:126>

Executing: 
Executing LspAttach Autocommands for "*"
autocommand <Lua 415: ~/.config/nvim/lua/jetnipit/plugins/lspconfig.lua:92>

Executing: 
Executing User Autocommands for "LuasnipSnippetsAdded"
autocommand <Lua 612: ~/.local/share/nvim/lazy/cmp_luasnip/after/plugin/cmp_luasnip.lua:15>

Executing: 
Executing User Autocommands for "LuasnipSnippetsAdded"
autocommand <Lua 612: ~/.local/share/nvim/lazy/cmp_luasnip/after/plugin/cmp_luasnip.lua:15>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing LspAttach Autocommands for "*"
autocommand <Lua 190: ~/.local/share/nvim/lazy/copilot-lualine/lua/lualine/components/copilot.lua:79>

Executing: 
Executing LspAttach Autocommands for "*"
autocommand <Lua 215: ~/.local/share/nvim/lazy/copilot-cmp/lua/copilot_cmp/init.lua:55>

Executing: 
Executing LspAttach Autocommands for "*"
autocommand <Lua 216: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:126>

Executing: 
Executing LspAttach Autocommands for "*"
autocommand <Lua 415: ~/.config/nvim/lua/jetnipit/plugins/lspconfig.lua:92>

Executing: 
Executing LspAttach Autocommands for "*"
autocommand <Lua 723: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:280>

Executing: 
Executing: version

NVIM v0.10.2
Build type: Release
LuaJIT 2.1.1731601260

   system vimrc file: "$VIM/sysinit.vim"
  fall-back for $VIM: "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim"

Run :checkhealth for more info
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing: unlet! b:keymap_name
Executing: unlet! b:keymap_name
Executing WinClosed Autocommands for "*"
autocommand <Lua 181: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:350>

Executing: 
Executing BufWinLeave Autocommands for "*"
autocommand <Lua 161: ~/.local/share/nvim/lazy/nvim-dap-ui/lua/dapui/windows/init.lua:107>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 146: ~/.local/share/nvim/lazy/dap-helper.nvim/lua/dap-helper/init.lua:79>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 544: ~/.local/share/nvim/lazy/nvim-tree.lua/lua/nvim-tree/explorer/init.lua:115>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 622: ~/.local/share/nvim/lazy/LuaSnip/lua/luasnip/config.lua:109>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 181: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:350>

Executing: 
Executing BufWinLeave Autocommands for "*"
autocommand <Lua 161: ~/.local/share/nvim/lazy/nvim-dap-ui/lua/dapui/windows/init.lua:107>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 146: ~/.local/share/nvim/lazy/dap-helper.nvim/lua/dap-helper/init.lua:79>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 544: ~/.local/share/nvim/lazy/nvim-tree.lua/lua/nvim-tree/explorer/init.lua:115>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 622: ~/.local/share/nvim/lazy/LuaSnip/lua/luasnip/config.lua:109>

Executing: 
Executing: augroup filetypedetect
Executing: augroup END
Executing: unlet! b:keymap_name
Executing: unlet! b:keymap_name
Executing WinClosed Autocommands for "*"
autocommand <Lua 181: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:350>

Executing: 
Executing BufWinLeave Autocommands for "*"
autocommand <Lua 161: ~/.local/share/nvim/lazy/nvim-dap-ui/lua/dapui/windows/init.lua:107>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 146: ~/.local/share/nvim/lazy/dap-helper.nvim/lua/dap-helper/init.lua:79>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 544: ~/.local/share/nvim/lazy/nvim-tree.lua/lua/nvim-tree/explorer/init.lua:115>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 622: ~/.local/share/nvim/lazy/LuaSnip/lua/luasnip/config.lua:109>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 181: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:350>

Executing: 
Executing BufWinLeave Autocommands for "*"
autocommand <Lua 161: ~/.local/share/nvim/lazy/nvim-dap-ui/lua/dapui/windows/init.lua:107>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 146: ~/.local/share/nvim/lazy/dap-helper.nvim/lua/dap-helper/init.lua:79>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 544: ~/.local/share/nvim/lazy/nvim-tree.lua/lua/nvim-tree/explorer/init.lua:115>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 622: ~/.local/share/nvim/lazy/LuaSnip/lua/luasnip/config.lua:109>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
line 33:     endif
line 34:   endif
line 35: 
line 36:   " Figure out the arguments for searchpairpos().
line 37:   if i % 2 == 0
line 38:     let s_flags = 'nW'
line 39:     let c2 = plist[i + 1]
line 40:   else
line 41:     let s_flags = 'nbW'
line 42:     let c2 = c
line 43:     let c = plist[i - 1]
line 44:   endif
line 45:   if c == '['
line 46:     let c = '\['
line 47:     let c2 = '\]'
line 48:   endif
line 49: 
line 50:   " Find the match.  When it was just before the cursor move it there for a
line 51:   " moment.
line 52:   if before > 0
line 53:     let has_getcurpos = exists("*getcurpos")
line 54:     if has_getcurpos
line 55:       " getcurpos() is more efficient but doesn't exist before 7.4.313.
line 56:       let save_cursor = getcurpos()
line 57:     else
line 58:       let save_cursor = winsaveview()
line 59:     endif
line 60:     call cursor(c_lnum, c_col - before)
line 61:   endif
line 62: 
line 63:   if !has("syntax") || !exists("g:syntax_on")
line 64:     let s_skip = "0"
line 65:   else
line 66:     " Build an expression that detects whether the current cursor position is
line 67:     " in certain syntax types (string, comment, etc.), for use as
line 68:     " searchpairpos()'s skip argument.
line 69:     " We match "escape" for special items, such as lispEscapeSpecial, and
line 70:     " match "symbol" for lispBarSymbol.
line 71:     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
line 74:     " If executing the expression determines that the cursor is currently in
line 75:     " one of the syntax types, then we want searchpairpos() to find the pair
line 76:     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
line 77:     " outside of the syntax types and s_skip should keep its value so we skip
line 78:     " any matching pair inside the syntax types.
line 79:     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
line 80:     try
line 81:       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
line 81: if synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0 | let s_skip = "0" | endif
line 81:  let s_skip = "0" | endif
line 81:  endif
line 82:     catch /^Vim\%((\a\+)\)\=:E363/
line 83:       " We won't find anything, so skip searching, should keep Vim responsive.
line 84:       return
line 85:     endtry
line 86:   endif
line 87: 
line 88:   " Limit the search to lines visible in the window.
line 89:   let stoplinebottom = line('w$')
line 90:   let stoplinetop = line('w0')
line 91:   if i % 2 == 0
line 92:     let stopline = stoplinebottom
line 93:   else
line 94:     let stopline = stoplinetop
line 95:   endif
line 96: 
line 97:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 98:   " This fails when a timeout is not supported.
line 99:   if mode() == 'i' || mode() == 'R'
line 100:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 101:   else
line 102:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 103:   endif
line 104:   try
line 105:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 106:   catch /E118/
line 107:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 108:     " a long time on closed folds and long lines.
line 109:     " The "viewable" variables give a range in which we can scroll while
line 110:     " keeping the cursor at the same position.
line 111:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 112:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 113:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 114:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 115:     " one of these stoplines will be adjusted below, but the current values are
line 116:     " minimal boundaries within the current window
line 117:     if i % 2 == 0
line 118:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 119: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 120: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 121:       else
line 122: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 123:       endif
line 124:       let stoplinebottom = stopline
line 125:     else
line 126:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 127: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 128: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 129:       else
line 130: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 131:       endif
line 132:       let stoplinetop = stopline
line 133:     endif
line 134:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 135:   endtry
line 136: 
line 137:   if before > 0
line 138:     if has_getcurpos
line 139:       call setpos('.', save_cursor)
line 140:     else
line 141:       call winrestview(save_cursor)
line 142:     endif
line 143:   endif
line 144: 
line 145:   " If a match is found setup match highlighting.
line 146:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 147:     if s:has_matchaddpos
line 148:       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
line 149:     else
line 150:       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 152:       call add(w:matchparen_ids, 3)
line 153:     endif
line 154:     let w:paren_hl_on = 1
line 155:   endif
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
line 33:     endif
line 34:   endif
line 35: 
line 36:   " Figure out the arguments for searchpairpos().
line 37:   if i % 2 == 0
line 38:     let s_flags = 'nW'
line 39:     let c2 = plist[i + 1]
line 40:   else
line 41:     let s_flags = 'nbW'
line 42:     let c2 = c
line 43:     let c = plist[i - 1]
line 44:   endif
line 45:   if c == '['
line 46:     let c = '\['
line 47:     let c2 = '\]'
line 48:   endif
line 49: 
line 50:   " Find the match.  When it was just before the cursor move it there for a
line 51:   " moment.
line 52:   if before > 0
line 53:     let has_getcurpos = exists("*getcurpos")
line 54:     if has_getcurpos
line 55:       " getcurpos() is more efficient but doesn't exist before 7.4.313.
line 56:       let save_cursor = getcurpos()
line 57:     else
line 58:       let save_cursor = winsaveview()
line 59:     endif
line 60:     call cursor(c_lnum, c_col - before)
line 61:   endif
line 62: 
line 63:   if !has("syntax") || !exists("g:syntax_on")
line 64:     let s_skip = "0"
line 65:   else
line 66:     " Build an expression that detects whether the current cursor position is
line 67:     " in certain syntax types (string, comment, etc.), for use as
line 68:     " searchpairpos()'s skip argument.
line 69:     " We match "escape" for special items, such as lispEscapeSpecial, and
line 70:     " match "symbol" for lispBarSymbol.
line 71:     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
line 74:     " If executing the expression determines that the cursor is currently in
line 75:     " one of the syntax types, then we want searchpairpos() to find the pair
line 76:     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
line 77:     " outside of the syntax types and s_skip should keep its value so we skip
line 78:     " any matching pair inside the syntax types.
line 79:     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
line 80:     try
line 81:       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
line 81: if synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0 | let s_skip = "0" | endif
line 81:  let s_skip = "0" | endif
line 81:  endif
line 82:     catch /^Vim\%((\a\+)\)\=:E363/
line 83:       " We won't find anything, so skip searching, should keep Vim responsive.
line 84:       return
line 85:     endtry
line 86:   endif
line 87: 
line 88:   " Limit the search to lines visible in the window.
line 89:   let stoplinebottom = line('w$')
line 90:   let stoplinetop = line('w0')
line 91:   if i % 2 == 0
line 92:     let stopline = stoplinebottom
line 93:   else
line 94:     let stopline = stoplinetop
line 95:   endif
line 96: 
line 97:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 98:   " This fails when a timeout is not supported.
line 99:   if mode() == 'i' || mode() == 'R'
line 100:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 101:   else
line 102:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 103:   endif
line 104:   try
line 105:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 106:   catch /E118/
line 107:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 108:     " a long time on closed folds and long lines.
line 109:     " The "viewable" variables give a range in which we can scroll while
line 110:     " keeping the cursor at the same position.
line 111:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 112:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 113:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 114:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 115:     " one of these stoplines will be adjusted below, but the current values are
line 116:     " minimal boundaries within the current window
line 117:     if i % 2 == 0
line 118:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 119: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 120: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 121:       else
line 122: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 123:       endif
line 124:       let stoplinebottom = stopline
line 125:     else
line 126:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 127: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 128: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 129:       else
line 130: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 131:       endif
line 132:       let stoplinetop = stopline
line 133:     endif
line 134:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 135:   endtry
line 136: 
line 137:   if before > 0
line 138:     if has_getcurpos
line 139:       call setpos('.', save_cursor)
line 140:     else
line 141:       call winrestview(save_cursor)
line 142:     endif
line 143:   endif
line 144: 
line 145:   " If a match is found setup match highlighting.
line 146:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 147:     if s:has_matchaddpos
line 148:       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
line 149:     else
line 150:       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 152:       call add(w:matchparen_ids, 3)
line 153:     endif
line 154:     let w:paren_hl_on = 1
line 155:   endif
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
line 33:     endif
line 34:   endif
line 35: 
line 36:   " Figure out the arguments for searchpairpos().
line 37:   if i % 2 == 0
line 38:     let s_flags = 'nW'
line 39:     let c2 = plist[i + 1]
line 40:   else
line 41:     let s_flags = 'nbW'
line 42:     let c2 = c
line 43:     let c = plist[i - 1]
line 44:   endif
line 45:   if c == '['
line 46:     let c = '\['
line 47:     let c2 = '\]'
line 48:   endif
line 49: 
line 50:   " Find the match.  When it was just before the cursor move it there for a
line 51:   " moment.
line 52:   if before > 0
line 53:     let has_getcurpos = exists("*getcurpos")
line 54:     if has_getcurpos
line 55:       " getcurpos() is more efficient but doesn't exist before 7.4.313.
line 56:       let save_cursor = getcurpos()
line 57:     else
line 58:       let save_cursor = winsaveview()
line 59:     endif
line 60:     call cursor(c_lnum, c_col - before)
line 61:   endif
line 62: 
line 63:   if !has("syntax") || !exists("g:syntax_on")
line 64:     let s_skip = "0"
line 65:   else
line 66:     " Build an expression that detects whether the current cursor position is
line 67:     " in certain syntax types (string, comment, etc.), for use as
line 68:     " searchpairpos()'s skip argument.
line 69:     " We match "escape" for special items, such as lispEscapeSpecial, and
line 70:     " match "symbol" for lispBarSymbol.
line 71:     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
line 74:     " If executing the expression determines that the cursor is currently in
line 75:     " one of the syntax types, then we want searchpairpos() to find the pair
line 76:     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
line 77:     " outside of the syntax types and s_skip should keep its value so we skip
line 78:     " any matching pair inside the syntax types.
line 79:     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
line 80:     try
line 81:       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
line 81: if synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0 | let s_skip = "0" | endif
line 81:  let s_skip = "0" | endif
line 81:  endif
line 82:     catch /^Vim\%((\a\+)\)\=:E363/
line 83:       " We won't find anything, so skip searching, should keep Vim responsive.
line 84:       return
line 85:     endtry
line 86:   endif
line 87: 
line 88:   " Limit the search to lines visible in the window.
line 89:   let stoplinebottom = line('w$')
line 90:   let stoplinetop = line('w0')
line 91:   if i % 2 == 0
line 92:     let stopline = stoplinebottom
line 93:   else
line 94:     let stopline = stoplinetop
line 95:   endif
line 96: 
line 97:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 98:   " This fails when a timeout is not supported.
line 99:   if mode() == 'i' || mode() == 'R'
line 100:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 101:   else
line 102:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 103:   endif
line 104:   try
line 105:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 106:   catch /E118/
line 107:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 108:     " a long time on closed folds and long lines.
line 109:     " The "viewable" variables give a range in which we can scroll while
line 110:     " keeping the cursor at the same position.
line 111:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 112:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 113:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 114:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 115:     " one of these stoplines will be adjusted below, but the current values are
line 116:     " minimal boundaries within the current window
line 117:     if i % 2 == 0
line 118:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 119: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 120: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 121:       else
line 122: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 123:       endif
line 124:       let stoplinebottom = stopline
line 125:     else
line 126:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 127: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 128: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 129:       else
line 130: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 131:       endif
line 132:       let stoplinetop = stopline
line 133:     endif
line 134:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 135:   endtry
line 136: 
line 137:   if before > 0
line 138:     if has_getcurpos
line 139:       call setpos('.', save_cursor)
line 140:     else
line 141:       call winrestview(save_cursor)
line 142:     endif
line 143:   endif
line 144: 
line 145:   " If a match is found setup match highlighting.
line 146:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 147:     if s:has_matchaddpos
line 148:       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
line 149:     else
line 150:       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 152:       call add(w:matchparen_ids, 3)
line 153:     endif
line 154:     let w:paren_hl_on = 1
line 155:   endif
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
line 33:     endif
line 34:   endif
line 35: 
line 36:   " Figure out the arguments for searchpairpos().
line 37:   if i % 2 == 0
line 38:     let s_flags = 'nW'
line 39:     let c2 = plist[i + 1]
line 40:   else
line 41:     let s_flags = 'nbW'
line 42:     let c2 = c
line 43:     let c = plist[i - 1]
line 44:   endif
line 45:   if c == '['
line 46:     let c = '\['
line 47:     let c2 = '\]'
line 48:   endif
line 49: 
line 50:   " Find the match.  When it was just before the cursor move it there for a
line 51:   " moment.
line 52:   if before > 0
line 53:     let has_getcurpos = exists("*getcurpos")
line 54:     if has_getcurpos
line 55:       " getcurpos() is more efficient but doesn't exist before 7.4.313.
line 56:       let save_cursor = getcurpos()
line 57:     else
line 58:       let save_cursor = winsaveview()
line 59:     endif
line 60:     call cursor(c_lnum, c_col - before)
line 61:   endif
line 62: 
line 63:   if !has("syntax") || !exists("g:syntax_on")
line 64:     let s_skip = "0"
line 65:   else
line 66:     " Build an expression that detects whether the current cursor position is
line 67:     " in certain syntax types (string, comment, etc.), for use as
line 68:     " searchpairpos()'s skip argument.
line 69:     " We match "escape" for special items, such as lispEscapeSpecial, and
line 70:     " match "symbol" for lispBarSymbol.
line 71:     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
line 74:     " If executing the expression determines that the cursor is currently in
line 75:     " one of the syntax types, then we want searchpairpos() to find the pair
line 76:     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
line 77:     " outside of the syntax types and s_skip should keep its value so we skip
line 78:     " any matching pair inside the syntax types.
line 79:     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
line 80:     try
line 81:       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
line 81: if synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0 | let s_skip = "0" | endif
line 81:  let s_skip = "0" | endif
line 81:  endif
line 82:     catch /^Vim\%((\a\+)\)\=:E363/
line 83:       " We won't find anything, so skip searching, should keep Vim responsive.
line 84:       return
line 85:     endtry
line 86:   endif
line 87: 
line 88:   " Limit the search to lines visible in the window.
line 89:   let stoplinebottom = line('w$')
line 90:   let stoplinetop = line('w0')
line 91:   if i % 2 == 0
line 92:     let stopline = stoplinebottom
line 93:   else
line 94:     let stopline = stoplinetop
line 95:   endif
line 96: 
line 97:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 98:   " This fails when a timeout is not supported.
line 99:   if mode() == 'i' || mode() == 'R'
line 100:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 101:   else
line 102:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 103:   endif
line 104:   try
line 105:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 106:   catch /E118/
line 107:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 108:     " a long time on closed folds and long lines.
line 109:     " The "viewable" variables give a range in which we can scroll while
line 110:     " keeping the cursor at the same position.
line 111:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 112:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 113:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 114:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 115:     " one of these stoplines will be adjusted below, but the current values are
line 116:     " minimal boundaries within the current window
line 117:     if i % 2 == 0
line 118:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 119: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 120: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 121:       else
line 122: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 123:       endif
line 124:       let stoplinebottom = stopline
line 125:     else
line 126:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 127: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 128: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 129:       else
line 130: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 131:       endif
line 132:       let stoplinetop = stopline
line 133:     endif
line 134:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 135:   endtry
line 136: 
line 137:   if before > 0
line 138:     if has_getcurpos
line 139:       call setpos('.', save_cursor)
line 140:     else
line 141:       call winrestview(save_cursor)
line 142:     endif
line 143:   endif
line 144: 
line 145:   " If a match is found setup match highlighting.
line 146:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 147:     if s:has_matchaddpos
line 148:       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
line 149:     else
line 150:       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 152:       call add(w:matchparen_ids, 3)
line 153:     endif
line 154:     let w:paren_hl_on = 1
line 155:   endif
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
line 33:     endif
line 34:   endif
line 35: 
line 36:   " Figure out the arguments for searchpairpos().
line 37:   if i % 2 == 0
line 38:     let s_flags = 'nW'
line 39:     let c2 = plist[i + 1]
line 40:   else
line 41:     let s_flags = 'nbW'
line 42:     let c2 = c
line 43:     let c = plist[i - 1]
line 44:   endif
line 45:   if c == '['
line 46:     let c = '\['
line 47:     let c2 = '\]'
line 48:   endif
line 49: 
line 50:   " Find the match.  When it was just before the cursor move it there for a
line 51:   " moment.
line 52:   if before > 0
line 53:     let has_getcurpos = exists("*getcurpos")
line 54:     if has_getcurpos
line 55:       " getcurpos() is more efficient but doesn't exist before 7.4.313.
line 56:       let save_cursor = getcurpos()
line 57:     else
line 58:       let save_cursor = winsaveview()
line 59:     endif
line 60:     call cursor(c_lnum, c_col - before)
line 61:   endif
line 62: 
line 63:   if !has("syntax") || !exists("g:syntax_on")
line 64:     let s_skip = "0"
line 65:   else
line 66:     " Build an expression that detects whether the current cursor position is
line 67:     " in certain syntax types (string, comment, etc.), for use as
line 68:     " searchpairpos()'s skip argument.
line 69:     " We match "escape" for special items, such as lispEscapeSpecial, and
line 70:     " match "symbol" for lispBarSymbol.
line 71:     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
line 74:     " If executing the expression determines that the cursor is currently in
line 75:     " one of the syntax types, then we want searchpairpos() to find the pair
line 76:     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
line 77:     " outside of the syntax types and s_skip should keep its value so we skip
line 78:     " any matching pair inside the syntax types.
line 79:     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
line 80:     try
line 81:       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
line 81: if synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0 | let s_skip = "0" | endif
line 81:  let s_skip = "0" | endif
line 81:  endif
line 82:     catch /^Vim\%((\a\+)\)\=:E363/
line 83:       " We won't find anything, so skip searching, should keep Vim responsive.
line 84:       return
line 85:     endtry
line 86:   endif
line 87: 
line 88:   " Limit the search to lines visible in the window.
line 89:   let stoplinebottom = line('w$')
line 90:   let stoplinetop = line('w0')
line 91:   if i % 2 == 0
line 92:     let stopline = stoplinebottom
line 93:   else
line 94:     let stopline = stoplinetop
line 95:   endif
line 96: 
line 97:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 98:   " This fails when a timeout is not supported.
line 99:   if mode() == 'i' || mode() == 'R'
line 100:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 101:   else
line 102:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 103:   endif
line 104:   try
line 105:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 106:   catch /E118/
line 107:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 108:     " a long time on closed folds and long lines.
line 109:     " The "viewable" variables give a range in which we can scroll while
line 110:     " keeping the cursor at the same position.
line 111:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 112:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 113:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 114:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 115:     " one of these stoplines will be adjusted below, but the current values are
line 116:     " minimal boundaries within the current window
line 117:     if i % 2 == 0
line 118:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 119: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 120: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 121:       else
line 122: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 123:       endif
line 124:       let stoplinebottom = stopline
line 125:     else
line 126:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 127: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 128: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 129:       else
line 130: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 131:       endif
line 132:       let stoplinetop = stopline
line 133:     endif
line 134:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 135:   endtry
line 136: 
line 137:   if before > 0
line 138:     if has_getcurpos
line 139:       call setpos('.', save_cursor)
line 140:     else
line 141:       call winrestview(save_cursor)
line 142:     endif
line 143:   endif
line 144: 
line 145:   " If a match is found setup match highlighting.
line 146:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 147:     if s:has_matchaddpos
line 148:       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
line 149:     else
line 150:       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 152:       call add(w:matchparen_ids, 3)
line 153:     endif
line 154:     let w:paren_hl_on = 1
line 155:   endif
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
line 33:     endif
line 34:   endif
line 35: 
line 36:   " Figure out the arguments for searchpairpos().
line 37:   if i % 2 == 0
line 38:     let s_flags = 'nW'
line 39:     let c2 = plist[i + 1]
line 40:   else
line 41:     let s_flags = 'nbW'
line 42:     let c2 = c
line 43:     let c = plist[i - 1]
line 44:   endif
line 45:   if c == '['
line 46:     let c = '\['
line 47:     let c2 = '\]'
line 48:   endif
line 49: 
line 50:   " Find the match.  When it was just before the cursor move it there for a
line 51:   " moment.
line 52:   if before > 0
line 53:     let has_getcurpos = exists("*getcurpos")
line 54:     if has_getcurpos
line 55:       " getcurpos() is more efficient but doesn't exist before 7.4.313.
line 56:       let save_cursor = getcurpos()
line 57:     else
line 58:       let save_cursor = winsaveview()
line 59:     endif
line 60:     call cursor(c_lnum, c_col - before)
line 61:   endif
line 62: 
line 63:   if !has("syntax") || !exists("g:syntax_on")
line 64:     let s_skip = "0"
line 65:   else
line 66:     " Build an expression that detects whether the current cursor position is
line 67:     " in certain syntax types (string, comment, etc.), for use as
line 68:     " searchpairpos()'s skip argument.
line 69:     " We match "escape" for special items, such as lispEscapeSpecial, and
line 70:     " match "symbol" for lispBarSymbol.
line 71:     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
line 74:     " If executing the expression determines that the cursor is currently in
line 75:     " one of the syntax types, then we want searchpairpos() to find the pair
line 76:     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
line 77:     " outside of the syntax types and s_skip should keep its value so we skip
line 78:     " any matching pair inside the syntax types.
line 79:     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
line 80:     try
line 81:       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
line 81: if synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0 | let s_skip = "0" | endif
line 81:  let s_skip = "0" | endif
line 81:  endif
line 82:     catch /^Vim\%((\a\+)\)\=:E363/
line 83:       " We won't find anything, so skip searching, should keep Vim responsive.
line 84:       return
line 85:     endtry
line 86:   endif
line 87: 
line 88:   " Limit the search to lines visible in the window.
line 89:   let stoplinebottom = line('w$')
line 90:   let stoplinetop = line('w0')
line 91:   if i % 2 == 0
line 92:     let stopline = stoplinebottom
line 93:   else
line 94:     let stopline = stoplinetop
line 95:   endif
line 96: 
line 97:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 98:   " This fails when a timeout is not supported.
line 99:   if mode() == 'i' || mode() == 'R'
line 100:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 101:   else
line 102:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 103:   endif
line 104:   try
line 105:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 106:   catch /E118/
line 107:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 108:     " a long time on closed folds and long lines.
line 109:     " The "viewable" variables give a range in which we can scroll while
line 110:     " keeping the cursor at the same position.
line 111:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 112:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 113:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 114:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 115:     " one of these stoplines will be adjusted below, but the current values are
line 116:     " minimal boundaries within the current window
line 117:     if i % 2 == 0
line 118:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 119: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 120: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 121:       else
line 122: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 123:       endif
line 124:       let stoplinebottom = stopline
line 125:     else
line 126:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 127: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 128: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 129:       else
line 130: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 131:       endif
line 132:       let stoplinetop = stopline
line 133:     endif
line 134:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 135:   endtry
line 136: 
line 137:   if before > 0
line 138:     if has_getcurpos
line 139:       call setpos('.', save_cursor)
line 140:     else
line 141:       call winrestview(save_cursor)
line 142:     endif
line 143:   endif
line 144: 
line 145:   " If a match is found setup match highlighting.
line 146:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 147:     if s:has_matchaddpos
line 148:       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
line 149:     else
line 150:       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 152:       call add(w:matchparen_ids, 3)
line 153:     endif
line 154:     let w:paren_hl_on = 1
line 155:   endif
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
line 33:     endif
line 34:   endif
line 35: 
line 36:   " Figure out the arguments for searchpairpos().
line 37:   if i % 2 == 0
line 38:     let s_flags = 'nW'
line 39:     let c2 = plist[i + 1]
line 40:   else
line 41:     let s_flags = 'nbW'
line 42:     let c2 = c
line 43:     let c = plist[i - 1]
line 44:   endif
line 45:   if c == '['
line 46:     let c = '\['
line 47:     let c2 = '\]'
line 48:   endif
line 49: 
line 50:   " Find the match.  When it was just before the cursor move it there for a
line 51:   " moment.
line 52:   if before > 0
line 53:     let has_getcurpos = exists("*getcurpos")
line 54:     if has_getcurpos
line 55:       " getcurpos() is more efficient but doesn't exist before 7.4.313.
line 56:       let save_cursor = getcurpos()
line 57:     else
line 58:       let save_cursor = winsaveview()
line 59:     endif
line 60:     call cursor(c_lnum, c_col - before)
line 61:   endif
line 62: 
line 63:   if !has("syntax") || !exists("g:syntax_on")
line 64:     let s_skip = "0"
line 65:   else
line 66:     " Build an expression that detects whether the current cursor position is
line 67:     " in certain syntax types (string, comment, etc.), for use as
line 68:     " searchpairpos()'s skip argument.
line 69:     " We match "escape" for special items, such as lispEscapeSpecial, and
line 70:     " match "symbol" for lispBarSymbol.
line 71:     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
line 74:     " If executing the expression determines that the cursor is currently in
line 75:     " one of the syntax types, then we want searchpairpos() to find the pair
line 76:     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
line 77:     " outside of the syntax types and s_skip should keep its value so we skip
line 78:     " any matching pair inside the syntax types.
line 79:     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
line 80:     try
line 81:       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
line 81: if synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0 | let s_skip = "0" | endif
line 81:  let s_skip = "0" | endif
line 81:  endif
line 82:     catch /^Vim\%((\a\+)\)\=:E363/
line 83:       " We won't find anything, so skip searching, should keep Vim responsive.
line 84:       return
line 85:     endtry
line 86:   endif
line 87: 
line 88:   " Limit the search to lines visible in the window.
line 89:   let stoplinebottom = line('w$')
line 90:   let stoplinetop = line('w0')
line 91:   if i % 2 == 0
line 92:     let stopline = stoplinebottom
line 93:   else
line 94:     let stopline = stoplinetop
line 95:   endif
line 96: 
line 97:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 98:   " This fails when a timeout is not supported.
line 99:   if mode() == 'i' || mode() == 'R'
line 100:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 101:   else
line 102:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 103:   endif
line 104:   try
line 105:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 106:   catch /E118/
line 107:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 108:     " a long time on closed folds and long lines.
line 109:     " The "viewable" variables give a range in which we can scroll while
line 110:     " keeping the cursor at the same position.
line 111:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 112:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 113:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 114:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 115:     " one of these stoplines will be adjusted below, but the current values are
line 116:     " minimal boundaries within the current window
line 117:     if i % 2 == 0
line 118:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 119: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 120: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 121:       else
line 122: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 123:       endif
line 124:       let stoplinebottom = stopline
line 125:     else
line 126:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 127: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 128: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 129:       else
line 130: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 131:       endif
line 132:       let stoplinetop = stopline
line 133:     endif
line 134:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 135:   endtry
line 136: 
line 137:   if before > 0
line 138:     if has_getcurpos
line 139:       call setpos('.', save_cursor)
line 140:     else
line 141:       call winrestview(save_cursor)
line 142:     endif
line 143:   endif
line 144: 
line 145:   " If a match is found setup match highlighting.
line 146:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 147:     if s:has_matchaddpos
line 148:       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
line 149:     else
line 150:       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 152:       call add(w:matchparen_ids, 3)
line 153:     endif
line 154:     let w:paren_hl_on = 1
line 155:   endif
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
line 33:     endif
line 34:   endif
line 35: 
line 36:   " Figure out the arguments for searchpairpos().
line 37:   if i % 2 == 0
line 38:     let s_flags = 'nW'
line 39:     let c2 = plist[i + 1]
line 40:   else
line 41:     let s_flags = 'nbW'
line 42:     let c2 = c
line 43:     let c = plist[i - 1]
line 44:   endif
line 45:   if c == '['
line 46:     let c = '\['
line 47:     let c2 = '\]'
line 48:   endif
line 49: 
line 50:   " Find the match.  When it was just before the cursor move it there for a
line 51:   " moment.
line 52:   if before > 0
line 53:     let has_getcurpos = exists("*getcurpos")
line 54:     if has_getcurpos
line 55:       " getcurpos() is more efficient but doesn't exist before 7.4.313.
line 56:       let save_cursor = getcurpos()
line 57:     else
line 58:       let save_cursor = winsaveview()
line 59:     endif
line 60:     call cursor(c_lnum, c_col - before)
line 61:   endif
line 62: 
line 63:   if !has("syntax") || !exists("g:syntax_on")
line 64:     let s_skip = "0"
line 65:   else
line 66:     " Build an expression that detects whether the current cursor position is
line 67:     " in certain syntax types (string, comment, etc.), for use as
line 68:     " searchpairpos()'s skip argument.
line 69:     " We match "escape" for special items, such as lispEscapeSpecial, and
line 70:     " match "symbol" for lispBarSymbol.
line 71:     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
line 74:     " If executing the expression determines that the cursor is currently in
line 75:     " one of the syntax types, then we want searchpairpos() to find the pair
line 76:     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
line 77:     " outside of the syntax types and s_skip should keep its value so we skip
line 78:     " any matching pair inside the syntax types.
line 79:     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
line 80:     try
line 81:       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
line 81: if synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0 | let s_skip = "0" | endif
line 81:  let s_skip = "0" | endif
line 81:  endif
line 82:     catch /^Vim\%((\a\+)\)\=:E363/
line 83:       " We won't find anything, so skip searching, should keep Vim responsive.
line 84:       return
line 85:     endtry
line 86:   endif
line 87: 
line 88:   " Limit the search to lines visible in the window.
line 89:   let stoplinebottom = line('w$')
line 90:   let stoplinetop = line('w0')
line 91:   if i % 2 == 0
line 92:     let stopline = stoplinebottom
line 93:   else
line 94:     let stopline = stoplinetop
line 95:   endif
line 96: 
line 97:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 98:   " This fails when a timeout is not supported.
line 99:   if mode() == 'i' || mode() == 'R'
line 100:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 101:   else
line 102:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 103:   endif
line 104:   try
line 105:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 106:   catch /E118/
line 107:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 108:     " a long time on closed folds and long lines.
line 109:     " The "viewable" variables give a range in which we can scroll while
line 110:     " keeping the cursor at the same position.
line 111:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 112:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 113:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 114:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 115:     " one of these stoplines will be adjusted below, but the current values are
line 116:     " minimal boundaries within the current window
line 117:     if i % 2 == 0
line 118:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 119: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 120: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 121:       else
line 122: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 123:       endif
line 124:       let stoplinebottom = stopline
line 125:     else
line 126:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 127: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 128: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 129:       else
line 130: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 131:       endif
line 132:       let stoplinetop = stopline
line 133:     endif
line 134:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 135:   endtry
line 136: 
line 137:   if before > 0
line 138:     if has_getcurpos
line 139:       call setpos('.', save_cursor)
line 140:     else
line 141:       call winrestview(save_cursor)
line 142:     endif
line 143:   endif
line 144: 
line 145:   " If a match is found setup match highlighting.
line 146:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 147:     if s:has_matchaddpos
line 148:       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
line 149:     else
line 150:       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 152:       call add(w:matchparen_ids, 3)
line 153:     endif
line 154:     let w:paren_hl_on = 1
line 155:   endif
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
line 33:     endif
line 34:   endif
line 35: 
line 36:   " Figure out the arguments for searchpairpos().
line 37:   if i % 2 == 0
line 38:     let s_flags = 'nW'
line 39:     let c2 = plist[i + 1]
line 40:   else
line 41:     let s_flags = 'nbW'
line 42:     let c2 = c
line 43:     let c = plist[i - 1]
line 44:   endif
line 45:   if c == '['
line 46:     let c = '\['
line 47:     let c2 = '\]'
line 48:   endif
line 49: 
line 50:   " Find the match.  When it was just before the cursor move it there for a
line 51:   " moment.
line 52:   if before > 0
line 53:     let has_getcurpos = exists("*getcurpos")
line 54:     if has_getcurpos
line 55:       " getcurpos() is more efficient but doesn't exist before 7.4.313.
line 56:       let save_cursor = getcurpos()
line 57:     else
line 58:       let save_cursor = winsaveview()
line 59:     endif
line 60:     call cursor(c_lnum, c_col - before)
line 61:   endif
line 62: 
line 63:   if !has("syntax") || !exists("g:syntax_on")
line 64:     let s_skip = "0"
line 65:   else
line 66:     " Build an expression that detects whether the current cursor position is
line 67:     " in certain syntax types (string, comment, etc.), for use as
line 68:     " searchpairpos()'s skip argument.
line 69:     " We match "escape" for special items, such as lispEscapeSpecial, and
line 70:     " match "symbol" for lispBarSymbol.
line 71:     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
line 74:     " If executing the expression determines that the cursor is currently in
line 75:     " one of the syntax types, then we want searchpairpos() to find the pair
line 76:     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
line 77:     " outside of the syntax types and s_skip should keep its value so we skip
line 78:     " any matching pair inside the syntax types.
line 79:     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
line 80:     try
line 81:       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
line 81: if synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0 | let s_skip = "0" | endif
line 81:  let s_skip = "0" | endif
line 81:  endif
line 82:     catch /^Vim\%((\a\+)\)\=:E363/
line 83:       " We won't find anything, so skip searching, should keep Vim responsive.
line 84:       return
line 85:     endtry
line 86:   endif
line 87: 
line 88:   " Limit the search to lines visible in the window.
line 89:   let stoplinebottom = line('w$')
line 90:   let stoplinetop = line('w0')
line 91:   if i % 2 == 0
line 92:     let stopline = stoplinebottom
line 93:   else
line 94:     let stopline = stoplinetop
line 95:   endif
line 96: 
line 97:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 98:   " This fails when a timeout is not supported.
line 99:   if mode() == 'i' || mode() == 'R'
line 100:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 101:   else
line 102:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 103:   endif
line 104:   try
line 105:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 106:   catch /E118/
line 107:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 108:     " a long time on closed folds and long lines.
line 109:     " The "viewable" variables give a range in which we can scroll while
line 110:     " keeping the cursor at the same position.
line 111:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 112:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 113:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 114:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 115:     " one of these stoplines will be adjusted below, but the current values are
line 116:     " minimal boundaries within the current window
line 117:     if i % 2 == 0
line 118:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 119: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 120: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 121:       else
line 122: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 123:       endif
line 124:       let stoplinebottom = stopline
line 125:     else
line 126:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 127: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 128: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 129:       else
line 130: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 131:       endif
line 132:       let stoplinetop = stopline
line 133:     endif
line 134:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 135:   endtry
line 136: 
line 137:   if before > 0
line 138:     if has_getcurpos
line 139:       call setpos('.', save_cursor)
line 140:     else
line 141:       call winrestview(save_cursor)
line 142:     endif
line 143:   endif
line 144: 
line 145:   " If a match is found setup match highlighting.
line 146:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 147:     if s:has_matchaddpos
line 148:       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
line 149:     else
line 150:       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 152:       call add(w:matchparen_ids, 3)
line 153:     endif
line 154:     let w:paren_hl_on = 1
line 155:   endif
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
line 33:     endif
line 34:   endif
line 35: 
line 36:   " Figure out the arguments for searchpairpos().
line 37:   if i % 2 == 0
line 38:     let s_flags = 'nW'
line 39:     let c2 = plist[i + 1]
line 40:   else
line 41:     let s_flags = 'nbW'
line 42:     let c2 = c
line 43:     let c = plist[i - 1]
line 44:   endif
line 45:   if c == '['
line 46:     let c = '\['
line 47:     let c2 = '\]'
line 48:   endif
line 49: 
line 50:   " Find the match.  When it was just before the cursor move it there for a
line 51:   " moment.
line 52:   if before > 0
line 53:     let has_getcurpos = exists("*getcurpos")
line 54:     if has_getcurpos
line 55:       " getcurpos() is more efficient but doesn't exist before 7.4.313.
line 56:       let save_cursor = getcurpos()
line 57:     else
line 58:       let save_cursor = winsaveview()
line 59:     endif
line 60:     call cursor(c_lnum, c_col - before)
line 61:   endif
line 62: 
line 63:   if !has("syntax") || !exists("g:syntax_on")
line 64:     let s_skip = "0"
line 65:   else
line 66:     " Build an expression that detects whether the current cursor position is
line 67:     " in certain syntax types (string, comment, etc.), for use as
line 68:     " searchpairpos()'s skip argument.
line 69:     " We match "escape" for special items, such as lispEscapeSpecial, and
line 70:     " match "symbol" for lispBarSymbol.
line 71:     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
line 74:     " If executing the expression determines that the cursor is currently in
line 75:     " one of the syntax types, then we want searchpairpos() to find the pair
line 76:     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
line 77:     " outside of the syntax types and s_skip should keep its value so we skip
line 78:     " any matching pair inside the syntax types.
line 79:     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
line 80:     try
line 81:       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
line 81: if synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0 | let s_skip = "0" | endif
line 81:  let s_skip = "0" | endif
line 81:  endif
line 82:     catch /^Vim\%((\a\+)\)\=:E363/
line 83:       " We won't find anything, so skip searching, should keep Vim responsive.
line 84:       return
line 85:     endtry
line 86:   endif
line 87: 
line 88:   " Limit the search to lines visible in the window.
line 89:   let stoplinebottom = line('w$')
line 90:   let stoplinetop = line('w0')
line 91:   if i % 2 == 0
line 92:     let stopline = stoplinebottom
line 93:   else
line 94:     let stopline = stoplinetop
line 95:   endif
line 96: 
line 97:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 98:   " This fails when a timeout is not supported.
line 99:   if mode() == 'i' || mode() == 'R'
line 100:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 101:   else
line 102:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 103:   endif
line 104:   try
line 105:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 106:   catch /E118/
line 107:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 108:     " a long time on closed folds and long lines.
line 109:     " The "viewable" variables give a range in which we can scroll while
line 110:     " keeping the cursor at the same position.
line 111:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 112:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 113:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 114:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 115:     " one of these stoplines will be adjusted below, but the current values are
line 116:     " minimal boundaries within the current window
line 117:     if i % 2 == 0
line 118:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 119: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 120: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 121:       else
line 122: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 123:       endif
line 124:       let stoplinebottom = stopline
line 125:     else
line 126:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 127: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 128: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 129:       else
line 130: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 131:       endif
line 132:       let stoplinetop = stopline
line 133:     endif
line 134:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 135:   endtry
line 136: 
line 137:   if before > 0
line 138:     if has_getcurpos
line 139:       call setpos('.', save_cursor)
line 140:     else
line 141:       call winrestview(save_cursor)
line 142:     endif
line 143:   endif
line 144: 
line 145:   " If a match is found setup match highlighting.
line 146:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 147:     if s:has_matchaddpos
line 148:       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
line 149:     else
line 150:       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 152:       call add(w:matchparen_ids, 3)
line 153:     endif
line 154:     let w:paren_hl_on = 1
line 155:   endif
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing ModeChanged Autocommands for "*"
autocommand <Lua 199: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:93>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: -- VISUAL --
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing: highlight! lualine_transitional_lualine_a_visual_to_lualine_b_visual guifg=#FF61EF guibg=#112638 gui=None
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing ModeChanged Autocommands for "*"
autocommand <Lua 199: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:93>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
line 33:     endif
line 34:   endif
line 35: 
line 36:   " Figure out the arguments for searchpairpos().
line 37:   if i % 2 == 0
line 38:     let s_flags = 'nW'
line 39:     let c2 = plist[i + 1]
line 40:   else
line 41:     let s_flags = 'nbW'
line 42:     let c2 = c
line 43:     let c = plist[i - 1]
line 44:   endif
line 45:   if c == '['
line 46:     let c = '\['
line 47:     let c2 = '\]'
line 48:   endif
line 49: 
line 50:   " Find the match.  When it was just before the cursor move it there for a
line 51:   " moment.
line 52:   if before > 0
line 53:     let has_getcurpos = exists("*getcurpos")
line 54:     if has_getcurpos
line 55:       " getcurpos() is more efficient but doesn't exist before 7.4.313.
line 56:       let save_cursor = getcurpos()
line 57:     else
line 58:       let save_cursor = winsaveview()
line 59:     endif
line 60:     call cursor(c_lnum, c_col - before)
line 61:   endif
line 62: 
line 63:   if !has("syntax") || !exists("g:syntax_on")
line 64:     let s_skip = "0"
line 65:   else
line 66:     " Build an expression that detects whether the current cursor position is
line 67:     " in certain syntax types (string, comment, etc.), for use as
line 68:     " searchpairpos()'s skip argument.
line 69:     " We match "escape" for special items, such as lispEscapeSpecial, and
line 70:     " match "symbol" for lispBarSymbol.
line 71:     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
line 74:     " If executing the expression determines that the cursor is currently in
line 75:     " one of the syntax types, then we want searchpairpos() to find the pair
line 76:     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
line 77:     " outside of the syntax types and s_skip should keep its value so we skip
line 78:     " any matching pair inside the syntax types.
line 79:     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
line 80:     try
line 81:       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
line 81: if synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0 | let s_skip = "0" | endif
line 81:  let s_skip = "0" | endif
line 81:  endif
line 82:     catch /^Vim\%((\a\+)\)\=:E363/
line 83:       " We won't find anything, so skip searching, should keep Vim responsive.
line 84:       return
line 85:     endtry
line 86:   endif
line 87: 
line 88:   " Limit the search to lines visible in the window.
line 89:   let stoplinebottom = line('w$')
line 90:   let stoplinetop = line('w0')
line 91:   if i % 2 == 0
line 92:     let stopline = stoplinebottom
line 93:   else
line 94:     let stopline = stoplinetop
line 95:   endif
line 96: 
line 97:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 98:   " This fails when a timeout is not supported.
line 99:   if mode() == 'i' || mode() == 'R'
line 100:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 101:   else
line 102:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 103:   endif
line 104:   try
line 105:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 106:   catch /E118/
line 107:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 108:     " a long time on closed folds and long lines.
line 109:     " The "viewable" variables give a range in which we can scroll while
line 110:     " keeping the cursor at the same position.
line 111:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 112:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 113:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 114:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 115:     " one of these stoplines will be adjusted below, but the current values are
line 116:     " minimal boundaries within the current window
line 117:     if i % 2 == 0
line 118:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 119: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 120: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 121:       else
line 122: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 123:       endif
line 124:       let stoplinebottom = stopline
line 125:     else
line 126:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 127: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 128: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 129:       else
line 130: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 131:       endif
line 132:       let stoplinetop = stopline
line 133:     endif
line 134:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 135:   endtry
line 136: 
line 137:   if before > 0
line 138:     if has_getcurpos
line 139:       call setpos('.', save_cursor)
line 140:     else
line 141:       call winrestview(save_cursor)
line 142:     endif
line 143:   endif
line 144: 
line 145:   " If a match is found setup match highlighting.
line 146:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 147:     if s:has_matchaddpos
line 148:       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
line 149:     else
line 150:       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 152:       call add(w:matchparen_ids, 3)
line 153:     endif
line 154:     let w:paren_hl_on = 1
line 155:   endif
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
line 33:     endif
line 34:   endif
line 35: 
line 36:   " Figure out the arguments for searchpairpos().
line 37:   if i % 2 == 0
line 38:     let s_flags = 'nW'
line 39:     let c2 = plist[i + 1]
line 40:   else
line 41:     let s_flags = 'nbW'
line 42:     let c2 = c
line 43:     let c = plist[i - 1]
line 44:   endif
line 45:   if c == '['
line 46:     let c = '\['
line 47:     let c2 = '\]'
line 48:   endif
line 49: 
line 50:   " Find the match.  When it was just before the cursor move it there for a
line 51:   " moment.
line 52:   if before > 0
line 53:     let has_getcurpos = exists("*getcurpos")
line 54:     if has_getcurpos
line 55:       " getcurpos() is more efficient but doesn't exist before 7.4.313.
line 56:       let save_cursor = getcurpos()
line 57:     else
line 58:       let save_cursor = winsaveview()
line 59:     endif
line 60:     call cursor(c_lnum, c_col - before)
line 61:   endif
line 62: 
line 63:   if !has("syntax") || !exists("g:syntax_on")
line 64:     let s_skip = "0"
line 65:   else
line 66:     " Build an expression that detects whether the current cursor position is
line 67:     " in certain syntax types (string, comment, etc.), for use as
line 68:     " searchpairpos()'s skip argument.
line 69:     " We match "escape" for special items, such as lispEscapeSpecial, and
line 70:     " match "symbol" for lispBarSymbol.
line 71:     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
line 74:     " If executing the expression determines that the cursor is currently in
line 75:     " one of the syntax types, then we want searchpairpos() to find the pair
line 76:     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
line 77:     " outside of the syntax types and s_skip should keep its value so we skip
line 78:     " any matching pair inside the syntax types.
line 79:     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
line 80:     try
line 81:       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
line 81: if synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0 | let s_skip = "0" | endif
line 81:  let s_skip = "0" | endif
line 81:  endif
line 82:     catch /^Vim\%((\a\+)\)\=:E363/
line 83:       " We won't find anything, so skip searching, should keep Vim responsive.
line 84:       return
line 85:     endtry
line 86:   endif
line 87: 
line 88:   " Limit the search to lines visible in the window.
line 89:   let stoplinebottom = line('w$')
line 90:   let stoplinetop = line('w0')
line 91:   if i % 2 == 0
line 92:     let stopline = stoplinebottom
line 93:   else
line 94:     let stopline = stoplinetop
line 95:   endif
line 96: 
line 97:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 98:   " This fails when a timeout is not supported.
line 99:   if mode() == 'i' || mode() == 'R'
line 100:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 101:   else
line 102:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 103:   endif
line 104:   try
line 105:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 106:   catch /E118/
line 107:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 108:     " a long time on closed folds and long lines.
line 109:     " The "viewable" variables give a range in which we can scroll while
line 110:     " keeping the cursor at the same position.
line 111:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 112:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 113:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 114:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 115:     " one of these stoplines will be adjusted below, but the current values are
line 116:     " minimal boundaries within the current window
line 117:     if i % 2 == 0
line 118:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 119: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 120: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 121:       else
line 122: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 123:       endif
line 124:       let stoplinebottom = stopline
line 125:     else
line 126:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 127: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 128: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 129:       else
line 130: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 131:       endif
line 132:       let stoplinetop = stopline
line 133:     endif
line 134:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 135:   endtry
line 136: 
line 137:   if before > 0
line 138:     if has_getcurpos
line 139:       call setpos('.', save_cursor)
line 140:     else
line 141:       call winrestview(save_cursor)
line 142:     endif
line 143:   endif
line 144: 
line 145:   " If a match is found setup match highlighting.
line 146:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 147:     if s:has_matchaddpos
line 148:       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
line 149:     else
line 150:       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 152:       call add(w:matchparen_ids, 3)
line 153:     endif
line 154:     let w:paren_hl_on = 1
line 155:   endif
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
line 33:     endif
line 34:   endif
line 35: 
line 36:   " Figure out the arguments for searchpairpos().
line 37:   if i % 2 == 0
line 38:     let s_flags = 'nW'
line 39:     let c2 = plist[i + 1]
line 40:   else
line 41:     let s_flags = 'nbW'
line 42:     let c2 = c
line 43:     let c = plist[i - 1]
line 44:   endif
line 45:   if c == '['
line 46:     let c = '\['
line 47:     let c2 = '\]'
line 48:   endif
line 49: 
line 50:   " Find the match.  When it was just before the cursor move it there for a
line 51:   " moment.
line 52:   if before > 0
line 53:     let has_getcurpos = exists("*getcurpos")
line 54:     if has_getcurpos
line 55:       " getcurpos() is more efficient but doesn't exist before 7.4.313.
line 56:       let save_cursor = getcurpos()
line 57:     else
line 58:       let save_cursor = winsaveview()
line 59:     endif
line 60:     call cursor(c_lnum, c_col - before)
line 61:   endif
line 62: 
line 63:   if !has("syntax") || !exists("g:syntax_on")
line 64:     let s_skip = "0"
line 65:   else
line 66:     " Build an expression that detects whether the current cursor position is
line 67:     " in certain syntax types (string, comment, etc.), for use as
line 68:     " searchpairpos()'s skip argument.
line 69:     " We match "escape" for special items, such as lispEscapeSpecial, and
line 70:     " match "symbol" for lispBarSymbol.
line 71:     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
line 74:     " If executing the expression determines that the cursor is currently in
line 75:     " one of the syntax types, then we want searchpairpos() to find the pair
line 76:     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
line 77:     " outside of the syntax types and s_skip should keep its value so we skip
line 78:     " any matching pair inside the syntax types.
line 79:     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
line 80:     try
line 81:       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
line 81: if synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0 | let s_skip = "0" | endif
line 81:  let s_skip = "0" | endif
line 81:  endif
line 82:     catch /^Vim\%((\a\+)\)\=:E363/
line 83:       " We won't find anything, so skip searching, should keep Vim responsive.
line 84:       return
line 85:     endtry
line 86:   endif
line 87: 
line 88:   " Limit the search to lines visible in the window.
line 89:   let stoplinebottom = line('w$')
line 90:   let stoplinetop = line('w0')
line 91:   if i % 2 == 0
line 92:     let stopline = stoplinebottom
line 93:   else
line 94:     let stopline = stoplinetop
line 95:   endif
line 96: 
line 97:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 98:   " This fails when a timeout is not supported.
line 99:   if mode() == 'i' || mode() == 'R'
line 100:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 101:   else
line 102:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 103:   endif
line 104:   try
line 105:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 106:   catch /E118/
line 107:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 108:     " a long time on closed folds and long lines.
line 109:     " The "viewable" variables give a range in which we can scroll while
line 110:     " keeping the cursor at the same position.
line 111:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 112:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 113:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 114:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 115:     " one of these stoplines will be adjusted below, but the current values are
line 116:     " minimal boundaries within the current window
line 117:     if i % 2 == 0
line 118:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 119: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 120: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 121:       else
line 122: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 123:       endif
line 124:       let stoplinebottom = stopline
line 125:     else
line 126:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 127: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 128: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 129:       else
line 130: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 131:       endif
line 132:       let stoplinetop = stopline
line 133:     endif
line 134:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 135:   endtry
line 136: 
line 137:   if before > 0
line 138:     if has_getcurpos
line 139:       call setpos('.', save_cursor)
line 140:     else
line 141:       call winrestview(save_cursor)
line 142:     endif
line 143:   endif
line 144: 
line 145:   " If a match is found setup match highlighting.
line 146:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 147:     if s:has_matchaddpos
line 148:       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
line 149:     else
line 150:       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 152:       call add(w:matchparen_ids, 3)
line 153:     endif
line 154:     let w:paren_hl_on = 1
line 155:   endif
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
line 33:     endif
line 34:   endif
line 35: 
line 36:   " Figure out the arguments for searchpairpos().
line 37:   if i % 2 == 0
line 38:     let s_flags = 'nW'
line 39:     let c2 = plist[i + 1]
line 40:   else
line 41:     let s_flags = 'nbW'
line 42:     let c2 = c
line 43:     let c = plist[i - 1]
line 44:   endif
line 45:   if c == '['
line 46:     let c = '\['
line 47:     let c2 = '\]'
line 48:   endif
line 49: 
line 50:   " Find the match.  When it was just before the cursor move it there for a
line 51:   " moment.
line 52:   if before > 0
line 53:     let has_getcurpos = exists("*getcurpos")
line 54:     if has_getcurpos
line 55:       " getcurpos() is more efficient but doesn't exist before 7.4.313.
line 56:       let save_cursor = getcurpos()
line 57:     else
line 58:       let save_cursor = winsaveview()
line 59:     endif
line 60:     call cursor(c_lnum, c_col - before)
line 61:   endif
line 62: 
line 63:   if !has("syntax") || !exists("g:syntax_on")
line 64:     let s_skip = "0"
line 65:   else
line 66:     " Build an expression that detects whether the current cursor position is
line 67:     " in certain syntax types (string, comment, etc.), for use as
line 68:     " searchpairpos()'s skip argument.
line 69:     " We match "escape" for special items, such as lispEscapeSpecial, and
line 70:     " match "symbol" for lispBarSymbol.
line 71:     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
line 74:     " If executing the expression determines that the cursor is currently in
line 75:     " one of the syntax types, then we want searchpairpos() to find the pair
line 76:     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
line 77:     " outside of the syntax types and s_skip should keep its value so we skip
line 78:     " any matching pair inside the syntax types.
line 79:     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
line 80:     try
line 81:       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
line 81: if synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0 | let s_skip = "0" | endif
line 81:  let s_skip = "0" | endif
line 81:  endif
line 82:     catch /^Vim\%((\a\+)\)\=:E363/
line 83:       " We won't find anything, so skip searching, should keep Vim responsive.
line 84:       return
line 85:     endtry
line 86:   endif
line 87: 
line 88:   " Limit the search to lines visible in the window.
line 89:   let stoplinebottom = line('w$')
line 90:   let stoplinetop = line('w0')
line 91:   if i % 2 == 0
line 92:     let stopline = stoplinebottom
line 93:   else
line 94:     let stopline = stoplinetop
line 95:   endif
line 96: 
line 97:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 98:   " This fails when a timeout is not supported.
line 99:   if mode() == 'i' || mode() == 'R'
line 100:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 101:   else
line 102:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 103:   endif
line 104:   try
line 105:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 106:   catch /E118/
line 107:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 108:     " a long time on closed folds and long lines.
line 109:     " The "viewable" variables give a range in which we can scroll while
line 110:     " keeping the cursor at the same position.
line 111:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 112:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 113:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 114:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 115:     " one of these stoplines will be adjusted below, but the current values are
line 116:     " minimal boundaries within the current window
line 117:     if i % 2 == 0
line 118:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 119: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 120: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 121:       else
line 122: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 123:       endif
line 124:       let stoplinebottom = stopline
line 125:     else
line 126:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 127: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 128: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 129:       else
line 130: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 131:       endif
line 132:       let stoplinetop = stopline
line 133:     endif
line 134:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 135:   endtry
line 136: 
line 137:   if before > 0
line 138:     if has_getcurpos
line 139:       call setpos('.', save_cursor)
line 140:     else
line 141:       call winrestview(save_cursor)
line 142:     endif
line 143:   endif
line 144: 
line 145:   " If a match is found setup match highlighting.
line 146:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 147:     if s:has_matchaddpos
line 148:       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
line 149:     else
line 150:       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 152:       call add(w:matchparen_ids, 3)
line 153:     endif
line 154:     let w:paren_hl_on = 1
line 155:   endif
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing ModeChanged Autocommands for "*"
autocommand <Lua 199: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:93>

Executing: -- VISUAL --
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing ModeChanged Autocommands for "*"
autocommand <Lua 199: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:93>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
line 33:     endif
line 34:   endif
line 35: 
line 36:   " Figure out the arguments for searchpairpos().
line 37:   if i % 2 == 0
line 38:     let s_flags = 'nW'
line 39:     let c2 = plist[i + 1]
line 40:   else
line 41:     let s_flags = 'nbW'
line 42:     let c2 = c
line 43:     let c = plist[i - 1]
line 44:   endif
line 45:   if c == '['
line 46:     let c = '\['
line 47:     let c2 = '\]'
line 48:   endif
line 49: 
line 50:   " Find the match.  When it was just before the cursor move it there for a
line 51:   " moment.
line 52:   if before > 0
line 53:     let has_getcurpos = exists("*getcurpos")
line 54:     if has_getcurpos
line 55:       " getcurpos() is more efficient but doesn't exist before 7.4.313.
line 56:       let save_cursor = getcurpos()
line 57:     else
line 58:       let save_cursor = winsaveview()
line 59:     endif
line 60:     call cursor(c_lnum, c_col - before)
line 61:   endif
line 62: 
line 63:   if !has("syntax") || !exists("g:syntax_on")
line 64:     let s_skip = "0"
line 65:   else
line 66:     " Build an expression that detects whether the current cursor position is
line 67:     " in certain syntax types (string, comment, etc.), for use as
line 68:     " searchpairpos()'s skip argument.
line 69:     " We match "escape" for special items, such as lispEscapeSpecial, and
line 70:     " match "symbol" for lispBarSymbol.
line 71:     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
line 74:     " If executing the expression determines that the cursor is currently in
line 75:     " one of the syntax types, then we want searchpairpos() to find the pair
line 76:     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
line 77:     " outside of the syntax types and s_skip should keep its value so we skip
line 78:     " any matching pair inside the syntax types.
line 79:     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
line 80:     try
line 81:       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
line 81: if synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0 | let s_skip = "0" | endif
line 81:  let s_skip = "0" | endif
line 81:  endif
line 82:     catch /^Vim\%((\a\+)\)\=:E363/
line 83:       " We won't find anything, so skip searching, should keep Vim responsive.
line 84:       return
line 85:     endtry
line 86:   endif
line 87: 
line 88:   " Limit the search to lines visible in the window.
line 89:   let stoplinebottom = line('w$')
line 90:   let stoplinetop = line('w0')
line 91:   if i % 2 == 0
line 92:     let stopline = stoplinebottom
line 93:   else
line 94:     let stopline = stoplinetop
line 95:   endif
line 96: 
line 97:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 98:   " This fails when a timeout is not supported.
line 99:   if mode() == 'i' || mode() == 'R'
line 100:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 101:   else
line 102:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 103:   endif
line 104:   try
line 105:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 106:   catch /E118/
line 107:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 108:     " a long time on closed folds and long lines.
line 109:     " The "viewable" variables give a range in which we can scroll while
line 110:     " keeping the cursor at the same position.
line 111:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 112:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 113:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 114:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 115:     " one of these stoplines will be adjusted below, but the current values are
line 116:     " minimal boundaries within the current window
line 117:     if i % 2 == 0
line 118:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 119: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 120: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 121:       else
line 122: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 123:       endif
line 124:       let stoplinebottom = stopline
line 125:     else
line 126:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 127: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 128: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 129:       else
line 130: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 131:       endif
line 132:       let stoplinetop = stopline
line 133:     endif
line 134:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 135:   endtry
line 136: 
line 137:   if before > 0
line 138:     if has_getcurpos
line 139:       call setpos('.', save_cursor)
line 140:     else
line 141:       call winrestview(save_cursor)
line 142:     endif
line 143:   endif
line 144: 
line 145:   " If a match is found setup match highlighting.
line 146:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 147:     if s:has_matchaddpos
line 148:       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
line 149:     else
line 150:       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 152:       call add(w:matchparen_ids, 3)
line 153:     endif
line 154:     let w:paren_hl_on = 1
line 155:   endif
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
line 33:     endif
line 34:   endif
line 35: 
line 36:   " Figure out the arguments for searchpairpos().
line 37:   if i % 2 == 0
line 38:     let s_flags = 'nW'
line 39:     let c2 = plist[i + 1]
line 40:   else
line 41:     let s_flags = 'nbW'
line 42:     let c2 = c
line 43:     let c = plist[i - 1]
line 44:   endif
line 45:   if c == '['
line 46:     let c = '\['
line 47:     let c2 = '\]'
line 48:   endif
line 49: 
line 50:   " Find the match.  When it was just before the cursor move it there for a
line 51:   " moment.
line 52:   if before > 0
line 53:     let has_getcurpos = exists("*getcurpos")
line 54:     if has_getcurpos
line 55:       " getcurpos() is more efficient but doesn't exist before 7.4.313.
line 56:       let save_cursor = getcurpos()
line 57:     else
line 58:       let save_cursor = winsaveview()
line 59:     endif
line 60:     call cursor(c_lnum, c_col - before)
line 61:   endif
line 62: 
line 63:   if !has("syntax") || !exists("g:syntax_on")
line 64:     let s_skip = "0"
line 65:   else
line 66:     " Build an expression that detects whether the current cursor position is
line 67:     " in certain syntax types (string, comment, etc.), for use as
line 68:     " searchpairpos()'s skip argument.
line 69:     " We match "escape" for special items, such as lispEscapeSpecial, and
line 70:     " match "symbol" for lispBarSymbol.
line 71:     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
line 74:     " If executing the expression determines that the cursor is currently in
line 75:     " one of the syntax types, then we want searchpairpos() to find the pair
line 76:     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
line 77:     " outside of the syntax types and s_skip should keep its value so we skip
line 78:     " any matching pair inside the syntax types.
line 79:     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
line 80:     try
line 81:       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
line 81: if synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0 | let s_skip = "0" | endif
line 81:  let s_skip = "0" | endif
line 81:  endif
line 82:     catch /^Vim\%((\a\+)\)\=:E363/
line 83:       " We won't find anything, so skip searching, should keep Vim responsive.
line 84:       return
line 85:     endtry
line 86:   endif
line 87: 
line 88:   " Limit the search to lines visible in the window.
line 89:   let stoplinebottom = line('w$')
line 90:   let stoplinetop = line('w0')
line 91:   if i % 2 == 0
line 92:     let stopline = stoplinebottom
line 93:   else
line 94:     let stopline = stoplinetop
line 95:   endif
line 96: 
line 97:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 98:   " This fails when a timeout is not supported.
line 99:   if mode() == 'i' || mode() == 'R'
line 100:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 101:   else
line 102:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 103:   endif
line 104:   try
line 105:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 106:   catch /E118/
line 107:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 108:     " a long time on closed folds and long lines.
line 109:     " The "viewable" variables give a range in which we can scroll while
line 110:     " keeping the cursor at the same position.
line 111:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 112:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 113:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 114:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 115:     " one of these stoplines will be adjusted below, but the current values are
line 116:     " minimal boundaries within the current window
line 117:     if i % 2 == 0
line 118:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 119: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 120: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 121:       else
line 122: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 123:       endif
line 124:       let stoplinebottom = stopline
line 125:     else
line 126:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 127: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 128: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 129:       else
line 130: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 131:       endif
line 132:       let stoplinetop = stopline
line 133:     endif
line 134:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 135:   endtry
line 136: 
line 137:   if before > 0
line 138:     if has_getcurpos
line 139:       call setpos('.', save_cursor)
line 140:     else
line 141:       call winrestview(save_cursor)
line 142:     endif
line 143:   endif
line 144: 
line 145:   " If a match is found setup match highlighting.
line 146:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 147:     if s:has_matchaddpos
line 148:       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
line 149:     else
line 150:       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 152:       call add(w:matchparen_ids, 3)
line 153:     endif
line 154:     let w:paren_hl_on = 1
line 155:   endif
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing ModeChanged Autocommands for "*"
autocommand <Lua 199: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:93>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: -- VISUAL --
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: 
Executing ModeChanged Autocommands for "*"
autocommand <Lua 199: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:93>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
line 33:     endif
line 34:   endif
line 35: 
line 36:   " Figure out the arguments for searchpairpos().
line 37:   if i % 2 == 0
line 38:     let s_flags = 'nW'
line 39:     let c2 = plist[i + 1]
line 40:   else
line 41:     let s_flags = 'nbW'
line 42:     let c2 = c
line 43:     let c = plist[i - 1]
line 44:   endif
line 45:   if c == '['
line 46:     let c = '\['
line 47:     let c2 = '\]'
line 48:   endif
line 49: 
line 50:   " Find the match.  When it was just before the cursor move it there for a
line 51:   " moment.
line 52:   if before > 0
line 53:     let has_getcurpos = exists("*getcurpos")
line 54:     if has_getcurpos
line 55:       " getcurpos() is more efficient but doesn't exist before 7.4.313.
line 56:       let save_cursor = getcurpos()
line 57:     else
line 58:       let save_cursor = winsaveview()
line 59:     endif
line 60:     call cursor(c_lnum, c_col - before)
line 61:   endif
line 62: 
line 63:   if !has("syntax") || !exists("g:syntax_on")
line 64:     let s_skip = "0"
line 65:   else
line 66:     " Build an expression that detects whether the current cursor position is
line 67:     " in certain syntax types (string, comment, etc.), for use as
line 68:     " searchpairpos()'s skip argument.
line 69:     " We match "escape" for special items, such as lispEscapeSpecial, and
line 70:     " match "symbol" for lispBarSymbol.
line 71:     let s_skip = 'synstack(".", col("."))' . '->indexof({_, id -> synIDattr(id, "name") =~? ' . '"string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0'
line 74:     " If executing the expression determines that the cursor is currently in
line 75:     " one of the syntax types, then we want searchpairpos() to find the pair
line 76:     " within those syntax types (i.e., not skip).  Otherwise, the cursor is
line 77:     " outside of the syntax types and s_skip should keep its value so we skip
line 78:     " any matching pair inside the syntax types.
line 79:     " Catch if this throws E363: pattern uses more memory than 'maxmempattern'.
line 80:     try
line 81:       execute 'if ' . s_skip . ' | let s_skip = "0" | endif'
line 81: if synstack(".", col("."))->indexof({_, id -> synIDattr(id, "name") =~? "string\\|character\\|singlequote\\|escape\\|symbol\\|comment"}) >= 0 | let s_skip = "0" | endif
line 81:  let s_skip = "0" | endif
line 81:  endif
line 82:     catch /^Vim\%((\a\+)\)\=:E363/
line 83:       " We won't find anything, so skip searching, should keep Vim responsive.
line 84:       return
line 85:     endtry
line 86:   endif
line 87: 
line 88:   " Limit the search to lines visible in the window.
line 89:   let stoplinebottom = line('w$')
line 90:   let stoplinetop = line('w0')
line 91:   if i % 2 == 0
line 92:     let stopline = stoplinebottom
line 93:   else
line 94:     let stopline = stoplinetop
line 95:   endif
line 96: 
line 97:   " Limit the search time to 300 msec to avoid a hang on very long lines.
line 98:   " This fails when a timeout is not supported.
line 99:   if mode() == 'i' || mode() == 'R'
line 100:     let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
line 101:   else
line 102:     let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
line 103:   endif
line 104:   try
line 105:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
line 106:   catch /E118/
line 107:     " Can't use the timeout, restrict the stopline a bit more to avoid taking
line 108:     " a long time on closed folds and long lines.
line 109:     " The "viewable" variables give a range in which we can scroll while
line 110:     " keeping the cursor at the same position.
line 111:     " adjustedScrolloff accounts for very large numbers of scrolloff.
line 112:     let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
line 113:     let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
line 114:     let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
line 115:     " one of these stoplines will be adjusted below, but the current values are
line 116:     " minimal boundaries within the current window
line 117:     if i % 2 == 0
line 118:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 119: ^Ilet stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
line 120: ^Ilet stopline = min([bottom_viewable, byte2line(stopbyte)])
line 121:       else
line 122: ^Ilet stopline = min([bottom_viewable, c_lnum + 100])
line 123:       endif
line 124:       let stoplinebottom = stopline
line 125:     else
line 126:       if has("byte_offset") && has("syntax_items") && &smc > 0
line 127: ^Ilet stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
line 128: ^Ilet stopline = max([top_viewable, byte2line(stopbyte)])
line 129:       else
line 130: ^Ilet stopline = max([top_viewable, c_lnum - 100])
line 131:       endif
line 132:       let stoplinetop = stopline
line 133:     endif
line 134:     let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
line 135:   endtry
line 136: 
line 137:   if before > 0
line 138:     if has_getcurpos
line 139:       call setpos('.', save_cursor)
line 140:     else
line 141:       call winrestview(save_cursor)
line 142:     endif
line 143:   endif
line 144: 
line 145:   " If a match is found setup match highlighting.
line 146:   if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
line 147:     if s:has_matchaddpos
line 148:       call add(w:matchparen_ids, matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10))
line 149:     else
line 150:       exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
line 152:       call add(w:matchparen_ids, 3)
line 153:     endif
line 154:     let w:paren_hl_on = 1
line 155:   endif
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing: unlet! b:keymap_name
Executing: unlet! b:keymap_name
Executing WinClosed Autocommands for "*"
autocommand <Lua 181: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:350>

Executing: 
Executing BufWinLeave Autocommands for "*"
autocommand <Lua 161: ~/.local/share/nvim/lazy/nvim-dap-ui/lua/dapui/windows/init.lua:107>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 146: ~/.local/share/nvim/lazy/dap-helper.nvim/lua/dap-helper/init.lua:79>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 544: ~/.local/share/nvim/lazy/nvim-tree.lua/lua/nvim-tree/explorer/init.lua:115>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 622: ~/.local/share/nvim/lazy/LuaSnip/lua/luasnip/config.lua:109>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 181: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:350>

Executing: 
Executing BufWinLeave Autocommands for "*"
autocommand <Lua 161: ~/.local/share/nvim/lazy/nvim-dap-ui/lua/dapui/windows/init.lua:107>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 146: ~/.local/share/nvim/lazy/dap-helper.nvim/lua/dap-helper/init.lua:79>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 544: ~/.local/share/nvim/lazy/nvim-tree.lua/lua/nvim-tree/explorer/init.lua:115>

Executing: 
Executing BufWipeout Autocommands for "*"
autocommand <Lua 622: ~/.local/share/nvim/lazy/LuaSnip/lua/luasnip/config.lua:109>

Executing: 
Executing FocusLost Autocommands for "*"
autocommand <Lua 197: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:68>

Executing: 
Executing CursorHold Autocommands for "<buffer=5>"
autocommand <Lua 588: ~/.local/share/nvim/lazy/nvim-ts-context-commentstring/lua/ts_context_commentstring/internal.lua:32>

Executing: 
Executing FocusGained Autocommands for "*"
autocommand <Lua 198: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:68>

Executing: 
Executing FocusLost Autocommands for "*"
autocommand <Lua 197: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:68>

Executing: 
Executing FocusGained Autocommands for "*"
autocommand <Lua 198: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:68>

Executing: 
Executing FocusLost Autocommands for "*"
autocommand <Lua 197: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:68>

Executing: 
Executing FocusGained Autocommands for "*"
autocommand <Lua 198: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:68>

Executing: 
Executing FocusLost Autocommands for "*"
autocommand <Lua 197: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:68>

Executing: 
Executing FocusGained Autocommands for "*"
autocommand <Lua 198: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:68>

Executing: 
Executing FocusLost Autocommands for "*"
autocommand <Lua 197: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:68>

Executing: 
Executing FocusGained Autocommands for "*"
autocommand <Lua 198: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:68>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing InsertEnter Autocommands for "*"
autocommand <Lua 35: ~/.local/share/nvim/lazy/lazy.nvim/lua/lazy/core/handler/event.lua:72>

Executing: augroup filetypedetect
Executing: augroup END
Executing: 
Executing InsertEnter Autocommands for "*"
autocommand <Lua 214: ~/.local/share/nvim/lazy/copilot-cmp/lua/copilot_cmp/init.lua:55>

Executing: 
Executing InsertEnter Autocommands for "*"
autocommand <Lua 304: ~/.local/share/nvim/lazy/cmp-nvim-lsp/lua/cmp_nvim_lsp/init.lua:97>

Executing: 
Executing InsertEnter Autocommands for "*"
autocommand <Lua 653: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing ModeChanged Autocommands for "*"
autocommand <Lua 199: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:93>

Executing: -- INSERT --

Executing: lua require"cmp.utils.feedkeys".run(1)
Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand <Lua 292: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMovedI Autocommands for "*"
autocommand <Lua 659: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing: highlight! lualine_transitional_lualine_a_insert_to_lualine_b_insert guifg=#3EFFDC guibg=#112638 gui=None
Searching for "autoload/nvim_treesitter.vim" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/autoload/nvim_treesitter.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/autoload/nvim_treesitter.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-autopairs/autoload/nvim_treesitter.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lint/autoload/nvim_treesitter.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lspkind.nvim/autoload/nvim_treesitter.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/friendly-snippets/autoload/nvim_treesitter.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/autoload/nvim_treesitter.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/autoload/nvim_treesitter.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/autoload/nvim_treesitter.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/autoload/nvim_treesitter.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/autoload/nvim_treesitter.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/autoload/nvim_treesitter.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/autoload/nvim_treesitter.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/autoload/nvim_treesitter.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/autoload/nvim_treesitter.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/autoload/nvim_treesitter.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/autoload/nvim_treesitter.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/autoload/nvim_treesitter.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/autoload/nvim_treesitter.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/autoload/nvim_treesitter.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/autoload/nvim_treesitter.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/autoload/nvim_treesitter.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/autoload/nvim_treesitter.vim"
sourcing "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/autoload/nvim_treesitter.vim"
line 1: function! nvim_treesitter#statusline(...) abort
line 4: 
line 5: function! nvim_treesitter#foldexpr() abort
line 8: 
line 9: function! nvim_treesitter#installable_parsers(arglead, cmdline, cursorpos) abort
line 12: 
line 13: function! nvim_treesitter#installed_parsers(arglead, cmdline, cursorpos) abort
line 16: 
line 17: function! nvim_treesitter#available_modules(arglead, cmdline, cursorpos) abort
line 20: 
line 21: function! nvim_treesitter#available_query_groups(arglead, cmdline, cursorpos) abort
line 24: 
line 25: function! nvim_treesitter#indent() abort
finished sourcing /Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/autoload/nvim_treesitter.vim
calling nvim_treesitter#indent()

line 1: ^Ireturn luaeval(printf('require"nvim-treesitter.indent".get_indent(%d)', v:lnum))
Searching for "queries/lua/indents.scm" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-autopairs/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lint/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lspkind.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/friendly-snippets/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/queries/lua/indents.scm"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/queries/lua/indents.scm"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/queries/lua/indents.scm"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/after/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/after/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/after/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/queries/lua/indents.scm"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/queries/lua/indents.scm"
nvim_treesitter#indent returning #12

Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand <Lua 292: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMovedI Autocommands for "*"
autocommand <Lua 659: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand <Lua 286: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing TextChangedI Autocommands for "*"
autocommand <Lua 642: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: 
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: 
Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand <Lua 292: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMovedI Autocommands for "*"
autocommand <Lua 659: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand <Lua 286: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing TextChangedI Autocommands for "*"
autocommand <Lua 642: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: 
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: 
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: 
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: 
Executing BufNew Autocommands for "*"
autocommand <Lua 219: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:135>

Executing: 
Executing FileType Autocommands for "*"
autocommand call s:LoadFTPlugin()

Executing: call s:LoadFTPlugin()
calling <SNR>2_LoadFTPlugin()

line 1:     if exists("b:undo_ftplugin")
line 2:       exe b:undo_ftplugin
line 3:       unlet! b:undo_ftplugin b:did_ftplugin
line 4:     endif
line 5: 
line 6:     let s = expand("<amatch>")
line 7:     if s != ""
line 8:       if &cpo =~# "S" && exists("b:did_ftplugin")
line 9: ^I" In compatible mode options are reset to the global values, need to
line 10: ^I" set the local values also when a plugin was already used.
line 11: ^Iunlet b:did_ftplugin
line 12:       endif
line 13: 
line 14:       " When there is a dot it is used to separate filetype names.  Thus for
line 15:       " "aaa.bbb" load "aaa" and then "bbb".
line 16:       for name in split(s, '\.')
line 17:         " Load Lua ftplugins after Vim ftplugins _per directory_
line 18:         " TODO(clason): use nvim__get_runtime when supports globs and modeline
line 19:         " XXX: "[.]" in the first pattern makes it a wildcard on Windows
line 20:         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
line 20: runtime! ftplugin/cmp_menu[.]{vim,lua} ftplugin/cmp_menu_*.{vim,lua} ftplugin/cmp_menu/*.{vim,lua}
Searching for "ftplugin/cmp_menu[.]{vim,lua} ftplugin/cmp_menu_*.{vim,lua} ftplugin/cmp_menu/*.{vim,lua}" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.config/nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.config/nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-autopairs/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-autopairs/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-autopairs/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lint/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lint/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lint/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lspkind.nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lspkind.nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lspkind.nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/friendly-snippets/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/friendly-snippets/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/friendly-snippets/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/after/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/after/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/after/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/after/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/after/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/after/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/after/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/after/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/after/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/ftplugin/cmp_menu/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/ftplugin/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/ftplugin/cmp_menu_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/ftplugin/cmp_menu/*.{vim,lua}"
not found in runtime path: "ftplugin/cmp_menu[.]{vim,lua} ftplugin/cmp_menu_*.{vim,lua} ftplugin/cmp_menu/*.{vim,lua}"
line 21:       endfor
line 16:       for name in split(s, '\.')
line 17:         " Load Lua ftplugins after Vim ftplugins _per directory_
line 18:         " TODO(clason): use nvim__get_runtime when supports globs and modeline
line 19:         " XXX: "[.]" in the first pattern makes it a wildcard on Windows
line 20:         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
line 21:       endfor
line 22:     endif
<SNR>2_LoadFTPlugin returning #0

continuing in FileType Autocommands for "*"

Executing FileType Autocommands for "*"
autocommand call s:LoadIndent()

Executing: call s:LoadIndent()
calling <SNR>3_LoadIndent()

line 1:     if exists("b:undo_indent")
line 2:       exe b:undo_indent
line 3:       unlet! b:undo_indent b:did_indent
line 4:     endif
line 5:     let s = expand("<amatch>")
line 6:     if s != ""
line 7:       if exists("b:did_indent")
line 8: ^Iunlet b:did_indent
line 9:       endif
line 10: 
line 11:       " When there is a dot it is used to separate filetype names.  Thus for
line 12:       " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
line 13:       for name in split(s, '\.')
line 14:         " XXX: "[.]" in the pattern makes it a wildcard on Windows
line 15:         exe $'runtime! indent/{name}[.]{{vim,lua}}'
line 15: runtime! indent/cmp_menu[.]{vim,lua}
Searching for "indent/cmp_menu[.]{vim,lua}" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-autopairs/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lint/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lspkind.nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/friendly-snippets/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/indent/cmp_menu[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/indent/cmp_menu[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/indent/cmp_menu[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/after/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/after/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/after/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/indent/cmp_menu[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/indent/cmp_menu[.]{vim,lua}"
not found in runtime path: "indent/cmp_menu[.]{vim,lua}"
line 16:       endfor
line 13:       for name in split(s, '\.')
line 14:         " XXX: "[.]" in the pattern makes it a wildcard on Windows
line 15:         exe $'runtime! indent/{name}[.]{{vim,lua}}'
line 16:       endfor
line 17:     endif
<SNR>3_LoadIndent returning #0

continuing in FileType Autocommands for "*"

Executing FileType Autocommands for "*"
autocommand if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif

Executing: if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  endif
Executing FileType Autocommands for "*"
autocommand if index(g:mkdp_filetypes, &filetype) !=# -1 | call s:init_command() | endif

Executing: if index(g:mkdp_filetypes, &filetype) !=# -1 | call s:init_command() | endif
Executing:  call s:init_command() | endif
Executing:  endif
Executing FileType Autocommands for "*"
autocommand <Lua 298: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/configs.lua:132>

Searching for "parser/cmp_menu.*" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-autopairs/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lint/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lspkind.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/friendly-snippets/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/cmp_menu.*"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/cmp_menu.*"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/cmp_menu.*"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/after/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/after/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/after/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/cmp_menu.*"
not found in runtime path: "parser/cmp_menu.*"
Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 297: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/configs.lua:132>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 296: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/configs.lua:132>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 299: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/configs.lua:132>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 454: ~/.local/share/nvim/lazy/nvim-ts-context-commentstring/plugin/ts_context_commentstring.lua:11>

Searching for "parser/cmp_menu.*" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-autopairs/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lint/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lspkind.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/friendly-snippets/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/cmp_menu.*"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/cmp_menu.*"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/cmp_menu.*"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/after/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/after/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/after/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/parser/cmp_menu.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/cmp_menu.*"
not found in runtime path: "parser/cmp_menu.*"
Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 288: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 518: vim/_editor.lua:0>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 620: ~/.local/share/nvim/lazy/LuaSnip/plugin/luasnip.lua:86>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 506: ~/.local/share/nvim/lazy/nvim-autopairs/lua/nvim-autopairs.lua:77>

Executing: 
Executing: unlet! b:keymap_name-- INSERT --
Executing BufNew Autocommands for "*"
autocommand <Lua 219: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:135>

Executing: 
Executing FileType Autocommands for "*"
autocommand call s:LoadFTPlugin()

Executing: call s:LoadFTPlugin()
calling <SNR>2_LoadFTPlugin()

line 1:     if exists("b:undo_ftplugin")
line 2:       exe b:undo_ftplugin
line 3:       unlet! b:undo_ftplugin b:did_ftplugin
line 4:     endif
line 5: 
line 6:     let s = expand("<amatch>")
line 7:     if s != ""
line 8:       if &cpo =~# "S" && exists("b:did_ftplugin")
line 9: ^I" In compatible mode options are reset to the global values, need to
line 10: ^I" set the local values also when a plugin was already used.
line 11: ^Iunlet b:did_ftplugin
line 12:       endif
line 13: 
line 14:       " When there is a dot it is used to separate filetype names.  Thus for
line 15:       " "aaa.bbb" load "aaa" and then "bbb".
line 16:       for name in split(s, '\.')
line 17:         " Load Lua ftplugins after Vim ftplugins _per directory_
line 18:         " TODO(clason): use nvim__get_runtime when supports globs and modeline
line 19:         " XXX: "[.]" in the first pattern makes it a wildcard on Windows
line 20:         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
line 20: runtime! ftplugin/cmp_docs[.]{vim,lua} ftplugin/cmp_docs_*.{vim,lua} ftplugin/cmp_docs/*.{vim,lua}
Searching for "ftplugin/cmp_docs[.]{vim,lua} ftplugin/cmp_docs_*.{vim,lua} ftplugin/cmp_docs/*.{vim,lua}" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.config/nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.config/nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-autopairs/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-autopairs/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-autopairs/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lint/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lint/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lint/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lspkind.nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lspkind.nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lspkind.nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/friendly-snippets/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/friendly-snippets/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/friendly-snippets/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/after/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/after/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/after/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/after/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/after/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/after/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/after/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/after/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/after/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/ftplugin/cmp_docs/*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/ftplugin/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/ftplugin/cmp_docs_*.{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/ftplugin/cmp_docs/*.{vim,lua}"
not found in runtime path: "ftplugin/cmp_docs[.]{vim,lua} ftplugin/cmp_docs_*.{vim,lua} ftplugin/cmp_docs/*.{vim,lua}"
line 21:       endfor
line 16:       for name in split(s, '\.')
line 17:         " Load Lua ftplugins after Vim ftplugins _per directory_
line 18:         " TODO(clason): use nvim__get_runtime when supports globs and modeline
line 19:         " XXX: "[.]" in the first pattern makes it a wildcard on Windows
line 20:         exe $'runtime! ftplugin/{name}[.]{{vim,lua}} ftplugin/{name}_*.{{vim,lua}} ftplugin/{name}/*.{{vim,lua}}'
line 21:       endfor
line 22:     endif
<SNR>2_LoadFTPlugin returning #0

continuing in FileType Autocommands for "*"

Executing FileType Autocommands for "*"
autocommand call s:LoadIndent()

Executing: call s:LoadIndent()
calling <SNR>3_LoadIndent()

line 1:     if exists("b:undo_indent")
line 2:       exe b:undo_indent
line 3:       unlet! b:undo_indent b:did_indent
line 4:     endif
line 5:     let s = expand("<amatch>")
line 6:     if s != ""
line 7:       if exists("b:did_indent")
line 8: ^Iunlet b:did_indent
line 9:       endif
line 10: 
line 11:       " When there is a dot it is used to separate filetype names.  Thus for
line 12:       " "aaa.bbb" load "indent/aaa.vim" and then "indent/bbb.vim".
line 13:       for name in split(s, '\.')
line 14:         " XXX: "[.]" in the pattern makes it a wildcard on Windows
line 15:         exe $'runtime! indent/{name}[.]{{vim,lua}}'
line 15: runtime! indent/cmp_docs[.]{vim,lua}
Searching for "indent/cmp_docs[.]{vim,lua}" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-autopairs/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lint/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lspkind.nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/friendly-snippets/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/indent/cmp_docs[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/indent/cmp_docs[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/indent/cmp_docs[.]{vim,lua}"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/after/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/after/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/after/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/indent/cmp_docs[.]{vim,lua}"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/indent/cmp_docs[.]{vim,lua}"
not found in runtime path: "indent/cmp_docs[.]{vim,lua}"
line 16:       endfor
line 13:       for name in split(s, '\.')
line 14:         " XXX: "[.]" in the pattern makes it a wildcard on Windows
line 15:         exe $'runtime! indent/{name}[.]{{vim,lua}}'
line 16:       endfor
line 17:     endif
<SNR>3_LoadIndent returning #0

continuing in FileType Autocommands for "*"

Executing FileType Autocommands for "*"
autocommand if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif

Executing: if !exists('b:ts_highlight') | 0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  0verbose exe "set syntax=" . expand("<amatch>") | endif
Executing:  endif
Executing FileType Autocommands for "*"
autocommand if index(g:mkdp_filetypes, &filetype) !=# -1 | call s:init_command() | endif

Executing: if index(g:mkdp_filetypes, &filetype) !=# -1 | call s:init_command() | endif
Executing:  call s:init_command() | endif
Executing:  endif
Executing FileType Autocommands for "*"
autocommand <Lua 298: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/configs.lua:132>

Searching for "parser/cmp_docs.*" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-autopairs/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lint/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lspkind.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/friendly-snippets/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/cmp_docs.*"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/cmp_docs.*"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/cmp_docs.*"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/after/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/after/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/after/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/cmp_docs.*"
not found in runtime path: "parser/cmp_docs.*"
Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 297: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/configs.lua:132>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 296: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/configs.lua:132>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 299: ~/.local/share/nvim/lazy/nvim-treesitter/lua/nvim-treesitter/configs.lua:132>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 454: ~/.local/share/nvim/lazy/nvim-ts-context-commentstring/plugin/ts_context_commentstring.lua:11>

Searching for "parser/cmp_docs.*" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-autopairs/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lint/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lspkind.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/friendly-snippets/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/parser/cmp_docs.*"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/parser/cmp_docs.*"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/parser/cmp_docs.*"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/after/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/after/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/after/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/parser/cmp_docs.*"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/parser/cmp_docs.*"
not found in runtime path: "parser/cmp_docs.*"
Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 288: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 518: vim/_editor.lua:0>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 620: ~/.local/share/nvim/lazy/LuaSnip/plugin/luasnip.lua:86>

Executing: 
Executing FileType Autocommands for "*"
autocommand <Lua 506: ~/.local/share/nvim/lazy/nvim-autopairs/lua/nvim-autopairs.lua:77>

Executing: 
Executing: syntax clear
Searching for "syntax/lua.vim" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-autopairs/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lint/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lspkind.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/friendly-snippets/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/syntax/lua.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/lua.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/syntax/lua.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/after/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/after/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/after/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/syntax/lua.vim"
Executing: syntax include @LUA syntax/lua.vim
Searching for "syntax/lua.vim" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-autopairs/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lint/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lspkind.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/friendly-snippets/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/syntax/lua.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/lua.vim"
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/lua.vim"
line 1: " Vim syntax file
line 2: " Language:     Lua 4.0, Lua 5.0, Lua 5.1, Lua 5.2 and Lua 5.3
line 3: " Maintainer:   Marcus Aurelius Farias <masserahguard-lua 'at' yahoo com>
line 4: " First Author: Carlos Augusto Teixeira Mendes <cmendes 'at' inf puc-rio br>
line 5: " Last Change:  2022 Sep 07
line 6: " Options:      lua_version = 4 or 5
line 7: "               lua_subversion = 0 (for 4.0 or 5.0)
line 8: "                               or 1, 2, 3 (for 5.1, 5.2 or 5.3)
line 9: "               the default is 5.3
line 10: 
line 11: " quit when a syntax file was already loaded
line 12: if exists("b:current_syntax")
line 13:   finish
line 14: endif
line 15: 
line 16: let s:cpo_save = &cpo
line 17: set cpo&vim
line 18: 
line 19: if !exists("lua_version")
line 20:   " Default is lua 5.3
line 21:   let lua_version = 5
line 22:   let lua_subversion = 3
line 23: elseif !exists("lua_subversion")
line 24:   " lua_version exists, but lua_subversion doesn't. In this case set it to 0
line 25:   let lua_subversion = 0
line 26: endif
line 27: 
line 28: syn case match
line 29: 
line 30: " syncing method
line 31: syn sync minlines=1000
line 32: 
line 33: if lua_version >= 5
line 34:   syn keyword luaMetaMethod __add __sub __mul __div __pow __unm __concat
line 35:   syn keyword luaMetaMethod __eq __lt __le
line 36:   syn keyword luaMetaMethod __index __newindex __call
line 37:   syn keyword luaMetaMethod __metatable __mode __gc __tostring
line 38: endif
line 39: 
line 40: if lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
line 41:   syn keyword luaMetaMethod __mod __len
line 42: endif
line 43: 
line 44: if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
line 45:   syn keyword luaMetaMethod __pairs
line 46: endif
line 47: 
line 48: if lua_version > 5 || (lua_version == 5 && lua_subversion >= 3)
line 49:   syn keyword luaMetaMethod __idiv __name
line 50:   syn keyword luaMetaMethod __band __bor __bxor __bnot __shl __shr
line 51: endif
line 52: 
line 53: if lua_version > 5 || (lua_version == 5 && lua_subversion >= 4)
line 54:   syn keyword luaMetaMethod __close
line 55: endif
line 56: 
line 57: " catch errors caused by wrong parenthesis and wrong curly brackets or
line 58: " keywords placed outside their respective blocks
line 59: 
line 60: syn region luaParen transparent start='(' end=')' contains=TOP,luaParenError
line 61: syn match  luaParenError ")"
line 62: syn match  luaError "}"
line 63: syn match  luaError "\<\%(end\|else\|elseif\|then\|until\|in\)\>"
line 64: 
line 65: " Function declaration
line 66: syn region luaFunctionBlock transparent matchgroup=luaFunction start="\<function\>" end="\<end\>" contains=TOP
line 67: 
line 68: " else
line 69: syn keyword luaCondElse matchgroup=luaCond contained containedin=luaCondEnd else
line 70: 
line 71: " then ... end
line 72: syn region luaCondEnd contained transparent matchgroup=luaCond start="\<then\>" end="\<end\>" contains=TOP
line 73: 
line 74: " elseif ... then
line 75: syn region luaCondElseif contained containedin=luaCondEnd transparent matchgroup=luaCond start="\<elseif\>" end="\<then\>" contains=TOP
line 76: 
line 77: " if ... then
line 78: syn region luaCondStart transparent matchgroup=luaCond start="\<if\>" end="\<then\>"me=e-4 contains=TOP nextgroup=luaCondEnd skipwhite skipempty
line 79: 
line 80: " do ... end
line 81: syn region luaBlock transparent matchgroup=luaStatement start="\<do\>" end="\<end\>" contains=TOP
line 82: " repeat ... until
line 83: syn region luaRepeatBlock transparent matchgroup=luaRepeat start="\<repeat\>" end="\<until\>" contains=TOP
line 84: 
line 85: " while ... do
line 86: syn region luaWhile transparent matchgroup=luaRepeat start="\<while\>" end="\<do\>"me=e-2 contains=TOP nextgroup=luaBlock skipwhite skipempty
line 87: 
line 88: " for ... do and for ... in ... do
line 89: syn region luaFor transparent matchgroup=luaRepeat start="\<for\>" end="\<do\>"me=e-2 contains=TOP nextgroup=luaBlock skipwhite skipempty
line 90: 
line 91: syn keyword luaFor contained containedin=luaFor in
line 92: 
line 93: " other keywords
line 94: syn keyword luaStatement return local break
line 95: if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
line 96:   syn keyword luaStatement goto
line 97:   syn match luaLabel "::\I\i*::"
line 98: endif
line 99: 
line 100: " operators
line 101: syn keyword luaOperator and or not
line 102: 
line 103: if (lua_version == 5 && lua_subversion >= 3) || lua_version > 5
line 104:   syn match luaSymbolOperator "[#<>=~^&|*/%+-]\|\.\{2,3}"
line 105: elseif lua_version == 5 && (lua_subversion == 1 || lua_subversion == 2)
line 106:   syn match luaSymbolOperator "[#<>=~^*/%+-]\|\.\{2,3}"
line 107: else
line 108:   syn match luaSymbolOperator "[<>=~^*/+-]\|\.\{2,3}"
line 109: endif
line 110: 
line 111: " comments
line 112: syn keyword luaTodo            contained TODO FIXME XXX
line 113: syn match   luaComment         "--.*$" contains=luaTodo,@Spell
line 114: if lua_version == 5 && lua_subversion == 0
line 115:   syn region luaComment        matchgroup=luaCommentDelimiter start="--\[\[" end="\]\]" contains=luaTodo,luaInnerComment,@Spell
line 116:   syn region luaInnerComment   contained transparent start="\[\[" end="\]\]"
line 117: elseif lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
line 118:   " Comments in Lua 5.1: --[[ ... ]], [=[ ... ]=], [===[ ... ]===], etc.
line 119:   syn region luaComment        matchgroup=luaCommentDelimiter start="--\[\z(=*\)\[" end="\]\z1\]" contains=luaTodo,@Spell
line 120: endif
line 121: 
line 122: " first line may start with #!
line 123: syn match luaComment "\%^#!.*"
line 124: 
line 125: syn keyword luaConstant nil
line 126: if lua_version > 4
line 127:   syn keyword luaConstant true false
line 128: endif
line 129: 
line 130: " strings
line 131: syn match  luaSpecial contained #\\[\\abfnrtv'"[\]]\|\\[[:digit:]]\{,3}#
line 132: if lua_version == 5
line 133:   if lua_subversion == 0
line 134:     syn region luaString2 matchgroup=luaStringDelimiter start=+\[\[+ end=+\]\]+ contains=luaString2,@Spell
line 135:   else
line 136:     if lua_subversion >= 2
line 137:       syn match  luaSpecial contained #\\z\|\\x[[:xdigit:]]\{2}#
line 138:     endif
line 139:     if lua_subversion >= 3
line 140:       syn match  luaSpecial contained #\\u{[[:xdigit:]]\+}#
line 141:     endif
line 142:     syn region luaString2 matchgroup=luaStringDelimiter start="\[\z(=*\)\[" end="\]\z1\]" contains=@Spell
line 143:   endif
line 144: endif
line 145: syn region luaString matchgroup=luaStringDelimiter start=+'+ end=+'+ skip=+\\\\\|\\'+ contains=luaSpecial,@Spell
line 146: syn region luaString matchgroup=luaStringDelimiter start=+"+ end=+"+ skip=+\\\\\|\\"+ contains=luaSpecial,@Spell
line 147: 
line 148: " integer number
line 149: syn match luaNumber "\<\d\+\>"
line 150: " floating point number, with dot, optional exponent
line 151: syn match luaNumber  "\<\d\+\.\d*\%([eE][-+]\=\d\+\)\="
line 152: " floating point number, starting with a dot, optional exponent
line 153: syn match luaNumber  "\.\d\+\%([eE][-+]\=\d\+\)\=\>"
line 154: " floating point number, without dot, with exponent
line 155: syn match luaNumber  "\<\d\+[eE][-+]\=\d\+\>"
line 156: 
line 157: " hex numbers
line 158: if lua_version >= 5
line 159:   if lua_subversion == 1
line 160:     syn match luaNumber "\<0[xX]\x\+\>"
line 161:   elseif lua_subversion >= 2
line 162:     syn match luaNumber "\<0[xX][[:xdigit:].]\+\%([pP][-+]\=\d\+\)\=\>"
line 163:   endif
line 164: endif
line 165: 
line 166: " tables
line 167: syn region luaTableBlock transparent matchgroup=luaTable start="{" end="}" contains=TOP,luaStatement
line 168: 
line 169: " methods
line 170: syntax match luaFunc ":\@<=\k\+"
line 171: 
line 172: " built-in functions
line 173: syn keyword luaFunc assert collectgarbage dofile error next
line 174: syn keyword luaFunc print rawget rawset self tonumber tostring type _VERSION
line 175: 
line 176: if lua_version == 4
line 177:   syn keyword luaFunc _ALERT _ERRORMESSAGE gcinfo
line 178:   syn keyword luaFunc call copytagmethods dostring
line 179:   syn keyword luaFunc foreach foreachi getglobal getn
line 180:   syn keyword luaFunc gettagmethod globals newtag
line 181:   syn keyword luaFunc setglobal settag settagmethod sort
line 182:   syn keyword luaFunc tag tinsert tremove
line 183:   syn keyword luaFunc _INPUT _OUTPUT _STDIN _STDOUT _STDERR
line 184:   syn keyword luaFunc openfile closefile flush seek
line 185:   syn keyword luaFunc setlocale execute remove rename tmpname
line 186:   syn keyword luaFunc getenv date clock exit
line 187:   syn keyword luaFunc readfrom writeto appendto read write
line 188:   syn keyword luaFunc PI abs sin cos tan asin
line 189:   syn keyword luaFunc acos atan atan2 ceil floor
line 190:   syn keyword luaFunc mod frexp ldexp sqrt min max log
line 191:   syn keyword luaFunc log10 exp deg rad random
line 192:   syn keyword luaFunc randomseed strlen strsub strlower strupper
line 193:   syn keyword luaFunc strchar strrep ascii strbyte
line 194:   syn keyword luaFunc format strfind gsub
line 195:   syn keyword luaFunc getinfo getlocal setlocal setcallhook setlinehook
line 196: elseif lua_version == 5
line 197:   syn keyword luaFunc getmetatable setmetatable
line 198:   syn keyword luaFunc ipairs pairs
line 199:   syn keyword luaFunc pcall xpcall
line 200:   syn keyword luaFunc _G loadfile rawequal require
line 201:   if lua_subversion == 0
line 202:     syn keyword luaFunc getfenv setfenv
line 203:     syn keyword luaFunc loadstring unpack
line 204:     syn keyword luaFunc gcinfo loadlib LUA_PATH _LOADED _REQUIREDNAME
line 205:   else
line 206:     syn keyword luaFunc load select
line 207:     syn match   luaFunc /\<package\.cpath\>/
line 208:     syn match   luaFunc /\<package\.loaded\>/
line 209:     syn match   luaFunc /\<package\.loadlib\>/
line 210:     syn match   luaFunc /\<package\.path\>/
line 211:     syn match   luaFunc /\<package\.preload\>/
line 212:     if lua_subversion == 1
line 213:       syn keyword luaFunc getfenv setfenv
line 214:       syn keyword luaFunc loadstring module unpack
line 215:       syn match   luaFunc /\<package\.loaders\>/
line 216:       syn match   luaFunc /\<package\.seeall\>/
line 217:     elseif lua_subversion >= 2
line 218:       syn keyword luaFunc _ENV rawlen
line 219:       syn match   luaFunc /\<package\.config\>/
line 220:       syn match   luaFunc /\<package\.preload\>/
line 221:       syn match   luaFunc /\<package\.searchers\>/
line 222:       syn match   luaFunc /\<package\.searchpath\>/
line 223:     endif
line 224: 
line 225:     if lua_subversion >= 3
line 226:       syn match luaFunc /\<coroutine\.isyieldable\>/
line 227:     endif
line 228:     if lua_subversion >= 4
line 229:       syn keyword luaFunc warn
line 230:       syn match luaFunc /\<coroutine\.close\>/
line 231:     endif
line 232:     syn match luaFunc /\<coroutine\.running\>/
line 233:   endif
line 234:   syn match   luaFunc /\<coroutine\.create\>/
line 235:   syn match   luaFunc /\<coroutine\.resume\>/
line 236:   syn match   luaFunc /\<coroutine\.status\>/
line 237:   syn match   luaFunc /\<coroutine\.wrap\>/
line 238:   syn match   luaFunc /\<coroutine\.yield\>/
line 239: 
line 240:   syn match   luaFunc /\<string\.byte\>/
line 241:   syn match   luaFunc /\<string\.char\>/
line 242:   syn match   luaFunc /\<string\.dump\>/
line 243:   syn match   luaFunc /\<string\.find\>/
line 244:   syn match   luaFunc /\<string\.format\>/
line 245:   syn match   luaFunc /\<string\.gsub\>/
line 246:   syn match   luaFunc /\<string\.len\>/
line 247:   syn match   luaFunc /\<string\.lower\>/
line 248:   syn match   luaFunc /\<string\.rep\>/
line 249:   syn match   luaFunc /\<string\.sub\>/
line 250:   syn match   luaFunc /\<string\.upper\>/
line 251:   if lua_subversion == 0
line 252:     syn match luaFunc /\<string\.gfind\>/
line 253:   else
line 254:     syn match luaFunc /\<string\.gmatch\>/
line 255:     syn match luaFunc /\<string\.match\>/
line 256:     syn match luaFunc /\<string\.reverse\>/
line 257:   endif
line 258:   if lua_subversion >= 3
line 259:     syn match luaFunc /\<string\.pack\>/
line 260:     syn match luaFunc /\<string\.packsize\>/
line 261:     syn match luaFunc /\<string\.unpack\>/
line 262:     syn match luaFunc /\<utf8\.char\>/
line 263:     syn match luaFunc /\<utf8\.charpattern\>/
line 264:     syn match luaFunc /\<utf8\.codes\>/
line 265:     syn match luaFunc /\<utf8\.codepoint\>/
line 266:     syn match luaFunc /\<utf8\.len\>/
line 267:     syn match luaFunc /\<utf8\.offset\>/
line 268:   endif
line 269: 
line 270:   if lua_subversion == 0
line 271:     syn match luaFunc /\<table\.getn\>/
line 272:     syn match luaFunc /\<table\.setn\>/
line 273:     syn match luaFunc /\<table\.foreach\>/
line 274:     syn match luaFunc /\<table\.foreachi\>/
line 275:   elseif lua_subversion == 1
line 276:     syn match luaFunc /\<table\.maxn\>/
line 277:   elseif lua_subversion >= 2
line 278:     syn match luaFunc /\<table\.pack\>/
line 279:     syn match luaFunc /\<table\.unpack\>/
line 280:     if lua_subversion >= 3
line 281:       syn match luaFunc /\<table\.move\>/
line 282:     endif
line 283:   endif
line 284:   syn match   luaFunc /\<table\.concat\>/
line 285:   syn match   luaFunc /\<table\.insert\>/
line 286:   syn match   luaFunc /\<table\.sort\>/
line 287:   syn match   luaFunc /\<table\.remove\>/
line 288: 
line 289:   if lua_subversion == 2
line 290:     syn match   luaFunc /\<bit32\.arshift\>/
line 291:     syn match   luaFunc /\<bit32\.band\>/
line 292:     syn match   luaFunc /\<bit32\.bnot\>/
line 293:     syn match   luaFunc /\<bit32\.bor\>/
line 294:     syn match   luaFunc /\<bit32\.btest\>/
line 295:     syn match   luaFunc /\<bit32\.bxor\>/
line 296:     syn match   luaFunc /\<bit32\.extract\>/
line 297:     syn match   luaFunc /\<bit32\.lrotate\>/
line 298:     syn match   luaFunc /\<bit32\.lshift\>/
line 299:     syn match   luaFunc /\<bit32\.replace\>/
line 300:     syn match   luaFunc /\<bit32\.rrotate\>/
line 301:     syn match   luaFunc /\<bit32\.rshift\>/
line 302:   endif
line 303: 
line 304:   syn match   luaFunc /\<math\.abs\>/
line 305:   syn match   luaFunc /\<math\.acos\>/
line 306:   syn match   luaFunc /\<math\.asin\>/
line 307:   syn match   luaFunc /\<math\.atan\>/
line 308:   if lua_subversion < 3
line 309:     syn match   luaFunc /\<math\.atan2\>/
line 310:   endif
line 311:   syn match   luaFunc /\<math\.ceil\>/
line 312:   syn match   luaFunc /\<math\.sin\>/
line 313:   syn match   luaFunc /\<math\.cos\>/
line 314:   syn match   luaFunc /\<math\.tan\>/
line 315:   syn match   luaFunc /\<math\.deg\>/
line 316:   syn match   luaFunc /\<math\.exp\>/
line 317:   syn match   luaFunc /\<math\.floor\>/
line 318:   syn match   luaFunc /\<math\.log\>/
line 319:   syn match   luaFunc /\<math\.max\>/
line 320:   syn match   luaFunc /\<math\.min\>/
line 321:   if lua_subversion == 0
line 322:     syn match luaFunc /\<math\.mod\>/
line 323:     syn match luaFunc /\<math\.log10\>/
line 324:   elseif lua_subversion == 1
line 325:     syn match luaFunc /\<math\.log10\>/
line 326:   endif
line 327:   if lua_subversion >= 1
line 328:     syn match luaFunc /\<math\.huge\>/
line 329:     syn match luaFunc /\<math\.fmod\>/
line 330:     syn match luaFunc /\<math\.modf\>/
line 331:     if lua_subversion == 1 || lua_subversion == 2
line 332:       syn match luaFunc /\<math\.cosh\>/
line 333:       syn match luaFunc /\<math\.sinh\>/
line 334:       syn match luaFunc /\<math\.tanh\>/
line 335:     endif
line 336:   endif
line 337:   syn match   luaFunc /\<math\.rad\>/
line 338:   syn match   luaFunc /\<math\.sqrt\>/
line 339:   if lua_subversion < 3
line 340:     syn match   luaFunc /\<math\.pow\>/
line 341:     syn match   luaFunc /\<math\.frexp\>/
line 342:     syn match   luaFunc /\<math\.ldexp\>/
line 343:   else
line 344:     syn match   luaFunc /\<math\.maxinteger\>/
line 345:     syn match   luaFunc /\<math\.mininteger\>/
line 346:     syn match   luaFunc /\<math\.tointeger\>/
line 347:     syn match   luaFunc /\<math\.type\>/
line 348:     syn match   luaFunc /\<math\.ult\>/
line 349:   endif
line 350:   syn match   luaFunc /\<math\.random\>/
line 351:   syn match   luaFunc /\<math\.randomseed\>/
line 352:   syn match   luaFunc /\<math\.pi\>/
line 353: 
line 354:   syn match   luaFunc /\<io\.close\>/
line 355:   syn match   luaFunc /\<io\.flush\>/
line 356:   syn match   luaFunc /\<io\.input\>/
line 357:   syn match   luaFunc /\<io\.lines\>/
line 358:   syn match   luaFunc /\<io\.open\>/
line 359:   syn match   luaFunc /\<io\.output\>/
line 360:   syn match   luaFunc /\<io\.popen\>/
line 361:   syn match   luaFunc /\<io\.read\>/
line 362:   syn match   luaFunc /\<io\.stderr\>/
line 363:   syn match   luaFunc /\<io\.stdin\>/
line 364:   syn match   luaFunc /\<io\.stdout\>/
line 365:   syn match   luaFunc /\<io\.tmpfile\>/
line 366:   syn match   luaFunc /\<io\.type\>/
line 367:   syn match   luaFunc /\<io\.write\>/
line 368: 
line 369:   syn match   luaFunc /\<os\.clock\>/
line 370:   syn match   luaFunc /\<os\.date\>/
line 371:   syn match   luaFunc /\<os\.difftime\>/
line 372:   syn match   luaFunc /\<os\.execute\>/
line 373:   syn match   luaFunc /\<os\.exit\>/
line 374:   syn match   luaFunc /\<os\.getenv\>/
line 375:   syn match   luaFunc /\<os\.remove\>/
line 376:   syn match   luaFunc /\<os\.rename\>/
line 377:   syn match   luaFunc /\<os\.setlocale\>/
line 378:   syn match   luaFunc /\<os\.time\>/
line 379:   syn match   luaFunc /\<os\.tmpname\>/
line 380: 
line 381:   syn match   luaFunc /\<debug\.debug\>/
line 382:   syn match   luaFunc /\<debug\.gethook\>/
line 383:   syn match   luaFunc /\<debug\.getinfo\>/
line 384:   syn match   luaFunc /\<debug\.getlocal\>/
line 385:   syn match   luaFunc /\<debug\.getupvalue\>/
line 386:   syn match   luaFunc /\<debug\.setlocal\>/
line 387:   syn match   luaFunc /\<debug\.setupvalue\>/
line 388:   syn match   luaFunc /\<debug\.sethook\>/
line 389:   syn match   luaFunc /\<debug\.traceback\>/
line 390:   if lua_subversion == 1
line 391:     syn match luaFunc /\<debug\.getfenv\>/
line 392:     syn match luaFunc /\<debug\.setfenv\>/
line 393:   endif
line 394:   if lua_subversion >= 1
line 395:     syn match luaFunc /\<debug\.getmetatable\>/
line 396:     syn match luaFunc /\<debug\.setmetatable\>/
line 397:     syn match luaFunc /\<debug\.getregistry\>/
line 398:     if lua_subversion >= 2
line 399:       syn match luaFunc /\<debug\.getuservalue\>/
line 400:       syn match luaFunc /\<debug\.setuservalue\>/
line 401:       syn match luaFunc /\<debug\.upvalueid\>/
line 402:       syn match luaFunc /\<debug\.upvaluejoin\>/
line 403:     endif
line 404:     if lua_subversion >= 4
line 405:       syn match luaFunc /\<debug.setcstacklimit\>/
line 406:     endif
line 407:   endif
line 408: endif
line 409: 
line 410: " Define the default highlighting.
line 411: " Only when an item doesn't have highlighting yet
line 412: 
line 413: hi def link luaStatement        Statement
line 414: hi def link luaRepeat           Repeat
line 415: hi def link luaFor              Repeat
line 416: hi def link luaString           String
line 417: hi def link luaString2          String
line 418: hi def link luaStringDelimiter  luaString
line 419: hi def link luaNumber           Number
line 420: hi def link luaOperator         Operator
line 421: hi def link luaSymbolOperator   luaOperator
line 422: hi def link luaConstant         Constant
line 423: hi def link luaCond             Conditional
line 424: hi def link luaCondElse         Conditional
line 425: hi def link luaFunction         Function
line 426: hi def link luaMetaMethod       Function
line 427: hi def link luaComment          Comment
line 428: hi def link luaCommentDelimiter luaComment
line 429: hi def link luaTodo             Todo
line 430: hi def link luaTable            Structure
line 431: hi def link luaError            Error
line 432: hi def link luaParenError       Error
line 433: hi def link luaSpecial          SpecialChar
line 434: hi def link luaFunc             Identifier
line 435: hi def link luaLabel            Label
line 436: 
line 437: 
line 438: let b:current_syntax = "lua"
line 439: 
line 440: let &cpo = s:cpo_save
line 441: unlet s:cpo_save
line 442: " vim: et ts=8 sw=2
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/lua.vim
continuing in nvim_exec2()
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/syntax/lua.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/after/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/after/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/after/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/syntax/lua.vim"
Executing: syntax region lua1 start=+\%1l+ end=+\%4l+ contains=@LUA keepend
Executing: unlet! b:keymap_name-- INSERT --
Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand <Lua 292: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMovedI Autocommands for "*"
autocommand <Lua 659: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand <Lua 286: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing TextChangedI Autocommands for "*"
autocommand <Lua 642: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: 
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: 
Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand <Lua 292: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMovedI Autocommands for "*"
autocommand <Lua 659: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand <Lua 286: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing TextChangedI Autocommands for "*"
autocommand <Lua 642: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: 
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: -- INSERT --
Executing: syntax clear
Searching for "syntax/lua.vim" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-autopairs/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lint/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lspkind.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/friendly-snippets/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/syntax/lua.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/lua.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/syntax/lua.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/after/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/after/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/after/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/syntax/lua.vim"
Executing: syntax include @LUA syntax/lua.vim
Searching for "syntax/lua.vim" in runtime path
Searching for "/Users/jkulrativid/.config/nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lazy.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-autopairs/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lint/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lspkind.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/friendly-snippets/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/LuaSnip/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot.lua/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-cmp/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/substitute.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-context-commentstring/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/Comment.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/gitsigns.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/neodev.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lsp-file-operations/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-lspconfig/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-ts-autotag/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-treesitter/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/todo-comments.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/conform.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-surround/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-tree.lua/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/markdown-preview.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dressing.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/which-key.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/alpha-nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-cmp/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/copilot-lualine/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lualine.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/vim-tmux-navigator/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-fzf-native.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-dap.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope-ui-select.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/plenary.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/telescope.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/auto-session/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/lsp_lines.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/dap-helper.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-nio/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-virtual-text/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-dap-ui/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/nvim-web-devicons/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/bufferline.nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/syntax/lua.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/lua.vim"
line 0: sourcing "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/lua.vim"
line 1: " Vim syntax file
line 2: " Language:     Lua 4.0, Lua 5.0, Lua 5.1, Lua 5.2 and Lua 5.3
line 3: " Maintainer:   Marcus Aurelius Farias <masserahguard-lua 'at' yahoo com>
line 4: " First Author: Carlos Augusto Teixeira Mendes <cmendes 'at' inf puc-rio br>
line 5: " Last Change:  2022 Sep 07
line 6: " Options:      lua_version = 4 or 5
line 7: "               lua_subversion = 0 (for 4.0 or 5.0)
line 8: "                               or 1, 2, 3 (for 5.1, 5.2 or 5.3)
line 9: "               the default is 5.3
line 10: 
line 11: " quit when a syntax file was already loaded
line 12: if exists("b:current_syntax")
line 13:   finish
line 14: endif
line 15: 
line 16: let s:cpo_save = &cpo
line 17: set cpo&vim
line 18: 
line 19: if !exists("lua_version")
line 20:   " Default is lua 5.3
line 21:   let lua_version = 5
line 22:   let lua_subversion = 3
line 23: elseif !exists("lua_subversion")
line 24:   " lua_version exists, but lua_subversion doesn't. In this case set it to 0
line 25:   let lua_subversion = 0
line 26: endif
line 27: 
line 28: syn case match
line 29: 
line 30: " syncing method
line 31: syn sync minlines=1000
line 32: 
line 33: if lua_version >= 5
line 34:   syn keyword luaMetaMethod __add __sub __mul __div __pow __unm __concat
line 35:   syn keyword luaMetaMethod __eq __lt __le
line 36:   syn keyword luaMetaMethod __index __newindex __call
line 37:   syn keyword luaMetaMethod __metatable __mode __gc __tostring
line 38: endif
line 39: 
line 40: if lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
line 41:   syn keyword luaMetaMethod __mod __len
line 42: endif
line 43: 
line 44: if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
line 45:   syn keyword luaMetaMethod __pairs
line 46: endif
line 47: 
line 48: if lua_version > 5 || (lua_version == 5 && lua_subversion >= 3)
line 49:   syn keyword luaMetaMethod __idiv __name
line 50:   syn keyword luaMetaMethod __band __bor __bxor __bnot __shl __shr
line 51: endif
line 52: 
line 53: if lua_version > 5 || (lua_version == 5 && lua_subversion >= 4)
line 54:   syn keyword luaMetaMethod __close
line 55: endif
line 56: 
line 57: " catch errors caused by wrong parenthesis and wrong curly brackets or
line 58: " keywords placed outside their respective blocks
line 59: 
line 60: syn region luaParen transparent start='(' end=')' contains=TOP,luaParenError
line 61: syn match  luaParenError ")"
line 62: syn match  luaError "}"
line 63: syn match  luaError "\<\%(end\|else\|elseif\|then\|until\|in\)\>"
line 64: 
line 65: " Function declaration
line 66: syn region luaFunctionBlock transparent matchgroup=luaFunction start="\<function\>" end="\<end\>" contains=TOP
line 67: 
line 68: " else
line 69: syn keyword luaCondElse matchgroup=luaCond contained containedin=luaCondEnd else
line 70: 
line 71: " then ... end
line 72: syn region luaCondEnd contained transparent matchgroup=luaCond start="\<then\>" end="\<end\>" contains=TOP
line 73: 
line 74: " elseif ... then
line 75: syn region luaCondElseif contained containedin=luaCondEnd transparent matchgroup=luaCond start="\<elseif\>" end="\<then\>" contains=TOP
line 76: 
line 77: " if ... then
line 78: syn region luaCondStart transparent matchgroup=luaCond start="\<if\>" end="\<then\>"me=e-4 contains=TOP nextgroup=luaCondEnd skipwhite skipempty
line 79: 
line 80: " do ... end
line 81: syn region luaBlock transparent matchgroup=luaStatement start="\<do\>" end="\<end\>" contains=TOP
line 82: " repeat ... until
line 83: syn region luaRepeatBlock transparent matchgroup=luaRepeat start="\<repeat\>" end="\<until\>" contains=TOP
line 84: 
line 85: " while ... do
line 86: syn region luaWhile transparent matchgroup=luaRepeat start="\<while\>" end="\<do\>"me=e-2 contains=TOP nextgroup=luaBlock skipwhite skipempty
line 87: 
line 88: " for ... do and for ... in ... do
line 89: syn region luaFor transparent matchgroup=luaRepeat start="\<for\>" end="\<do\>"me=e-2 contains=TOP nextgroup=luaBlock skipwhite skipempty
line 90: 
line 91: syn keyword luaFor contained containedin=luaFor in
line 92: 
line 93: " other keywords
line 94: syn keyword luaStatement return local break
line 95: if lua_version > 5 || (lua_version == 5 && lua_subversion >= 2)
line 96:   syn keyword luaStatement goto
line 97:   syn match luaLabel "::\I\i*::"
line 98: endif
line 99: 
line 100: " operators
line 101: syn keyword luaOperator and or not
line 102: 
line 103: if (lua_version == 5 && lua_subversion >= 3) || lua_version > 5
line 104:   syn match luaSymbolOperator "[#<>=~^&|*/%+-]\|\.\{2,3}"
line 105: elseif lua_version == 5 && (lua_subversion == 1 || lua_subversion == 2)
line 106:   syn match luaSymbolOperator "[#<>=~^*/%+-]\|\.\{2,3}"
line 107: else
line 108:   syn match luaSymbolOperator "[<>=~^*/+-]\|\.\{2,3}"
line 109: endif
line 110: 
line 111: " comments
line 112: syn keyword luaTodo            contained TODO FIXME XXX
line 113: syn match   luaComment         "--.*$" contains=luaTodo,@Spell
line 114: if lua_version == 5 && lua_subversion == 0
line 115:   syn region luaComment        matchgroup=luaCommentDelimiter start="--\[\[" end="\]\]" contains=luaTodo,luaInnerComment,@Spell
line 116:   syn region luaInnerComment   contained transparent start="\[\[" end="\]\]"
line 117: elseif lua_version > 5 || (lua_version == 5 && lua_subversion >= 1)
line 118:   " Comments in Lua 5.1: --[[ ... ]], [=[ ... ]=], [===[ ... ]===], etc.
line 119:   syn region luaComment        matchgroup=luaCommentDelimiter start="--\[\z(=*\)\[" end="\]\z1\]" contains=luaTodo,@Spell
line 120: endif
line 121: 
line 122: " first line may start with #!
line 123: syn match luaComment "\%^#!.*"
line 124: 
line 125: syn keyword luaConstant nil
line 126: if lua_version > 4
line 127:   syn keyword luaConstant true false
line 128: endif
line 129: 
line 130: " strings
line 131: syn match  luaSpecial contained #\\[\\abfnrtv'"[\]]\|\\[[:digit:]]\{,3}#
line 132: if lua_version == 5
line 133:   if lua_subversion == 0
line 134:     syn region luaString2 matchgroup=luaStringDelimiter start=+\[\[+ end=+\]\]+ contains=luaString2,@Spell
line 135:   else
line 136:     if lua_subversion >= 2
line 137:       syn match  luaSpecial contained #\\z\|\\x[[:xdigit:]]\{2}#
line 138:     endif
line 139:     if lua_subversion >= 3
line 140:       syn match  luaSpecial contained #\\u{[[:xdigit:]]\+}#
line 141:     endif
line 142:     syn region luaString2 matchgroup=luaStringDelimiter start="\[\z(=*\)\[" end="\]\z1\]" contains=@Spell
line 143:   endif
line 144: endif
line 145: syn region luaString matchgroup=luaStringDelimiter start=+'+ end=+'+ skip=+\\\\\|\\'+ contains=luaSpecial,@Spell
line 146: syn region luaString matchgroup=luaStringDelimiter start=+"+ end=+"+ skip=+\\\\\|\\"+ contains=luaSpecial,@Spell
line 147: 
line 148: " integer number
line 149: syn match luaNumber "\<\d\+\>"
line 150: " floating point number, with dot, optional exponent
line 151: syn match luaNumber  "\<\d\+\.\d*\%([eE][-+]\=\d\+\)\="
line 152: " floating point number, starting with a dot, optional exponent
line 153: syn match luaNumber  "\.\d\+\%([eE][-+]\=\d\+\)\=\>"
line 154: " floating point number, without dot, with exponent
line 155: syn match luaNumber  "\<\d\+[eE][-+]\=\d\+\>"
line 156: 
line 157: " hex numbers
line 158: if lua_version >= 5
line 159:   if lua_subversion == 1
line 160:     syn match luaNumber "\<0[xX]\x\+\>"
line 161:   elseif lua_subversion >= 2
line 162:     syn match luaNumber "\<0[xX][[:xdigit:].]\+\%([pP][-+]\=\d\+\)\=\>"
line 163:   endif
line 164: endif
line 165: 
line 166: " tables
line 167: syn region luaTableBlock transparent matchgroup=luaTable start="{" end="}" contains=TOP,luaStatement
line 168: 
line 169: " methods
line 170: syntax match luaFunc ":\@<=\k\+"
line 171: 
line 172: " built-in functions
line 173: syn keyword luaFunc assert collectgarbage dofile error next
line 174: syn keyword luaFunc print rawget rawset self tonumber tostring type _VERSION
line 175: 
line 176: if lua_version == 4
line 177:   syn keyword luaFunc _ALERT _ERRORMESSAGE gcinfo
line 178:   syn keyword luaFunc call copytagmethods dostring
line 179:   syn keyword luaFunc foreach foreachi getglobal getn
line 180:   syn keyword luaFunc gettagmethod globals newtag
line 181:   syn keyword luaFunc setglobal settag settagmethod sort
line 182:   syn keyword luaFunc tag tinsert tremove
line 183:   syn keyword luaFunc _INPUT _OUTPUT _STDIN _STDOUT _STDERR
line 184:   syn keyword luaFunc openfile closefile flush seek
line 185:   syn keyword luaFunc setlocale execute remove rename tmpname
line 186:   syn keyword luaFunc getenv date clock exit
line 187:   syn keyword luaFunc readfrom writeto appendto read write
line 188:   syn keyword luaFunc PI abs sin cos tan asin
line 189:   syn keyword luaFunc acos atan atan2 ceil floor
line 190:   syn keyword luaFunc mod frexp ldexp sqrt min max log
line 191:   syn keyword luaFunc log10 exp deg rad random
line 192:   syn keyword luaFunc randomseed strlen strsub strlower strupper
line 193:   syn keyword luaFunc strchar strrep ascii strbyte
line 194:   syn keyword luaFunc format strfind gsub
line 195:   syn keyword luaFunc getinfo getlocal setlocal setcallhook setlinehook
line 196: elseif lua_version == 5
line 197:   syn keyword luaFunc getmetatable setmetatable
line 198:   syn keyword luaFunc ipairs pairs
line 199:   syn keyword luaFunc pcall xpcall
line 200:   syn keyword luaFunc _G loadfile rawequal require
line 201:   if lua_subversion == 0
line 202:     syn keyword luaFunc getfenv setfenv
line 203:     syn keyword luaFunc loadstring unpack
line 204:     syn keyword luaFunc gcinfo loadlib LUA_PATH _LOADED _REQUIREDNAME
line 205:   else
line 206:     syn keyword luaFunc load select
line 207:     syn match   luaFunc /\<package\.cpath\>/
line 208:     syn match   luaFunc /\<package\.loaded\>/
line 209:     syn match   luaFunc /\<package\.loadlib\>/
line 210:     syn match   luaFunc /\<package\.path\>/
line 211:     syn match   luaFunc /\<package\.preload\>/
line 212:     if lua_subversion == 1
line 213:       syn keyword luaFunc getfenv setfenv
line 214:       syn keyword luaFunc loadstring module unpack
line 215:       syn match   luaFunc /\<package\.loaders\>/
line 216:       syn match   luaFunc /\<package\.seeall\>/
line 217:     elseif lua_subversion >= 2
line 218:       syn keyword luaFunc _ENV rawlen
line 219:       syn match   luaFunc /\<package\.config\>/
line 220:       syn match   luaFunc /\<package\.preload\>/
line 221:       syn match   luaFunc /\<package\.searchers\>/
line 222:       syn match   luaFunc /\<package\.searchpath\>/
line 223:     endif
line 224: 
line 225:     if lua_subversion >= 3
line 226:       syn match luaFunc /\<coroutine\.isyieldable\>/
line 227:     endif
line 228:     if lua_subversion >= 4
line 229:       syn keyword luaFunc warn
line 230:       syn match luaFunc /\<coroutine\.close\>/
line 231:     endif
line 232:     syn match luaFunc /\<coroutine\.running\>/
line 233:   endif
line 234:   syn match   luaFunc /\<coroutine\.create\>/
line 235:   syn match   luaFunc /\<coroutine\.resume\>/
line 236:   syn match   luaFunc /\<coroutine\.status\>/
line 237:   syn match   luaFunc /\<coroutine\.wrap\>/
line 238:   syn match   luaFunc /\<coroutine\.yield\>/
line 239: 
line 240:   syn match   luaFunc /\<string\.byte\>/
line 241:   syn match   luaFunc /\<string\.char\>/
line 242:   syn match   luaFunc /\<string\.dump\>/
line 243:   syn match   luaFunc /\<string\.find\>/
line 244:   syn match   luaFunc /\<string\.format\>/
line 245:   syn match   luaFunc /\<string\.gsub\>/
line 246:   syn match   luaFunc /\<string\.len\>/
line 247:   syn match   luaFunc /\<string\.lower\>/
line 248:   syn match   luaFunc /\<string\.rep\>/
line 249:   syn match   luaFunc /\<string\.sub\>/
line 250:   syn match   luaFunc /\<string\.upper\>/
line 251:   if lua_subversion == 0
line 252:     syn match luaFunc /\<string\.gfind\>/
line 253:   else
line 254:     syn match luaFunc /\<string\.gmatch\>/
line 255:     syn match luaFunc /\<string\.match\>/
line 256:     syn match luaFunc /\<string\.reverse\>/
line 257:   endif
line 258:   if lua_subversion >= 3
line 259:     syn match luaFunc /\<string\.pack\>/
line 260:     syn match luaFunc /\<string\.packsize\>/
line 261:     syn match luaFunc /\<string\.unpack\>/
line 262:     syn match luaFunc /\<utf8\.char\>/
line 263:     syn match luaFunc /\<utf8\.charpattern\>/
line 264:     syn match luaFunc /\<utf8\.codes\>/
line 265:     syn match luaFunc /\<utf8\.codepoint\>/
line 266:     syn match luaFunc /\<utf8\.len\>/
line 267:     syn match luaFunc /\<utf8\.offset\>/
line 268:   endif
line 269: 
line 270:   if lua_subversion == 0
line 271:     syn match luaFunc /\<table\.getn\>/
line 272:     syn match luaFunc /\<table\.setn\>/
line 273:     syn match luaFunc /\<table\.foreach\>/
line 274:     syn match luaFunc /\<table\.foreachi\>/
line 275:   elseif lua_subversion == 1
line 276:     syn match luaFunc /\<table\.maxn\>/
line 277:   elseif lua_subversion >= 2
line 278:     syn match luaFunc /\<table\.pack\>/
line 279:     syn match luaFunc /\<table\.unpack\>/
line 280:     if lua_subversion >= 3
line 281:       syn match luaFunc /\<table\.move\>/
line 282:     endif
line 283:   endif
line 284:   syn match   luaFunc /\<table\.concat\>/
line 285:   syn match   luaFunc /\<table\.insert\>/
line 286:   syn match   luaFunc /\<table\.sort\>/
line 287:   syn match   luaFunc /\<table\.remove\>/
line 288: 
line 289:   if lua_subversion == 2
line 290:     syn match   luaFunc /\<bit32\.arshift\>/
line 291:     syn match   luaFunc /\<bit32\.band\>/
line 292:     syn match   luaFunc /\<bit32\.bnot\>/
line 293:     syn match   luaFunc /\<bit32\.bor\>/
line 294:     syn match   luaFunc /\<bit32\.btest\>/
line 295:     syn match   luaFunc /\<bit32\.bxor\>/
line 296:     syn match   luaFunc /\<bit32\.extract\>/
line 297:     syn match   luaFunc /\<bit32\.lrotate\>/
line 298:     syn match   luaFunc /\<bit32\.lshift\>/
line 299:     syn match   luaFunc /\<bit32\.replace\>/
line 300:     syn match   luaFunc /\<bit32\.rrotate\>/
line 301:     syn match   luaFunc /\<bit32\.rshift\>/
line 302:   endif
line 303: 
line 304:   syn match   luaFunc /\<math\.abs\>/
line 305:   syn match   luaFunc /\<math\.acos\>/
line 306:   syn match   luaFunc /\<math\.asin\>/
line 307:   syn match   luaFunc /\<math\.atan\>/
line 308:   if lua_subversion < 3
line 309:     syn match   luaFunc /\<math\.atan2\>/
line 310:   endif
line 311:   syn match   luaFunc /\<math\.ceil\>/
line 312:   syn match   luaFunc /\<math\.sin\>/
line 313:   syn match   luaFunc /\<math\.cos\>/
line 314:   syn match   luaFunc /\<math\.tan\>/
line 315:   syn match   luaFunc /\<math\.deg\>/
line 316:   syn match   luaFunc /\<math\.exp\>/
line 317:   syn match   luaFunc /\<math\.floor\>/
line 318:   syn match   luaFunc /\<math\.log\>/
line 319:   syn match   luaFunc /\<math\.max\>/
line 320:   syn match   luaFunc /\<math\.min\>/
line 321:   if lua_subversion == 0
line 322:     syn match luaFunc /\<math\.mod\>/
line 323:     syn match luaFunc /\<math\.log10\>/
line 324:   elseif lua_subversion == 1
line 325:     syn match luaFunc /\<math\.log10\>/
line 326:   endif
line 327:   if lua_subversion >= 1
line 328:     syn match luaFunc /\<math\.huge\>/
line 329:     syn match luaFunc /\<math\.fmod\>/
line 330:     syn match luaFunc /\<math\.modf\>/
line 331:     if lua_subversion == 1 || lua_subversion == 2
line 332:       syn match luaFunc /\<math\.cosh\>/
line 333:       syn match luaFunc /\<math\.sinh\>/
line 334:       syn match luaFunc /\<math\.tanh\>/
line 335:     endif
line 336:   endif
line 337:   syn match   luaFunc /\<math\.rad\>/
line 338:   syn match   luaFunc /\<math\.sqrt\>/
line 339:   if lua_subversion < 3
line 340:     syn match   luaFunc /\<math\.pow\>/
line 341:     syn match   luaFunc /\<math\.frexp\>/
line 342:     syn match   luaFunc /\<math\.ldexp\>/
line 343:   else
line 344:     syn match   luaFunc /\<math\.maxinteger\>/
line 345:     syn match   luaFunc /\<math\.mininteger\>/
line 346:     syn match   luaFunc /\<math\.tointeger\>/
line 347:     syn match   luaFunc /\<math\.type\>/
line 348:     syn match   luaFunc /\<math\.ult\>/
line 349:   endif
line 350:   syn match   luaFunc /\<math\.random\>/
line 351:   syn match   luaFunc /\<math\.randomseed\>/
line 352:   syn match   luaFunc /\<math\.pi\>/
line 353: 
line 354:   syn match   luaFunc /\<io\.close\>/
line 355:   syn match   luaFunc /\<io\.flush\>/
line 356:   syn match   luaFunc /\<io\.input\>/
line 357:   syn match   luaFunc /\<io\.lines\>/
line 358:   syn match   luaFunc /\<io\.open\>/
line 359:   syn match   luaFunc /\<io\.output\>/
line 360:   syn match   luaFunc /\<io\.popen\>/
line 361:   syn match   luaFunc /\<io\.read\>/
line 362:   syn match   luaFunc /\<io\.stderr\>/
line 363:   syn match   luaFunc /\<io\.stdin\>/
line 364:   syn match   luaFunc /\<io\.stdout\>/
line 365:   syn match   luaFunc /\<io\.tmpfile\>/
line 366:   syn match   luaFunc /\<io\.type\>/
line 367:   syn match   luaFunc /\<io\.write\>/
line 368: 
line 369:   syn match   luaFunc /\<os\.clock\>/
line 370:   syn match   luaFunc /\<os\.date\>/
line 371:   syn match   luaFunc /\<os\.difftime\>/
line 372:   syn match   luaFunc /\<os\.execute\>/
line 373:   syn match   luaFunc /\<os\.exit\>/
line 374:   syn match   luaFunc /\<os\.getenv\>/
line 375:   syn match   luaFunc /\<os\.remove\>/
line 376:   syn match   luaFunc /\<os\.rename\>/
line 377:   syn match   luaFunc /\<os\.setlocale\>/
line 378:   syn match   luaFunc /\<os\.time\>/
line 379:   syn match   luaFunc /\<os\.tmpname\>/
line 380: 
line 381:   syn match   luaFunc /\<debug\.debug\>/
line 382:   syn match   luaFunc /\<debug\.gethook\>/
line 383:   syn match   luaFunc /\<debug\.getinfo\>/
line 384:   syn match   luaFunc /\<debug\.getlocal\>/
line 385:   syn match   luaFunc /\<debug\.getupvalue\>/
line 386:   syn match   luaFunc /\<debug\.setlocal\>/
line 387:   syn match   luaFunc /\<debug\.setupvalue\>/
line 388:   syn match   luaFunc /\<debug\.sethook\>/
line 389:   syn match   luaFunc /\<debug\.traceback\>/
line 390:   if lua_subversion == 1
line 391:     syn match luaFunc /\<debug\.getfenv\>/
line 392:     syn match luaFunc /\<debug\.setfenv\>/
line 393:   endif
line 394:   if lua_subversion >= 1
line 395:     syn match luaFunc /\<debug\.getmetatable\>/
line 396:     syn match luaFunc /\<debug\.setmetatable\>/
line 397:     syn match luaFunc /\<debug\.getregistry\>/
line 398:     if lua_subversion >= 2
line 399:       syn match luaFunc /\<debug\.getuservalue\>/
line 400:       syn match luaFunc /\<debug\.setuservalue\>/
line 401:       syn match luaFunc /\<debug\.upvalueid\>/
line 402:       syn match luaFunc /\<debug\.upvaluejoin\>/
line 403:     endif
line 404:     if lua_subversion >= 4
line 405:       syn match luaFunc /\<debug.setcstacklimit\>/
line 406:     endif
line 407:   endif
line 408: endif
line 409: 
line 410: " Define the default highlighting.
line 411: " Only when an item doesn't have highlighting yet
line 412: 
line 413: hi def link luaStatement        Statement
line 414: hi def link luaRepeat           Repeat
line 415: hi def link luaFor              Repeat
line 416: hi def link luaString           String
line 417: hi def link luaString2          String
line 418: hi def link luaStringDelimiter  luaString
line 419: hi def link luaNumber           Number
line 420: hi def link luaOperator         Operator
line 421: hi def link luaSymbolOperator   luaOperator
line 422: hi def link luaConstant         Constant
line 423: hi def link luaCond             Conditional
line 424: hi def link luaCondElse         Conditional
line 425: hi def link luaFunction         Function
line 426: hi def link luaMetaMethod       Function
line 427: hi def link luaComment          Comment
line 428: hi def link luaCommentDelimiter luaComment
line 429: hi def link luaTodo             Todo
line 430: hi def link luaTable            Structure
line 431: hi def link luaError            Error
line 432: hi def link luaParenError       Error
line 433: hi def link luaSpecial          SpecialChar
line 434: hi def link luaFunc             Identifier
line 435: hi def link luaLabel            Label
line 436: 
line 437: 
line 438: let b:current_syntax = "lua"
line 439: 
line 440: let &cpo = s:cpo_save
line 441: unlet s:cpo_save
line 442: " vim: et ts=8 sw=2
finished sourcing /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/syntax/lua.vim
continuing in nvim_exec2()
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/pack/dist/opt/matchit/syntax/lua.vim"
Searching for "/opt/homebrew/Cellar/neovim/0.10.2_1/lib/nvim/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/state/nvim/lazy/readme/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp_luasnip/after/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-path/after/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-buffer/after/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/indent-blankline.nvim/after/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/cmp-nvim-lsp/after/syntax/lua.vim"
Searching for "/Users/jkulrativid/.local/share/nvim/lazy/catppuccin/after/syntax/lua.vim"
Executing: syntax region lua1 start=+\%1l+ end=+\%4l+ contains=@LUA keepend-- INSERT --
Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand <Lua 292: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMovedI Autocommands for "*"
autocommand <Lua 659: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand <Lua 286: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing TextChangedI Autocommands for "*"
autocommand <Lua 642: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: 
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: 
Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand <Lua 292: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMovedI Autocommands for "*"
autocommand <Lua 659: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand <Lua 286: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing TextChangedI Autocommands for "*"
autocommand <Lua 642: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: 
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: -- INSERT ---- INSERT --
Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand <Lua 292: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMovedI Autocommands for "*"
autocommand <Lua 659: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand <Lua 286: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing TextChangedI Autocommands for "*"
autocommand <Lua 642: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: 
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: 
Executing WinScrolled Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in WinScrolled Autocommands for "*"

Executing WinScrolled Autocommands for "*"
autocommand lua require("todo-comments.highlight").highlight_win()

Executing: lua require("todo-comments.highlight").highlight_win()
Executing WinScrolled Autocommands for "*"
autocommand <Lua 232: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:40>

Executing: -- INSERT --
Executing WinClosed Autocommands for "*"
autocommand <Lua 181: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:350>

Executing: 
Executing BufWinLeave Autocommands for "*"
autocommand <Lua 161: ~/.local/share/nvim/lazy/nvim-dap-ui/lua/dapui/windows/init.lua:107>

Executing: 
Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand <Lua 292: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMovedI Autocommands for "*"
autocommand <Lua 659: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand <Lua 286: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing TextChangedI Autocommands for "*"
autocommand <Lua 642: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: 
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: 
Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand <Lua 292: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMovedI Autocommands for "*"
autocommand <Lua 659: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand <Lua 286: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing TextChangedI Autocommands for "*"
autocommand <Lua 642: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: 
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: 
Executing WinClosed Autocommands for "*"
autocommand <Lua 181: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:350>

Executing: 
Executing BufWinLeave Autocommands for "*"
autocommand <Lua 161: ~/.local/share/nvim/lazy/nvim-dap-ui/lua/dapui/windows/init.lua:107>

Executing: 
Executing ModeChanged Autocommands for "*"
autocommand <Lua 199: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:93>

Executing: 

Executing InsertLeave Autocommands for "*"
autocommand <Lua 647: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing InsertLeave Autocommands for "*"
autocommand <Lua 624: ~/.local/share/nvim/lazy/LuaSnip/lua/luasnip/init.lua:475>

Executing: 
Executing InsertLeave Autocommands for "<buffer=5>"
autocommand <Lua 614: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/semantic_tokens.lua:200>

Executing: 
Executing InsertLeave Autocommands for "<buffer=5>"
autocommand <Lua 669: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/diagnostic.lua:673>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing InsertEnter Autocommands for "*"
autocommand <Lua 214: ~/.local/share/nvim/lazy/copilot-cmp/lua/copilot_cmp/init.lua:55>

Executing: 
Executing InsertEnter Autocommands for "*"
autocommand <Lua 304: ~/.local/share/nvim/lazy/cmp-nvim-lsp/lua/cmp_nvim_lsp/init.lua:97>

Executing: 
Executing InsertEnter Autocommands for "*"
autocommand <Lua 653: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing ModeChanged Autocommands for "*"
autocommand <Lua 199: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:93>

Executing: -- INSERT --

Executing: lua require"cmp.utils.feedkeys".run(2)
Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand <Lua 292: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMovedI Autocommands for "*"
autocommand <Lua 659: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing ModeChanged Autocommands for "*"
autocommand <Lua 199: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:93>

Executing: 

Executing InsertLeave Autocommands for "*"
autocommand <Lua 647: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing InsertLeave Autocommands for "*"
autocommand <Lua 624: ~/.local/share/nvim/lazy/LuaSnip/lua/luasnip/init.lua:475>

Executing: 
Executing InsertLeave Autocommands for "<buffer=5>"
autocommand <Lua 614: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/semantic_tokens.lua:200>

Executing: 
Executing InsertLeave Autocommands for "<buffer=5>"
autocommand <Lua 669: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/diagnostic.lua:673>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing InsertEnter Autocommands for "*"
autocommand <Lua 214: ~/.local/share/nvim/lazy/copilot-cmp/lua/copilot_cmp/init.lua:55>

Executing: 
Executing InsertEnter Autocommands for "*"
autocommand <Lua 304: ~/.local/share/nvim/lazy/cmp-nvim-lsp/lua/cmp_nvim_lsp/init.lua:97>

Executing: 
Executing InsertEnter Autocommands for "*"
autocommand <Lua 653: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing ModeChanged Autocommands for "*"
autocommand <Lua 199: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:93>

Executing: -- INSERT --

Executing: lua require"cmp.utils.feedkeys".run(3)
Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand <Lua 292: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMovedI Autocommands for "*"
autocommand <Lua 659: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing CursorMovedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMovedI Autocommands for "*"

Executing CursorMovedI Autocommands for "*"
autocommand <Lua 292: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMovedI Autocommands for "*"
autocommand <Lua 659: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing TextChangedI Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in TextChangedI Autocommands for "*"

Executing TextChangedI Autocommands for "*"
autocommand <Lua 286: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing TextChangedI Autocommands for "*"
autocommand <Lua 642: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: 
Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: 
Executing ModeChanged Autocommands for "*"
autocommand <Lua 199: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:93>

Executing: 

Executing InsertLeave Autocommands for "*"
autocommand <Lua 647: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/autocmd.lua:22>

Executing: 
Executing InsertLeave Autocommands for "*"
autocommand <Lua 624: ~/.local/share/nvim/lazy/LuaSnip/lua/luasnip/init.lua:475>

Executing: 
Executing InsertLeave Autocommands for "<buffer=5>"
autocommand <Lua 614: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/semantic_tokens.lua:200>

Executing: 
Executing InsertLeave Autocommands for "<buffer=5>"
autocommand <Lua 669: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/diagnostic.lua:673>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>45_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>45_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>45_Remove_Matches returning #0

continuing in <SNR>45_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let c_before = text->strpart(0, c_col - 1)->slice(-1)
line 20:   let c = text->strpart(c_col - 1)->slice(0, 1)
line 21:   let plist = split(&matchpairs, '.\zs[:,]')
line 22:   let i = index(plist, c)
line 23:   if i < 0
line 24:     " not found, in Insert mode try character before the cursor
line 25:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 26:       let before = strlen(c_before)
line 27:       let c = c_before
line 28:       let i = index(plist, c)
line 29:     endif
line 30:     if i < 0
line 31:       " not found, nothing to do
line 32:       return
<SNR>45_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand <Lua 293: ~/.local/share/nvim/lazy/indent-blankline.nvim/lua/ibl/autocmds.lua:26>

Executing: 
Executing ModeChanged Autocommands for "*"
autocommand <Lua 199: ~/.local/share/nvim/lazy/which-key.nvim/lua/which-key/state.lua:93>

Executing: 

Executing: wq
Executing BufWritePre Autocommands for "*"
autocommand <Lua 538: ~/.local/share/nvim/lazy/conform.nvim/lua/conform/init.lua:99>

Executing: 
Executing BufWritePre Autocommands for "<buffer=5>"
autocommand <Lua 583: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp.lua:541>

Executing: 
Executing BufWritePre Autocommands for "<buffer=5>"
autocommand <Lua 511: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/attach.lua:361>

Executing: 
           "lua/jetnipit/plugins/lint.lua" 
"lua/jetnipit/plugins/lint.lua" 67L, 2117B written
Executing BufWritePost Autocommands for "*"
autocommand lua require'lualine.components.diff.git_diff'.update_git_diff()

Executing: lua require'lualine.components.diff.git_diff'.update_git_diff()
Executing BufWritePost Autocommands for "*"
autocommand <Lua 546: ~/.local/share/nvim/lazy/nvim-tree.lua/lua/nvim-tree/explorer/init.lua:94>

Executing: 
Executing BufWritePost Autocommands for "*"
autocommand <Lua 360: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns.lua:148>

Executing: 
Executing BufWritePost Autocommands for "<buffer=5>"
autocommand <Lua 584: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp.lua:568>

Executing: 
Executing BufWritePost Autocommands for "*"
autocommand <Lua 625: ~/.local/share/nvim/lazy/LuaSnip/lua/luasnip/loaders/fs_watchers.lua:66>

Executing: 
Executing BufWritePost Autocommands for "*"
autocommand <Lua 604: ~/.config/nvim/lua/jetnipit/plugins/lint.lua:45>

Executing: 
Executing ExitPre Autocommands for "*"
autocommand <Lua 130: ~/.local/share/nvim/lazy/nvim-dap/lua/dap.lua:1338>

Executing: 
Executing BufWinLeave Autocommands for "*"
autocommand <Lua 161: ~/.local/share/nvim/lazy/nvim-dap-ui/lua/dapui/windows/init.lua:107>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 146: ~/.local/share/nvim/lazy/dap-helper.nvim/lua/dap-helper/init.lua:79>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 544: ~/.local/share/nvim/lazy/nvim-tree.lua/lua/nvim-tree/explorer/init.lua:115>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 146: ~/.local/share/nvim/lazy/dap-helper.nvim/lua/dap-helper/init.lua:79>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 544: ~/.local/share/nvim/lazy/nvim-tree.lua/lua/nvim-tree/explorer/init.lua:115>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 146: ~/.local/share/nvim/lazy/dap-helper.nvim/lua/dap-helper/init.lua:79>

Executing: 
Executing BufUnload Autocommands for "*"
autocommand <Lua 544: ~/.local/share/nvim/lazy/nvim-tree.lua/lua/nvim-tree/explorer/init.lua:115>

Executing: 
Executing VimLeavePre Autocommands for "*"
autocommand <Lua 180: ~/.local/share/nvim/lazy/auto-session/lua/auto-session/autocmds.lua:337>

Executing: %argdelete
Executing: mks! /Users/jkulrativid/.local/share/nvim/sessions/\%2FUsers\%2Fjkulrativid\%2F\%2Econfig\%2Fnvim.vim
chdir(/Users/jkulrativid/.config/nvim)
Executing: 
Executing VimLeavePre Autocommands for "*"
autocommand <Lua 564: ~/.local/share/nvim/lazy/conform.nvim/lua/conform/init.lua:128>

Executing LspNotify Autocommands for "*"
autocommand <Lua 724: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp/inlay_hint.lua:263>

Executing: 
Executing: 
Executing VimLeavePre Autocommands for "*"
autocommand <Lua 313: /opt/homebrew/Cellar/neovim/0.10.2_1/share/nvim/runtime/lua/vim/lsp.lua:797>

Executing: 
Executing VimLeavePre Autocommands for "*"
autocommand <Lua 531: ~/.local/share/nvim/lazy/gitsigns.nvim/lua/gitsigns/attach.lua:375>

Executing: 
Executing VimLeavePre Autocommands for "*"
autocommand <Lua 423: ~/.local/share/nvim/lazy/nvim-cmp/lua/cmp/utils/async.lua:17>

Executing: 
Writing ShaDa file "/Users/jkulrativid/.local/state/nvim/shada/main.shada"